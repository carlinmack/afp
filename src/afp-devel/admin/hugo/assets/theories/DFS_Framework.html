<div id="DFS_Framework_Misc">
<div class="head">
<h1>Theory DFS_Framework_Misc</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> DFS_Framework_Misc
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../Automatic_Refinement/Misc.html">Automatic_Refinement.Misc</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* General *)</span>
<span class="keyword1" id="DFS_Framework_Misc-tri_caseE"><span class="command">lemma</span></span> tri_caseE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⟦</span><span class="main">¬</span><span class="free">P</span><span class="main">;</span><span class="main">¬</span><span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">R</span><span class="main">;</span> <span class="main">⟦</span><span class="main">¬</span><span class="free">P</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(* TODO: How often have we formalized this now? *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">opt_tag</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1" id="DFS_Framework_Misc-opt_tagI"><span class="command">lemma</span></span> opt_tagI<span class="main">:</span> <span class="quoted"><span class="quoted">"opt_tag <span class="free">x</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> opt_tag_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="DFS_Framework_Misc-opt_tagD"><span class="command">lemma</span></span> opt_tagD<span class="main">:</span> <span class="quoted"><span class="quoted">"opt_tag <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> opt_tag_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Usage example, to simplify term
  schematic_lemma "term = ?c"
    apply (rule opt_tagD)
    apply simp, unfold, whatever ...
    by (rule opt_tagI)
*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="DFS_Framework_Refine_Aux">
<div class="head">
<h1>Theory DFS_Framework_Refine_Aux</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> DFS_Framework_Refine_Aux
<span class="keyword2"><span class="keyword">imports</span></span> <a href="DFS_Framework_Misc.html">DFS_Framework_Misc</a> <a href="../Refine_Monadic/Refine_Monadic.html">Refine_Monadic.Refine_Monadic</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">GHOST</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> 
  <span class="comment1">― ‹Ghost tag to mark ghost variables in let-expressions›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">GHOST</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span>
<span class="keyword1" id="DFS_Framework_Refine_Aux-GHOST_elim_Let"><span class="command">lemma</span></span> GHOST_elim_Let<span class="main">:</span> <span class="comment1">― ‹Unfold rule to inline GHOST-Lets›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="bound">x</span><span class="main">=</span>GHOST <span class="free">m</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"WHILEI <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s</span> <span class="main">≤</span> 
  <span class="keyword1">do</span> <span class="main">{</span>ASSERT <span class="main">(</span><span class="free">I</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> WHILE <span class="free">b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">s</span> <span class="main">←</span> <span class="free">f</span> <span class="bound">s</span><span class="main">;</span> ASSERT <span class="main">(</span><span class="free">I</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span> RETURN <span class="bound">s</span><span class="main">}</span><span class="main">)</span> <span class="free">s</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> WHILEI_def WHILE_def WHILEI_body_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> introR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"br id <span class="free">I</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"br id <span class="free">I</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* TODO: Move to RefineG_While *)</span>
<span class="keyword1" id="DFS_Framework_Refine_Aux-WHILET_eq_WHILE"><span class="command">lemma</span></span> WHILET_eq_WHILE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"WHILET <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">≠</span> top"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"WHILET <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">=</span> WHILE <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> WHILET_def WHILE_def WHILEIT_def WHILEI_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> RECT_eq_REC<span class="main">)</span>

<span class="keyword1" id="DFS_Framework_Refine_Aux-WHILEIT_eq_WHILEI"><span class="command">lemma</span></span> WHILEIT_eq_WHILEI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"WHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">≠</span> top"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"WHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">=</span> WHILEI <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> WHILEIT_def WHILEI_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> RECT_eq_REC<span class="main">)</span>

<span class="comment1">(* TODO: Move to refinement framework! *)</span>
<span class="keyword1" id="DFS_Framework_Refine_Aux-WHILEIT_le_WHILEI"><span class="command">lemma</span></span> WHILEIT_le_WHILEI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VAR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> SPEC <span class="free">I</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"WHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s</span> <span class="main">≤</span> WHILEI <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹wf <span class="free">V</span>›</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_induct<span class="main"><span class="main">[</span></span><span class="operator">consumes</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> WHILEIT_unfold<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> WHILEI_unfold<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="skolem">x</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span> <span class="main">⟶</span> WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup><span class="free">I</span></sup><span class="hidden">⇖</span> <span class="free">b</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">≤</span> WHILE<span class="hidden">⇗</span><sup><span class="free">I</span></sup><span class="hidden">⇖</span> <span class="free">b</span> <span class="free">f</span> <span class="bound">y</span>"</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">⤜</span> WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup><span class="free">I</span></sup><span class="hidden">⇖</span> <span class="free">b</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="skolem">x</span> <span class="main">⤜</span> WHILE<span class="hidden">⇗</span><sup><span class="free">I</span></sup><span class="hidden">⇖</span> <span class="free">b</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">≤</span> SPEC <span class="free">I</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Refine_Basic.bind_mono<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> order_refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> IH VAR<span class="main">[</span><span class="operator">OF</span> A B<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="free">f</span> <span class="skolem">x</span> <span class="main">≤</span> SPEC <span class="free">I</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">⤜</span> WHILE<span class="hidden">⇗</span><sup><span class="free">I</span></sup><span class="hidden">⇖</span> <span class="free">b</span> <span class="free">f</span> <span class="main">=</span> FAIL"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> WHILEI_unfold<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eq_iff pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> WHILEIT_refine_WHILEI <span class="main">=</span> order_trans<span class="main">[</span><span class="operator">OF</span> WHILEIT_le_WHILEI WHILEI_refine<span class="main">]</span>


<span class="keyword1" id="DFS_Framework_Refine_Aux-WHILET_eq_WHILE_tproof"><span class="command">lemma</span></span> WHILET_eq_WHILE_tproof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">b</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"WHILET <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">=</span> WHILE <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"WHILET <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">≤</span> SPEC <span class="free">I</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">I</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"WHILET <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">≠</span> top"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> WHILE_def WHILEI_def WHILET_def WHILEIT_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> RECT_eq_REC<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  


<span class="keyword1" id="DFS_Framework_Refine_Aux-WHILEIT_eq_WHILEI_tproof"><span class="command">lemma</span></span> WHILEIT_eq_WHILEI_tproof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">b</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"WHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span> <span class="main">=</span> WHILEI <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s0</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> WHILEIT_le_WHILEI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> WHILEI_le_WHILEIT<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  



<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Impl_Rev_Array_Stack">
<div class="head">
<h1>Theory Impl_Rev_Array_Stack</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stack by Reversed Array›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Impl_Rev_Array_Stack
<span class="keyword2"><span class="keyword">imports</span></span>   
  <a href="../CAVA_Base/CAVA_Base.html">CAVA_Base.CAVA_Base</a>
  <a href="DFS_Framework_Refine_Aux.html">DFS_Framework_Refine_Aux</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(* TODO: Move theory to GenCF/Impl *)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> rev_array_stack <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> array <span class="main">×</span> nat"</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">Diff_Array.array_length</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_raw_α</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> rev <span class="main">(</span>take <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span>list_of_array <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_raw_invar</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> snd <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≤</span> array_length <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> ras_rel_def_internal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ras_rel</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> br ras_raw_α ras_raw_invar <span class="keyword1">O</span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">⟩</span>list_rel"</span></span>
<span class="keyword1" id="Impl_Rev_Array_Stack-ras_rel_def"><span class="command">lemma</span></span> ras_rel_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">≡</span> br ras_raw_α ras_raw_invar <span class="keyword1">O</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>list_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ras_rel_def_internal<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> relAPP_def<span class="main">)</span>


<span class="comment1">(* TODO: Fix relator-props solver to also include atac! *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued <span class="free">R</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ras_rel_def
  <span class="comment1">(*apply (tactic {* REPEAT_ALL_NEW (atac ORELSE' (resolve_tac @{thms relator_props})) 1*})*)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">tagged_solver</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">ras_rel</span> <span class="quoted">i_list</span><span class="main">]</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_empty</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">::</span>unit<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span>array_of_list <span class="main">[]</span><span class="main">,</span><span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_empty_refine"><span class="command">lemma</span></span> ras_empty_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_empty <span class="main">()</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ras_rel_def ras_empty_def br_def
  <span class="keyword1"><span class="command">unfolding</span></span> ras_raw_α_def ras_raw_invar_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_push</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">a</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> array_length <span class="bound">a</span> <span class="keyword1">then</span>
        array_grow <span class="bound">a</span> <span class="main">(</span>max <span class="numeral">4</span> <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>
      <span class="keyword1">else</span> <span class="bound">a</span><span class="main">;</span>
    <span class="bound">a</span> <span class="main">=</span> array_set <span class="bound">a</span> <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>
  <span class="keyword1">in</span>
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_push_refine"><span class="command">lemma</span></span> ras_push_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_push<span class="main">,</span><span class="main">(#)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_push_def ras_rel_def br_def
    ras_raw_α_def ras_raw_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> array_length_list<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_Suc_conv_app_nth array_length_list list_update_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">array_shrink</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_shrink</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> 
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">a</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="numeral">128</span><span class="main">*</span><span class="bound">n</span> <span class="main">≤</span> array_length <span class="bound">a</span> <span class="main">∧</span> <span class="bound">n</span><span class="main">&gt;</span><span class="numeral">4</span> <span class="keyword1">then</span>
        array_shrink <span class="bound">a</span> <span class="bound">n</span>
      <span class="keyword1">else</span> <span class="bound">a</span>
  <span class="keyword1">in</span>
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_shrink_id_refine"><span class="command">lemma</span></span> ras_shrink_id_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_shrink<span class="main">,</span>id<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_shrink_def ras_rel_def br_def
    ras_raw_α_def ras_raw_invar_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> array_length_list<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_shrinkI"><span class="command">lemma</span></span> ras_shrinkI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">a</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_shrink <span class="free">s</span><span class="main">,</span><span class="free">a</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> id_apply<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">parametricity</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_shrink_id_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_pop</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> ras_shrink <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>


<span class="keyword1" id="Impl_Rev_Array_Stack-ras_pop_refine"><span class="command">lemma</span></span> ras_pop_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_pop<span class="main">,</span>tl<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_pop_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ras_shrinkI<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_pop_def ras_rel_def br_def
    ras_raw_α_def ras_raw_invar_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> array_length_list<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> array_length_list 
    take_minus_one_conv_butlast rev_butlast_is_tl_rev<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_get</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> array_get <span class="bound">a</span> <span class="main">(</span><span class="bound">n</span><span class="main">-</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_get_refine"><span class="command">lemma</span></span> ras_get_refine<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i'</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 3<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_get <span class="free">a</span> <span class="free">i</span><span class="main">,</span><span class="free">l</span><span class="main">!</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> 2
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_get_def ras_rel_def br_def ras_raw_α_def ras_raw_invar_def
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> aa bb<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">aa</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">cl</span>
  <span class="keyword3"><span class="command">assume</span></span> TKR<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rev <span class="main">(</span>take <span class="skolem">n</span> <span class="skolem">cl</span><span class="main">)</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>list_rel"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> NLE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≤</span> length <span class="skolem">cl</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rev <span class="main">(</span>take <span class="skolem">n</span> <span class="skolem">cl</span><span class="main">)</span><span class="main">!</span><span class="free">i</span><span class="main">,</span> <span class="free">l</span><span class="main">!</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">parametricity</span> <span class="main">(</span><span class="operator">rule</span> 1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rev <span class="main">(</span>take <span class="skolem">n</span> <span class="skolem">cl</span><span class="main">)</span><span class="main">!</span><span class="free">i</span> <span class="main">=</span> <span class="main">(</span>take <span class="skolem">n</span> <span class="skolem">cl</span><span class="main">)</span><span class="main">!</span><span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> Suc <span class="free">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rev_nth<span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> 1 3 list_rel_imp_same_length<span class="main">[</span><span class="operator">OF</span> TKR<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_absorb2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> NLE<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"take <span class="skolem">n</span> <span class="skolem">cl</span><span class="main">!</span><span class="main">(</span><span class="skolem">n</span><span class="main">-</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">cl</span><span class="main">!</span><span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> Suc <span class="free">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> 1 3 list_rel_imp_same_length<span class="main">[</span><span class="operator">OF</span> TKR<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cl</span><span class="main">!</span><span class="main">(</span><span class="skolem">n</span><span class="main">-</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">,</span><span class="free">l</span><span class="main">!</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1" id="Impl_Rev_Array_Stack-ras_get_autoref"><span class="command">lemma</span></span> ras_get_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span><span class="free">i'</span> <span class="main">&lt;</span> length <span class="free">l'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_get <span class="free">l</span> <span class="free">i</span><span class="main">,</span><span class="main">(</span><span class="keyword1">OP</span> nth <span class="main">:::</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> nat_rel <span class="main">→</span> <span class="free">R</span><span class="main">)</span><span class="main">$</span><span class="free">l'</span><span class="main">$</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_get_refine<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_set</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span>array_set <span class="bound">a</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="bound">n</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_set_refine"><span class="command">lemma</span></span> ras_set_refine<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i'</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 3<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 4<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_set <span class="free">a</span> <span class="free">i</span> <span class="free">x</span><span class="main">,</span> <span class="free">l</span><span class="main">[</span><span class="free">i'</span><span class="main">:=</span><span class="free">x'</span><span class="main">]</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_set_def ras_rel_def br_def ras_raw_α_def ras_raw_invar_def
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_rel_def br_def ras_raw_invar_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rev_update<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> 1 2 3 4 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_rel_def br_def ras_raw_invar_def ras_raw_α_def<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ar n<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">ar</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> list_rel_imp_same_length<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
  <span class="keyword1"><span class="command">using</span></span> 2 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_rel_def br_def ras_raw_invar_def ras_raw_α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command">using</span></span> 1 2 4
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_rel_def br_def ras_raw_invar_def ras_raw_α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ar n<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">ar</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> list_rel_imp_same_length<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_set_autoref"><span class="command">lemma</span></span> ras_set_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span><span class="free">i'</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 3<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span><span class="free">i'</span> <span class="main">&lt;</span> length <span class="free">l'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_set <span class="free">l</span> <span class="free">i</span> <span class="free">x</span><span class="main">,</span>
    <span class="main">(</span><span class="keyword1">OP</span> list_update <span class="main">:::</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> nat_rel <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel<span class="main">)</span><span class="main">$</span><span class="free">l'</span><span class="main">$</span><span class="free">i'</span><span class="main">$</span><span class="free">x'</span>
    <span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_set_refine<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ras_length</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rev_array_stack <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ras_length</span> <span class="main">=</span> snd"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_length_refine"><span class="command">lemma</span></span> ras_length_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_length<span class="main">,</span>length<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> nat_rel"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_length_def ras_rel_def br_def ras_raw_α_def ras_raw_invar_def
      array_length_list
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> list_rel_imp_same_length
  <span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_top</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ras_get <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">0</span>"</span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_top_code"><span class="command">lemma</span></span> ras_top_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ras_top <span class="free">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">=</span><span class="free">s</span> <span class="keyword1">in</span> array_get <span class="bound">a</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ras_top_def ras_get_def ras_length_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_top_refine"><span class="command">lemma</span></span> ras_top_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">l</span><span class="main">≠</span><span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel<span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>ras_top <span class="free">s</span><span class="main">,</span>hd <span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ras_top_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ras_get_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ras_length_def ras_rel_def br_def ras_raw_α_def 
    ras_raw_invar_def array_length_list
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> list_rel_imp_same_length<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_top_autoref"><span class="command">lemma</span></span> ras_top_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span><span class="free">l'</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_top <span class="free">l</span><span class="main">,</span><span class="main">(</span><span class="keyword1">OP</span> hd <span class="main">:::</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> <span class="free">R</span><span class="main">)</span><span class="main">$</span><span class="free">l'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_top_refine<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_is_empty</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ras_length <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1" id="Impl_Rev_Array_Stack-ras_is_empty_code"><span class="command">lemma</span></span> ras_is_empty_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ras_is_empty <span class="free">s</span> <span class="main">=</span> <span class="main">(</span>snd <span class="free">s</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ras_is_empty_def ras_length_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Impl_Rev_Array_Stack-ras_is_empty_refine"><span class="command">lemma</span></span> ras_is_empty_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_is_empty<span class="main">,</span>is_Nil<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> bool_rel"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">l</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_is_empty <span class="skolem">s</span><span class="main">,</span>length <span class="skolem">l</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∈</span> bool_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ras_is_empty_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">parametricity</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_length_refine<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">l</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> is_Nil <span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_is_empty <span class="skolem">s</span><span class="main">,</span> is_Nil <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> bool_rel"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_singleton</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">(</span>array_of_list <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">,</span><span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1" id="Impl_Rev_Array_Stack-ras_singleton_refine"><span class="command">lemma</span></span> ras_singleton_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_singleton<span class="main">,</span>op_list_singleton<span class="main">)</span><span class="main">∈</span><span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_singleton_def ras_rel_def br_def ras_raw_α_def 
    ras_raw_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> array_length_list<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ras_cast_to_list</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> rev <span class="main">(</span>take <span class="bound">n</span> <span class="main">(</span>list_of_array <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1" id="Impl_Rev_Array_Stack-ras_cast_to_list_refine"><span class="command">lemma</span></span> ras_cast_to_list_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ras_cast_to_list<span class="main">,</span> CAST<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>ras_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>list_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ras_cast_to_list_def ras_rel_def br_def ras_raw_α_def 
    ras_raw_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> array_length_list<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="On_Stack">
<div class="head">
<h1>Theory On_Stack</h1>
</div>
<pre class="source"><span class="comment1">(* Currently not used, but may be of general use. Keep in Aux! *)</span>
<span class="keyword1"><span class="command">theory</span></span> On_Stack
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../Collections/Refine_Dflt.html">Collections.Refine_Dflt</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of a stack with efficient on-stack operation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This generic implementation combines a stack implementation and
  a set implementation that is used to keep track of the elements on the stack.
  It requires a distinct stack, i.e., no duplicate elements on the stack.

  Note that this generic implementation has to be instantiated to a
  concrete stack-relation in order to avoid looping of the autoref-tool,
  which otherwise tries to instantiate the stack-implementation with itself
  indefinitely often.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> stack_rel_internal_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stack_rel</span> <span class="free"><span class="bound"><span class="entity">lrel</span></span></span> <span class="free"><span class="bound"><span class="entity">srel</span></span></span> <span class="free"><span class="bound"><span class="entity">vrel</span></span></span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="main">(</span><span class="bound">li</span><span class="main">,</span><span class="bound">si</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">li</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">vrel</span></span></span><span class="main">⟩</span><span class="free"><span class="bound"><span class="entity">lrel</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">si</span><span class="main">,</span>set <span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">vrel</span></span></span><span class="main">⟩</span><span class="free"><span class="bound"><span class="entity">srel</span></span></span> <span class="main">∧</span> distinct <span class="bound">l</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="On_Stack-stack_rel_def"><span class="command">lemma</span></span> stack_rel_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="main">(</span><span class="bound">li</span><span class="main">,</span><span class="bound">si</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">li</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">si</span><span class="main">,</span>set <span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span> <span class="main">∧</span> distinct <span class="bound">l</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_internal_def relAPP_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> 
  <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span> <span class="quoted">i_list</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">lrel</span> <span class="free">srel</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">lrel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'xi</span> <span class="main">×</span> <span class="tfree">'x</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'xli</span> <span class="main">×</span> <span class="tfree">'x</span> list<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">srel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'xi</span> <span class="main">×</span> <span class="tfree">'x</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'xsi</span> <span class="main">×</span> <span class="tfree">'x</span> set<span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="On_Stack-autoref_stack_empty"><span class="command">lemma</span></span> autoref_stack_empty<span class="main">[</span><span class="operator">OF</span> GEN_OP_D GEN_OP_D<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">es</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">el</span><span class="main">,</span><span class="free">es</span><span class="main">)</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">stack_push</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">_</span><span class="main">::</span>type"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stack_push</span> <span class="free"><span class="bound"><span class="entity">push</span></span></span> <span class="free"><span class="bound"><span class="entity">ins</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">push</span></span></span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ins</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="On_Stack-autoref_stack_push"><span class="command">lemma</span></span> autoref_stack_push<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">push</span> op_list_append_elem <span class="main">(</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span> <span class="main">→</span> <span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">ins</span> insert <span class="main">(</span><span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span><span class="free">v</span><span class="main">∉</span>set <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">vi</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">vrel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>stack_push <span class="free">push</span> <span class="free">ins</span> <span class="free">si</span> <span class="free">vi</span><span class="main">,</span>
    <span class="main">(</span><span class="keyword1">OP</span> op_list_append_elem <span class="main">:::</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span> <span class="main">→</span> <span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span><span class="main">)</span>
      <span class="main">$</span><span class="free">l</span><span class="main">$</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> op_list_append_elem_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="On_Stack-autoref_stack_sng"><span class="command">lemma</span></span> autoref_stack_sng<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">lsng</span> op_list_singleton <span class="main">(</span><span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">sins</span> insert <span class="main">(</span><span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">semp</span> <span class="main">{}</span> <span class="main">(</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">lsng</span> <span class="bound">v</span><span class="main">,</span> <span class="free">sins</span> <span class="bound">v</span> <span class="free">semp</span><span class="main">)</span><span class="main">,</span>op_list_singleton<span class="main">)</span> 
    <span class="main">∈</span> <span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def <span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> op_list_singleton_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD<span class="main">)</span>
  
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">stack_pop</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">_</span><span class="main">::</span>type"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stack_pop</span> <span class="free"><span class="bound"><span class="entity">lpop</span></span></span> <span class="free"><span class="bound"><span class="entity">ltop</span></span></span> <span class="free"><span class="bound"><span class="entity">del</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> 
    <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ltop</span></span></span> <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">;</span> <span class="bound">el</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">lpop</span></span></span> <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">;</span> <span class="bound">es</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">del</span></span></span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">el</span><span class="main">,</span><span class="bound">es</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="On_Stack-autoref_stack_pop"><span class="command">lemma</span></span> autoref_stack_pop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> POPR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">el</span> <span class="bound">l</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">el</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span><span class="main">;</span> <span class="bound">l</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="free">lpop</span> <span class="bound">el</span><span class="main">,</span><span class="main">(</span><span class="keyword1">OP</span> butlast <span class="main">:::</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span><span class="main">)</span><span class="main">$</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TOPR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">el</span> <span class="bound">l</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">el</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span><span class="main">;</span> <span class="bound">l</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="free">ltop</span> <span class="bound">el</span><span class="main">,</span><span class="main">(</span><span class="keyword1">OP</span> last <span class="main">:::</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span> <span class="main">→</span> <span class="free">vrel</span><span class="main">)</span><span class="main">$</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span> <span class="free">vrel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DELR<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">del</span> op_set_delete <span class="main">(</span><span class="free">vrel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span><span class="free">l</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>stack_pop <span class="free">lpop</span> <span class="free">ltop</span> <span class="free">del</span> <span class="free">si</span><span class="main">,</span>
    <span class="main">(</span><span class="keyword1">OP</span> butlast <span class="main">:::</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span><span class="main">)</span>
      <span class="main">$</span><span class="free">l</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> POPR TOPR DELR
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">param</span><span class="main">]</span> <span class="main">=</span> this<span class="main">[</span><span class="operator">unfolded</span> <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span></span></span></span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">have</span></span> AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="free">l</span><span class="main">)</span> <span class="main">=</span> op_set_delete <span class="main">(</span>last <span class="free">l</span><span class="main">)</span> <span class="main">(</span>set <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> NE R <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> NE R <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def <span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_butlast<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> AUX<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="On_Stack-autoref_stack_set"><span class="command">lemma</span></span> autoref_stack_set<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snd<span class="main">,</span> set<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">srel</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="On_Stack-autoref_stack_is_Nil"><span class="command">lemma</span></span> autoref_stack_is_Nil<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">ini</span> is_Nil <span class="main">(</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span> <span class="main">→</span> bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ini</span> <span class="keyword1">o</span> fst<span class="main">,</span> is_Nil<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD<span class="main">)</span>

<span class="keyword1" id="On_Stack-autoref_stack_ltop"><span class="command">lemma</span></span> autoref_stack_ltop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TOPR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">el</span> <span class="bound">l</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">el</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span><span class="main">;</span> <span class="bound">l</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="free">ltop</span> <span class="bound">el</span><span class="main">,</span><span class="main">(</span><span class="keyword1">OP</span> last <span class="main">:::</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span><span class="free">lrel</span> <span class="main">→</span> <span class="free">vrel</span><span class="main">)</span><span class="main">$</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span> <span class="free">vrel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span><span class="free">l</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ltop</span> <span class="main">(</span>fst <span class="free">si</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="keyword1">OP</span> last <span class="main">:::</span> <span class="main">⟨</span><span class="free">vrel</span><span class="main">⟩</span>stack_rel <span class="free">lrel</span> <span class="free">srel</span> <span class="main">→</span> <span class="free">vrel</span><span class="main">)</span><span class="main">$</span><span class="free">l</span><span class="main">)</span> <span class="main">∈</span> <span class="free">vrel</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> stack_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> stack_autoref_rules 
  <span class="main">=</span> autoref_stack_empty autoref_stack_push autoref_stack_sng autoref_stack_pop
    autoref_stack_set autoref_stack_is_Nil autoref_stack_ltop

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">as_ahs_stack_rel</span> <span class="main">≡</span> stack_rel as_rel dflt_ahs_rel"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> as_ahs_stack_rules 
  <span class="main">=</span> stack_autoref_rules<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> lrel <span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">as_rel</span></span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span></span></span></span></span> srel <span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">dflt_ahs_rel</span></span></span></span></span></span></span><span class="main">]</span>


<span class="keyword1"><span class="command">schematic_goal</span></span> 
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> as_ahs_stack_rules
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">,</span> set <span class="main">(</span>butlast <span class="main">(</span><span class="main">[</span><span class="main">1</span><span class="main">::</span>nat<span class="main">]</span><span class="main">@</span><span class="main">[</span><span class="numeral">2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="DFS_Chapter_Framework">
<div class="head">
<h1>Theory DFS_Chapter_Framework</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">"The DFS Framework"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This chapter contains the basic DFS Framework
›</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> DFS_Chapter_Framework
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Param_DFS">
<div class="head">
<h1>Theory Param_DFS</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹General DFS with Hooks›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Param_DFS
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../CAVA_Base/CAVA_Base.html">CAVA_Base.CAVA_Base</a>
  <a href="../CAVA_Automata/Digraph.html">CAVA_Automata.Digraph</a>
  <span class="quoted">"<a href="DFS_Framework_Refine_Aux.html">Misc/DFS_Framework_Refine_Aux</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define a general DFS algorithm, which is parameterized over
  hook functions at certain events during the DFS.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State and Parameterization›</span></span>
<span class="comment1">(* A DFS with timing and a stack, phrased iteratively *)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The state of the general DFS. 
  Users may inherit from this state using the record package's 
  inheritance support.
›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> state <span class="main">=</span>
  counter <span class="main">::</span> <span class="quoted">nat</span>               <span class="comment1">― ‹Node counter (timer)›</span>
  discovered <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇀</span> nat"</span></span>    <span class="comment1">― ‹Discovered times of nodes›</span>
  finished <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇀</span> nat"</span></span>      <span class="comment1">― ‹Finished times of nodes›</span>
  pending <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span>  <span class="comment1">― ‹Edges to be processed next›</span>
  stack <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> list"</span></span>          <span class="comment1">― ‹Current DFS stack›</span>
  tree_edges <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> rel"</span></span>      <span class="comment1">― ‹Tree edges›</span>
  back_edges <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> rel"</span></span>      <span class="comment1">― ‹Back edges›</span>
  cross_edges <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> rel"</span></span>     <span class="comment1">― ‹Cross edges›</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">NOOP</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span>state.more <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Record holding the parameterization.›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_parameterization <span class="main">=</span>
  on_init <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'es</span> nres"</span></span>
  on_new_root <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'es</span> nres"</span></span>
  on_discover <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'es</span> nres"</span></span>
  on_finish <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'es</span> nres"</span></span>
  on_back_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'es</span> nres"</span></span>
  on_cross_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'es</span> nres"</span></span>
  is_break <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Default type restriction for parameterizations.
  The event handler functions go from a complete state to
  the user-defined part of the state (i.e. the fields added by inheritance).
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> parameterization 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme<span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_parameterization"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Default parameterization, the functions do nothing.
  This can be used as the basis for specialized parameterizations, which may 
  be derived by updating some fields.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">more</span> <span class="bound">init</span><span class="main">.</span> <span class="free">dflt_parametrization</span> <span class="bound">more</span> <span class="bound">init</span> <span class="main">≡</span> <span class="main">⦇</span>  
  on_init <span class="main">=</span> <span class="bound">init</span><span class="main">,</span>
  on_new_root <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="keyword1">o</span> <span class="bound">more</span><span class="main">,</span>
  on_discover <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="keyword1">o</span> <span class="bound">more</span><span class="main">,</span>
  on_finish <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="keyword1">o</span> <span class="bound">more</span><span class="main">,</span>
  on_back_edge <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="keyword1">o</span> <span class="bound">more</span><span class="main">,</span>
  on_cross_edge <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="keyword1">o</span> <span class="bound">more</span><span class="main">,</span>
  is_break <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> dflt_parametrization_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span>
  gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> dflt_parametrization_def<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This locale builds a DFS algorithm from a graph and a parameterization.›</span></span>
<span class="keyword1"><span class="command">locale</span></span> param_DFS_defs <span class="main">=</span>
  graph_defs <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">param</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> parameterization"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹DFS operations›</span></span>
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Node predicates›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First, we define some predicates to check whether nodes are in certain sets›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_discovered</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_discovered</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_finished</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_finished</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_empty_stack</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_empty_stack</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">[]</span>"</span></span>

  <span class="comment1">(*definition top_pending :: "('v,'es) state_scheme ⇒ 'v × 'v set" where
    "top_pending s ≡ (hd (stack s), pending s `` {hd (stack s)})"*)</span>

  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Effects on Basic State›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the effect of the operations on the basic part of the state›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">discover</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">discover</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
    <span class="bound">d</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↦</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span> <span class="bound">c</span> <span class="main">=</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">;</span>
    <span class="bound">st</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">#</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">p</span> <span class="main">=</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span> <span class="main">×</span> E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">;</span>
    <span class="bound">t</span> <span class="main">=</span> insert <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
  <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> discovered <span class="main">:=</span> <span class="bound">d</span><span class="main">,</span> counter <span class="main">:=</span> <span class="bound">c</span><span class="main">,</span> stack <span class="main">:=</span> <span class="bound">st</span><span class="main">,</span> pending <span class="main">:=</span> <span class="bound">p</span><span class="main">,</span> tree_edges <span class="main">:=</span> <span class="bound">t</span><span class="main">⦈</span>"</span></span>

  <span class="keyword1" id="Param_DFS-discover_simps"><span class="command">lemma</span></span> discover_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"counter <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"discovered <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">v</span> <span class="main">↦</span> counter <span class="free">s</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"finished <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> finished <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"stack <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">v</span><span class="main">#</span>stack <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"pending <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> pending <span class="free">s</span> <span class="main">∪</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_edges <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"cross_edges <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> cross_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"back_edges <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> back_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"state.more <span class="main">(</span>discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> state.more <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discover_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">finish</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">finish</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
    <span class="bound">f</span> <span class="main">=</span> <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">↦</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span> <span class="bound">c</span> <span class="main">=</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">;</span>
    <span class="bound">st</span> <span class="main">=</span> tl <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
  <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> finished <span class="main">:=</span> <span class="bound">f</span><span class="main">,</span> counter <span class="main">:=</span> <span class="bound">c</span><span class="main">,</span> stack <span class="main">:=</span> <span class="bound">st</span><span class="main">⦈</span>"</span></span>

  <span class="keyword1" id="Param_DFS-finish_simps"><span class="command">lemma</span></span> finish_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"counter <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"discovered <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> discovered <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"finished <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">u</span> <span class="main">↦</span> counter <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"stack <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"pending <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> pending <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_edges <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"cross_edges <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> cross_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"back_edges <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> back_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"state.more <span class="main">(</span>finish <span class="free">u</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> state.more <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">back_edge</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">back_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
    <span class="bound">b</span> <span class="main">=</span> insert <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
   <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> back_edges <span class="main">:=</span> <span class="bound">b</span> <span class="main">⦈</span>"</span></span>

  <span class="keyword1" id="Param_DFS-back_edge_simps"><span class="command">lemma</span></span> back_edge_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"counter <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> counter <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"discovered <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> discovered <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"finished <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> finished <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"stack <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> stack <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"pending <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> pending <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_edges <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"cross_edges <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> cross_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"back_edges <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>back_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"state.more <span class="main">(</span>back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> state.more <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> back_edge_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cross_edge</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cross_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
    <span class="bound">c</span> <span class="main">=</span> insert <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
   <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> cross_edges <span class="main">:=</span> <span class="bound">c</span> <span class="main">⦈</span>"</span></span>
  
  <span class="keyword1" id="Param_DFS-cross_edge_simps"><span class="command">lemma</span></span> cross_edge_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"counter <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> counter <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"discovered <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> discovered <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"finished <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> finished <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"stack <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> stack <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"pending <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> pending <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_edges <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"cross_edges <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>cross_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"back_edges <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> back_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"state.more <span class="main">(</span>cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> state.more <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cross_edge_def<span class="main">)</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">new_root</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">new_root</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
       <span class="bound">c</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
       <span class="bound">d</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">↦</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
       <span class="bound">p</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">×</span>E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">;</span>
       <span class="bound">st</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">]</span>
     <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span>counter <span class="main">:=</span> <span class="bound">c</span><span class="main">,</span> discovered <span class="main">:=</span> <span class="bound">d</span><span class="main">,</span> pending <span class="main">:=</span> <span class="bound">p</span><span class="main">,</span> stack <span class="main">:=</span> <span class="bound">st</span><span class="main">⦈</span>"</span></span>

  <span class="keyword1" id="Param_DFS-new_root_simps"><span class="command">lemma</span></span> new_root_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"counter <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"discovered <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">v0</span> <span class="main">↦</span> counter <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"finished <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> finished <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"stack <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">v0</span><span class="main">]</span>"</span></span>
    <span class="quoted"><span class="quoted">"pending <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">×</span>E<span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_edges <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"cross_edges <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> cross_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"back_edges <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> back_edges <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"state.more <span class="main">(</span>new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> state.more <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_root_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">empty_state</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>
    <span class="main">≡</span> <span class="main">⦇</span> counter <span class="main">=</span> <span class="main">0</span><span class="main">,</span>
         discovered <span class="main">=</span> Map.empty<span class="main">,</span>
         finished <span class="main">=</span> Map.empty<span class="main">,</span>
         pending <span class="main">=</span> <span class="main">{}</span><span class="main">,</span>
         stack <span class="main">=</span> <span class="main">[]</span><span class="main">,</span>
         tree_edges <span class="main">=</span> <span class="main">{}</span><span class="main">,</span>
         back_edges <span class="main">=</span> <span class="main">{}</span><span class="main">,</span>
         cross_edges <span class="main">=</span> <span class="main">{}</span><span class="main">,</span>
         <span class="main">…</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">⦈</span>"</span></span>

  <span class="keyword1" id="Param_DFS-empty_state_simps"><span class="command">lemma</span></span> empty_state_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"counter <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="quoted"><span class="quoted">"discovered <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> Map.empty"</span></span>
    <span class="quoted"><span class="quoted">"finished <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> Map.empty"</span></span>
    <span class="quoted"><span class="quoted">"pending <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="quoted"><span class="quoted">"stack <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_edges <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="quoted"><span class="quoted">"back_edges <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="quoted"><span class="quoted">"cross_edges <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="quoted"><span class="quoted">"state.more <span class="main">(</span>empty_state <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="free">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_state_def<span class="main">)</span>




  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Effects on Whole State›</span></span>  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The effects of the operations on the whole state are defined by 
    combining the effects of the basic state with the parameterization.›</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">do_cross_edge</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_cross_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> cross_edge <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      <span class="bound">e</span> <span class="main">←</span> on_cross_edge <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">do_back_edge</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_back_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> back_edge <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      <span class="bound">e</span> <span class="main">←</span> on_back_edge <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">do_known_edge</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_known_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">if</span> is_finished <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
      do_cross_edge <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
    <span class="keyword1">else</span> 
      do_back_edge <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">do_discover</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_discover</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> discover <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">e</span> <span class="main">←</span> on_discover <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">do_finish</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_finish</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> finish <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">e</span> <span class="main">←</span> on_finish <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">s</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_new_root</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">get_new_root</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span>V0 <span class="main">∧</span> <span class="main">¬</span>is_discovered <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">do_new_root</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">do_new_root</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> new_root <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">e</span> <span class="main">←</span> on_new_root <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="bound">s</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> op_defs <span class="main">=</span> discover_def finish_def back_edge_def cross_edge_def new_root_def
  <span class="keyword1"><span class="command">lemmas</span></span> do_defs <span class="main">=</span> do_discover_def do_finish_def do_known_edge_def
    do_cross_edge_def do_back_edge_def do_new_root_def
  <span class="keyword1"><span class="command">lemmas</span></span> pred_defs <span class="main">=</span> is_discovered_def is_finished_def is_empty_stack_def

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">e</span> <span class="main">←</span> on_init <span class="free">param</span><span class="main">;</span>
    RETURN <span class="main">(</span>empty_state <span class="bound">e</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹DFS Algorithm›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We phrase the DFS algorithm iteratively:
    While there are undiscovered root nodes or the stack is not empty,
      inspect the topmost node on the stack: 
        Follow any pending edge, or finish the node if there 
        are no pending edges left.

    ›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">cond</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⟷</span> <span class="main">(</span>V0 <span class="main">⊆</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> is_discovered <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span> <span class="main">⟶</span> <span class="main">¬</span>is_empty_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> 
      <span class="main">∧</span> <span class="main">¬</span>is_break <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>  

  <span class="keyword1" id="Param_DFS-cond_alt"><span class="command">lemma</span></span> cond_alt<span class="main">:</span>
    <span class="quoted"><span class="quoted">"cond <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>V0 <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">⟶</span> stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span>is_break <span class="free">param</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> cond_def is_discovered_def is_empty_stack_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_pending</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span> option <span class="main">×</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'es</span><span class="main">)</span> state_scheme<span class="main">)</span> nres"</span></span> 
    <span class="comment1">― ‹Get topmost stack node and a pending edge if any. The pending
          edge is removed.›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">Vs</span> <span class="main">=</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">;</span>

    <span class="keyword1">if</span> <span class="bound">Vs</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span>
      RETURN <span class="main">(</span><span class="bound">u</span><span class="main">,</span>None<span class="main">,</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> RES <span class="bound">Vs</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> pending <span class="main">:=</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">u</span><span class="main">,</span>Some <span class="bound">v</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme nres"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">step</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">if</span> is_empty_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">v0</span> <span class="main">←</span> get_new_root <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
        do_new_root <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> get_pending <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
        <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> 
          None <span class="main">⇒</span> do_finish <span class="bound">u</span> <span class="bound">s</span> 
        <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">if</span> is_discovered <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> 
            do_known_edge <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
          <span class="keyword1">else</span> 
            do_discover <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
        <span class="main">}</span>
      <span class="main">}</span>"</span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">it_dfs</span> <span class="main">≡</span> init <span class="main">⤜</span> WHILE cond step"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">it_dfsT</span> <span class="main">≡</span> init <span class="main">⤜</span> WHILET cond step"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariants›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now build the infrastructure for establishing invariants 
  of DFS algorithms. The infrastructure is modular and extensible, i.e., 
  we can define re-usable libraries of invariants.
›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For technical reasons, invariants are established in a two-step process:
  <span class="antiquoted"><span class="antiquoted">▸</span></span> First, we prove the invariant wrt. the parameterization in the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>param_DFS›</span></span></span></span> locale.
  <span class="antiquoted"><span class="antiquoted">▸</span></span> Next, we transfer the invariant to the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>DFS_invar›</span></span></span></span>-locale.
›</span></span>
<span class="comment1">(* This locale is required to establish new invariants.
  We would like to directly establish new invariants in the 
  DFS_invar-locale, unfortunately this causes technical problems:
  When interpreting the DFS_invar locale in a proof inside the 
  DFS_invar-locale itself, we get "duplicate constant" warnings,
  unless we prefix the interpreted locale, which may be quite confusing
  in a proof, as the user has to choose the prefixed lemmas, while the
  unprefixed ones are also available, but for the wrong state.
 *)</span>
<span class="keyword1"><span class="command">locale</span></span> param_DFS <span class="main">=</span>
  fb_graph <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> param_DFS_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">param</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> parameterization"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'es</span><span class="main">)</span> state_scheme <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
    <span class="comment1">― ‹Predicate that states that <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">I</span></span><span class="antiquote">}</span></span> is an invariant.›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_invar</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="main">≡</span> is_rwof_invar init cond step <span class="free"><span class="bound"><span class="entity">I</span></span></span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Invariants are transferred to this locale, which is parameterized
  with a state. ›</span></span>
<span class="keyword1"><span class="command">locale</span></span> DFS_invar <span class="main">=</span>
  param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">param</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> parameterization"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rwof<span class="main">:</span> <span class="quoted"><span class="quoted">"rwof init cond step <span class="free">s</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="Param_DFS-make_invar_thm"><span class="command">lemma</span></span> make_invar_thm<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span> <span class="main">⟹</span> <span class="free">I</span> <span class="free">s</span>"</span></span>
    <span class="comment1">― ‹Lemma to transfer an invariant into this locale›</span>
    <span class="keyword1"><span class="command">using</span></span> rwof_cons<span class="main">[</span><span class="operator">OF</span> _ rwof<span class="main">,</span> <span class="operator">folded</span> is_invar_def<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Establishing Invariants›</span></span>
<span class="keyword1"><span class="command">context</span></span> param_DFS
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Include this into refine-rules to discard any information about 
    parameterization ›</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> indep_invar_rules <span class="main">=</span> 
    leof_True_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"on_init <span class="free">param</span>"</span></span><span class="main">]</span>
    leof_True_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"on_new_root <span class="free">param</span> <span class="free">v0</span> <span class="free">s'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">v0</span> <span class="free">s'</span><span class="main">]</span>
    leof_True_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"on_discover <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span><span class="main">]</span>
    leof_True_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"on_finish <span class="free">param</span> <span class="free">v</span> <span class="free">s'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">v</span> <span class="free">s'</span><span class="main">]</span>
    leof_True_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"on_cross_edge <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span><span class="main">]</span>
    leof_True_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"on_back_edge <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span><span class="main">]</span>

  
  <span class="keyword1" id="Param_DFS-rwof_eq_DFS_invar"><span class="command">lemma</span></span> rwof_eq_DFS_invar<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"rwof init cond step <span class="main">=</span> DFS_invar <span class="free">G</span> <span class="free">param</span>"</span></span>
    <span class="comment1">― ‹The DFS-invar locale is equivalent to the strongest invariant of the loop.›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> DFS_invar.rwof <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1" id="Param_DFS-DFS_invar_step"><span class="command">lemma</span></span> DFS_invar_step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>nofail it_dfs<span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free">s</span><span class="main">;</span> cond <span class="free">s</span><span class="main">⟧</span> 
    <span class="main">⟹</span> step <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span>DFS_invar <span class="free">G</span> <span class="free">param</span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹A step preserves the (best) invariant.›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> it_dfs_def rwof_eq_DFS_invar<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rwof_step<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-DFS_invar_step'"><span class="command">lemma</span></span> DFS_invar_step'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>nofail <span class="main">(</span>step <span class="free">s</span><span class="main">)</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free">s</span><span class="main">;</span> cond <span class="free">s</span><span class="main">⟧</span> 
    <span class="main">⟹</span> step <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span>DFS_invar <span class="free">G</span> <span class="free">param</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> it_dfs_def rwof_eq_DFS_invar<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rwof_step'<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define symbolic names for the preconditions of certain operations›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_is_break</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_on_new_root</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span>
    DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span> <span class="main">∧</span> cond <span class="bound">s</span> <span class="main">∧</span> 
    stack <span class="bound">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">∈</span> V0 <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">=</span> new_root <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="bound">s</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_on_finish</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span>
    DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span> <span class="main">∧</span> cond <span class="bound">s</span> <span class="main">∧</span> 
    stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">=</span> finish <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">s</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_edge_selected</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> cond <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> 
    stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">∈</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_on_cross_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span> pre_edge_selected <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span> <span class="main">∧</span>
        <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∈</span>dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">=</span> cross_edge <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_on_back_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span> pre_edge_selected <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span> <span class="main">∧</span>
        <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∉</span>dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">=</span> back_edge <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_on_discover</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span> pre_edge_selected <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span> <span class="main">∧</span>
        <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">=</span> discover <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> pre_on_defs <span class="main">=</span> pre_on_new_root_def pre_on_finish_def 
    pre_edge_selected_def pre_on_cross_edge_def pre_on_back_edge_def
    pre_on_discover_def pre_is_break_def

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we define a set of rules to establish an invariant.›</span></span>  

  <span class="keyword1" id="Param_DFS-establish_invarI"><span class="command">lemma</span></span> establish_invarI<span class="main">[</span><span class="operator">case_names</span> init new_root finish cross_edge back_edge discover<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant (explicit preconditions).›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"on_init <span class="free">param</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> new_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">v0</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       stack <span class="bound">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v0</span> <span class="main">∈</span> V0<span class="main">;</span> <span class="bound">v0</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> new_root <span class="bound">v0</span> <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_new_root <span class="free">param</span> <span class="bound">v0</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
             SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                         <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finish<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
       pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
       <span class="bound">s'</span> <span class="main">=</span> finish <span class="bound">u</span> <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_finish <span class="free">param</span> <span class="bound">u</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
              SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cross_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v</span><span class="main">∈</span>dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> cross_edge <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> back_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v</span><span class="main">∉</span>dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> back_edge <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_back_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span> 
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> discover<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span>  <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> discover <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_discover <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_invar_def
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"init <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="free">I</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> init_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rwof init cond step <span class="skolem">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> IC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"cond <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> DI<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹cond <span class="skolem">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> IB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_break <span class="free">param</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"step <span class="skolem">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span>DFS_invar <span class="free">G</span> <span class="free">param</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="main">(</span><span class="operator">metis</span> DFS_invar_step' DI <span class="quoted"><span class="quoted">‹cond <span class="skolem">s</span>›</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">note</span></span> rule_assms <span class="main">=</span> DI IC IB

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"step <span class="skolem">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="free">I</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leof_use_spec_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> B<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> step_def do_defs pred_defs get_pending_def get_new_root_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> new_root<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rule_assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finish<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rule_assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cross_edge<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rule_assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> back_edge<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rule_assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> discover<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rule_assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Param_DFS-establish_invarI'"><span class="command">lemma</span></span> establish_invarI'<span class="main">[</span><span class="operator">case_names</span> init new_root finish cross_edge back_edge discover<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant (symbolic preconditions).›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"on_init <span class="free">param</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> new_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s'</span> <span class="bound">v0</span><span class="main">.</span> pre_on_new_root <span class="bound">v0</span> <span class="bound">s'</span>
         <span class="main">⟹</span> on_new_root <span class="free">param</span> <span class="bound">v0</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
             SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                         <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finish<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s'</span> <span class="bound">u</span><span class="main">.</span> pre_on_finish <span class="bound">u</span> <span class="bound">s'</span> 
         <span class="main">⟹</span> on_finish <span class="free">param</span> <span class="bound">u</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
              SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cross_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> pre_on_cross_edge <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span>
       <span class="main">⟹</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> back_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> pre_on_back_edge <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span>
       <span class="main">⟹</span> on_back_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span> 
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> discover<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> pre_on_discover <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span>
       <span class="main">⟹</span> on_discover <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> establish_invarI<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> pre_on_defs
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rprems</span><span class="main"><span class="keyword3">,</span></span><span class="operator">blast</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword1" id="Param_DFS-establish_invarI_ND"><span class="command">lemma</span></span> establish_invarI_ND <span class="main">[</span><span class="operator">case_names</span> prereq init new_discover finish cross_edge back_edge<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant (new-root and discover cases are combined).›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> prereq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> on_discover <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span> <span class="main">=</span> on_new_root <span class="free">param</span> <span class="bound">v</span> <span class="bound">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"on_init <span class="free">param</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> new_discover<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">v</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
       discovered <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span>counter <span class="bound">s</span><span class="main">)</span><span class="main">;</span> finished <span class="bound">s'</span> <span class="main">=</span> finished <span class="bound">s</span><span class="main">;</span>
       counter <span class="bound">s'</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="bound">s</span><span class="main">)</span><span class="main">;</span> stack <span class="bound">s'</span> <span class="main">=</span> <span class="bound">v</span><span class="main">#</span>stack <span class="bound">s</span><span class="main">;</span>
       back_edges <span class="bound">s'</span> <span class="main">=</span> back_edges <span class="bound">s</span><span class="main">;</span> cross_edges <span class="bound">s'</span> <span class="main">=</span> cross_edges <span class="bound">s</span><span class="main">;</span>
       tree_edges <span class="bound">s'</span> <span class="main">⊇</span> tree_edges <span class="bound">s</span><span class="main">;</span>
       state.more <span class="bound">s'</span> <span class="main">=</span> state.more <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_new_root <span class="free">param</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
             SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                         <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finish<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
       pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
       <span class="bound">s'</span> <span class="main">=</span> finish <span class="bound">u</span> <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_finish <span class="free">param</span> <span class="bound">u</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
              SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cross_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v</span><span class="main">∈</span>dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> cross_edge <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> back_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v</span><span class="main">∉</span>dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> back_edge <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_back_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span> 
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> new_discover<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span>
      <span class="quoted"><span class="quoted">"on_new_root <span class="free">param</span> <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
        SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                   <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> new_discover<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> prereq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

  <span class="comment1">(* Variant of establish_invarI, where cross_edge and back_edge are combined *)</span>
  <span class="keyword1" id="Param_DFS-establish_invarI_CB"><span class="command">lemma</span></span> establish_invarI_CB <span class="main">[</span><span class="operator">case_names</span> prereq init new_root finish cross_back_edge discover<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant (cross and back edge cases are combined).›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> prereq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> on_back_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span> <span class="main">=</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"on_init <span class="free">param</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> new_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">v0</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       stack <span class="bound">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v0</span> <span class="main">∈</span> V0<span class="main">;</span> <span class="bound">v0</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> new_root <span class="bound">v0</span> <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_new_root <span class="free">param</span> <span class="bound">v0</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
             SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                         <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finish<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
       pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
       <span class="bound">s'</span> <span class="main">=</span> finish <span class="bound">u</span> <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_finish <span class="free">param</span> <span class="bound">u</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
              SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cross_back_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        discovered <span class="bound">s'</span> <span class="main">=</span> discovered <span class="bound">s</span><span class="main">;</span> finished <span class="bound">s'</span> <span class="main">=</span> finished <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s'</span> <span class="main">=</span> stack <span class="bound">s</span><span class="main">;</span> tree_edges <span class="bound">s'</span> <span class="main">=</span> tree_edges <span class="bound">s</span><span class="main">;</span> counter <span class="bound">s'</span> <span class="main">=</span> counter <span class="bound">s</span><span class="main">;</span>
        pending <span class="bound">s'</span> <span class="main">=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
        cross_edges <span class="bound">s'</span> <span class="main">∪</span> back_edges <span class="bound">s'</span> <span class="main">=</span> cross_edges <span class="bound">s</span> <span class="main">∪</span> back_edges <span class="bound">s</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
        state.more <span class="bound">s'</span> <span class="main">=</span> state.more <span class="bound">s</span> <span class="main">⟧</span>
       <span class="main">⟹</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> discover<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span>  <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> discover <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_discover <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> cross_edge <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span>
      <span class="quoted"><span class="quoted">"on_cross_edge <span class="free">param</span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
             SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                         <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> prereq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

  <span class="comment1">(* Variant of establish_invarI, where cross_edge and back_edge, and discover and new_root are combined *)</span>
  <span class="keyword1" id="Param_DFS-establish_invarI_ND_CB"><span class="command">lemma</span></span> establish_invarI_ND_CB <span class="main">[</span><span class="operator">case_names</span> prereq_ND prereq_CB init new_discover finish cross_back_edge<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant (new-root/discover and cross/back-edge cases are combined).›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> prereq<span class="main">:</span> 
        <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> on_discover <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span> <span class="main">=</span> on_new_root <span class="free">param</span> <span class="bound">v</span> <span class="bound">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> on_back_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span> <span class="main">=</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"on_init <span class="free">param</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> new_discover<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">v</span><span class="main">.</span> 
     <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
      <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
      discovered <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span>counter <span class="bound">s</span><span class="main">)</span><span class="main">;</span> finished <span class="bound">s'</span> <span class="main">=</span> finished <span class="bound">s</span><span class="main">;</span>
      counter <span class="bound">s'</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="bound">s</span><span class="main">)</span><span class="main">;</span> stack <span class="bound">s'</span> <span class="main">=</span> <span class="bound">v</span><span class="main">#</span>stack <span class="bound">s</span><span class="main">;</span>
      back_edges <span class="bound">s'</span> <span class="main">=</span> back_edges <span class="bound">s</span><span class="main">;</span> cross_edges <span class="bound">s'</span> <span class="main">=</span> cross_edges <span class="bound">s</span><span class="main">;</span>
      tree_edges <span class="bound">s'</span> <span class="main">⊇</span> tree_edges <span class="bound">s</span><span class="main">;</span>
      state.more <span class="bound">s'</span> <span class="main">=</span> state.more <span class="bound">s</span><span class="main">⟧</span>
        <span class="main">⟹</span> on_new_root <span class="free">param</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
            SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finish<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span><span class="main">.</span> 
      <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
       stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
       pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
       <span class="bound">s'</span> <span class="main">=</span> finish <span class="bound">u</span> <span class="bound">s</span><span class="main">⟧</span>
         <span class="main">⟹</span> on_finish <span class="free">param</span> <span class="bound">u</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
              SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                        <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cross_back_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span>
       <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">;</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        discovered <span class="bound">s'</span> <span class="main">=</span> discovered <span class="bound">s</span><span class="main">;</span> finished <span class="bound">s'</span> <span class="main">=</span> finished <span class="bound">s</span><span class="main">;</span>
        stack <span class="bound">s'</span> <span class="main">=</span> stack <span class="bound">s</span><span class="main">;</span> tree_edges <span class="bound">s'</span> <span class="main">=</span> tree_edges <span class="bound">s</span><span class="main">;</span> counter <span class="bound">s'</span> <span class="main">=</span> counter <span class="bound">s</span><span class="main">;</span>
        pending <span class="bound">s'</span> <span class="main">=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
        cross_edges <span class="bound">s'</span> <span class="main">∪</span> back_edges <span class="bound">s'</span> <span class="main">=</span> cross_edges <span class="bound">s</span> <span class="main">∪</span> back_edges <span class="bound">s</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
        state.more <span class="bound">s'</span> <span class="main">=</span> state.more <span class="bound">s</span> <span class="main">⟧</span>
       <span class="main">⟹</span> on_cross_edge <span class="free">param</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
           SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                      <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI_ND<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> cross_edge <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span>
      <span class="quoted"><span class="quoted">"on_cross_edge <span class="free">param</span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> 
             SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span>
                         <span class="main">⟶</span> <span class="free">I</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> prereq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>


  <span class="keyword1" id="Param_DFS-is_invarI_full"><span class="command">lemma</span></span> is_invarI_full <span class="main">[</span><span class="operator">case_names</span> init new_root finish cross_edge back_edge discover<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant not taking into account the parameterization.›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">e</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">e</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> new_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">v0</span> <span class="bound">e</span><span class="main">.</span> 
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v0</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v0</span> <span class="main">∈</span> V0<span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> new_root <span class="bound">v0</span> <span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> finish<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">e</span><span class="main">.</span> 
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">s'</span> <span class="main">=</span> finish <span class="bound">u</span> <span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span> 
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cross_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">e</span><span class="main">.</span>
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span>cross_edge <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span>
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> back_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">e</span><span class="main">.</span>
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span>back_edge <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span>
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> discover<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">e</span><span class="main">.</span>
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span>discover <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span>
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> establish_invarI<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> indep_invar_rules assms<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Param_DFS-is_invarI"><span class="command">lemma</span></span> is_invarI <span class="main">[</span><span class="operator">case_names</span> init new_root finish visited discover<span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Establish a DFS invariant not taking into account the parameterization, cross/back-edges combined.›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> init'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">e</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span>empty_state <span class="bound">e</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> new_root'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">v0</span> <span class="bound">e</span><span class="main">.</span> 
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v0</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">v0</span> <span class="main">∈</span> V0<span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> new_root <span class="bound">v0</span> <span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> finish'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">e</span><span class="main">.</span> 
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">s'</span> <span class="main">=</span> finish <span class="bound">u</span> <span class="bound">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span> 
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> visited'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">e</span> <span class="bound">c</span> <span class="bound">b</span><span class="main">.</span>
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
        cross_edges <span class="bound">s</span> <span class="main">⊆</span> <span class="bound">c</span><span class="main">;</span> back_edges <span class="bound">s</span> <span class="main">⊆</span> <span class="bound">b</span><span class="main">;</span>
        <span class="bound">s'</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦇</span> 
          pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">,</span>
          state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">,</span> 
          cross_edges <span class="main">:=</span> <span class="bound">c</span><span class="main">,</span> 
          back_edges <span class="main">:=</span> <span class="bound">b</span><span class="main">⦈</span><span class="main">⟧</span>
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> discover'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">e</span><span class="main">.</span>
       <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> cond <span class="bound">s</span><span class="main">;</span>  DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s'</span><span class="main">;</span>
        stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> pending <span class="bound">s</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span>discover <span class="bound">u</span> <span class="bound">v</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">⟧</span>
       <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI_full<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">e</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> visited'<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">s</span></span> <span class="quoted"><span class="skolem">s'</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>cross_edges <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"back_edges <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="skolem">e</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">e</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> visited'<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">s</span></span> <span class="quoted"><span class="skolem">s'</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="quoted">"cross_edges <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>back_edges <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="skolem">e</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Invariants›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We establish some basic invariants›</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(* Establish some invariants *)</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">basic_invar</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
    set <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">-</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span>
    distinct <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟶</span> last <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∈</span> V0<span class="main">)</span> <span class="main">∧</span>
    dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span>
    Domain <span class="main">(</span>pending <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">-</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span>
    pending <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊆</span> E"</span></span>

  <span class="keyword1" id="Param_DFS-i_basic_invar"><span class="command">lemma</span></span> i_basic_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar basic_invar"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> basic_invar_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv last_tl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> basic_invar <span class="main">=</span> make_invar_thm<span class="main">[</span><span class="operator">OF</span> i_basic_invar<span class="main">]</span>

  <span class="keyword1" id="Param_DFS-pending_ssE"><span class="command">lemma</span></span> pending_ssE<span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">⊆</span> E"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> basic_invar 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-pendingD"><span class="command">lemma</span></span> pendingD<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>pending <span class="free">s</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E <span class="main">∧</span> <span class="free">u</span><span class="main">∈</span>dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-stack_set_def"><span class="command">lemma</span></span> stack_set_def<span class="main">:</span>
    <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">-</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-stack_discovered"><span class="command">lemma</span></span> stack_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_set_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Param_DFS-stack_distinct"><span class="command">lemma</span></span> stack_distinct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-last_stack_in_V0"><span class="command">lemma</span></span> last_stack_in_V0<span class="main">:</span>
    <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> last <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> V0"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-stack_not_finished"><span class="command">lemma</span></span> stack_not_finished<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_set_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Param_DFS-discovered_not_stack_imp_finished"><span class="command">lemma</span></span> discovered_not_stack_imp_finished<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∉</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_set_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Param_DFS-finished_discovered"><span class="command">lemma</span></span> finished_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-finished_no_pending"><span class="command">lemma</span></span> finished_no_pending<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-discovered_eq_finished_un_stack"><span class="command">lemma</span></span> discovered_eq_finished_un_stack<span class="main">:</span>
    <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_set_def finished_discovered <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1" id="Param_DFS-pending_on_stack"><span class="command">lemma</span></span> pending_on_stack<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> pending <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> basic_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> basic_invar_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-empty_stack_imp_empty_pending"><span class="command">lemma</span></span> empty_stack_imp_empty_pending<span class="main">:</span>
    <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> pending <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> pending_on_stack
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Establish some more invariants *)</span>
  <span class="keyword1" id="Param_DFS-i_discovered_reachable"><span class="command">lemma</span></span> i_discovered_reachable<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">⊆</span> reachable<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> i<span class="main">:</span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> i.pendingD<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> contra_subsetD list.set_sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rtrancl_image_advance i.stack_discovered<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">discovered_closed</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
      E<span class="main">``</span>dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span>E <span class="main">-</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">``</span> set <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Param_DFS-i_discovered_closed"><span class="command">lemma</span></span> i_discovered_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar discovered_closed"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>E <span class="main">-</span> pending <span class="skolem">s</span><span class="main">)</span> <span class="main">``</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discovered_closed_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span> <span class="main">⊆</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>E <span class="main">-</span> pending <span class="skolem">s'</span><span class="main">)</span> <span class="main">``</span> set <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> finish
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"E<span class="main">``</span>dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discovered_closed_def<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discovered_closed_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discovered_closed_def cond_def<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-i_discovered_finite"><span class="command">lemma</span></span> i_discovered_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> finite <span class="main">(</span>dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> discovered_reachable <span class="main">=</span> 
    i_discovered_reachable <span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="Param_DFS-stack_reachable"><span class="command">lemma</span></span> stack_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> reachable"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> stack_discovered discovered_reachable <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">lemmas</span></span> discovered_closed <span class="main">=</span> i_discovered_closed<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> discovered_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> i_discovered_finite<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
  <span class="keyword1" id="Param_DFS-finished_finite"><span class="command">lemma</span></span> finished_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finished_discovered discovered_finite <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-finished_closed"><span class="command">lemma</span></span> finished_closed<span class="main">:</span>
    <span class="quoted"><span class="quoted">"E <span class="main">``</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> discovered_closed<span class="main">[</span><span class="operator">unfolded</span> discovered_closed_def<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Param_DFS-finished_imp_succ_discovered"><span class="command">lemma</span></span> finished_imp_succ_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> discovered_closed<span class="main">[</span><span class="operator">unfolded</span> discovered_closed_def<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Param_DFS-pending_reachable"><span class="command">lemma</span></span> pending_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">⊆</span> reachable <span class="main">×</span> reachable"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> pendingD discovered_reachable
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_image_advance_rtrancl<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-pending_finite"><span class="command">lemma</span></span> pending_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>pending <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">⊆</span> <span class="main">(</span><span class="keyword1">SIGMA</span> <span class="bound">u</span><span class="main">:</span>dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">.</span> E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pendingD<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> discovered_finite<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> discovered_reachable
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finitely_branching<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>finite_subset<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Param_DFS-no_pending_imp_succ_discovered"><span class="command">lemma</span></span> no_pending_imp_succ_discovered<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> succ <span class="free">u</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> finished_imp_succ_discovered assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> stack_set_def assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms discovered_closed<span class="main">[</span><span class="operator">unfolded</span> discovered_closed_def<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Param_DFS-nc_finished_eq_reachable"><span class="command">lemma</span></span> nc_finished_eq_reachable<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_break <span class="free">param</span> <span class="free">s</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">=</span> reachable"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> NC basic_invar 
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> SS<span class="main">:</span> <span class="quoted"><span class="quoted">"V0 <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> basic_invar_def cond_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">=</span> reachable"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> 
      <span class="keyword1"><span class="command">from</span></span> discovered_reachable <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> reachable"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword1"><span class="command">from</span></span> discovered_closed <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">(</span>dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> discovered_closed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> SS <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"reachable <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> rtrancl_reachable_induct<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Param_DFS-nc_V0_finished"><span class="command">lemma</span></span> nc_V0_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_break <span class="free">param</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"V0 <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nc_finished_eq_reachable<span class="main">[</span><span class="operator">OF</span> NC<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 

  <span class="keyword1" id="Param_DFS-nc_discovered_eq_finished"><span class="command">lemma</span></span> nc_discovered_eq_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_break <span class="free">param</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finished_discovered
    <span class="keyword1"><span class="command">using</span></span> nc_finished_eq_reachable<span class="main">[</span><span class="operator">OF</span> NC<span class="main">]</span> discovered_reachable
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Param_DFS-nc_discovered_eq_reachable"><span class="command">lemma</span></span> nc_discovered_eq_reachable<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_break <span class="free">param</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">=</span> reachable"</span></span>
    <span class="keyword1"><span class="command">using</span></span> NC
    <span class="keyword1"><span class="command">using</span></span> nc_discovered_eq_finished nc_finished_eq_reachable
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Param_DFS-nc_fin_closed"><span class="command">lemma</span></span> nc_fin_closed<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_break <span class="free">param</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"E<span class="main">``</span>dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finished_imp_succ_discovered
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nc_discovered_eq_finished<span class="main"><span class="main">[</span></span><span class="operator">OF</span> NC NB<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Total Correctness›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can show termination of the DFS algorithm, independently of the parameterization›</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">param_dfs_variant</span> <span class="main">≡</span> inv_image 
    <span class="main">(</span>finite_psupset reachable <span class="keyword1">&lt;*lex*&gt;</span> finite_psubset <span class="keyword1">&lt;*lex*&gt;</span> less_than<span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">,</span> pending <span class="bound">s</span><span class="main">,</span> length <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Param_DFS-param_dfs_variant_wf"><span class="command">lemma</span></span> param_dfs_variant_wf<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite reachable"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf param_dfs_variant"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> param_dfs_variant_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Param_DFS-param_dfs_variant_step"><span class="command">lemma</span></span> param_dfs_variant_step<span class="main">:</span>   
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"nofail it_dfs"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"step <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>param_dfs_variant<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="free">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rwof_eq_DFS_invar<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> it_dfs_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> WHILE_nofail_imp_rwof_nofail<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> step_def get_new_root_def do_defs get_pending_def
      <span class="keyword1"><span class="command">unfolding</span></span> param_dfs_variant_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
      <span class="keyword1"><span class="command">using</span></span> discovered_reachable <span class="comment1">(* TODO: Clean, up. *)</span> 
        <span class="comment1">(* FIXME: auto-steps take loooong *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff is_discovered_def finite_psupset_def
      <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff is_empty_stack_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff is_discovered_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
        <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff is_discovered_def<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> discovered_reachable pending_reachable
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_discovered_def
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff finite_psupset_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Param_DFS-it_dfsT_eq_it_dfs"><span class="command">lemma</span></span> it_dfsT_eq_it_dfs<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite reachable"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"it_dfsT <span class="main">=</span> it_dfs"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"it_dfs <span class="main">≤</span> it_dfsT"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> it_dfs_def it_dfsT_def WHILE_def WHILET_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_mono<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILEI_le_WHILEIT<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"it_dfsT <span class="main">≤</span> it_dfs"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"nofail it_dfs"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_nofail_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> it_dfsT_def it_dfs_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_mono<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> WHILET_eq_WHILE_tproof<span class="main"><span class="main">[</span></span>
          <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="free">param</span>"</span></span>
          <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> V<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"param_dfs_variant"</span></span>
          <span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> rwof_eq_DFS_invar<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> rwof_init<span class="main">[</span><span class="operator">OF</span> True<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> it_dfs_def<span class="main"><span class="main">]</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> order_trans<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conjI<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> DFS_invar_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> True<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> param_dfs_variant_step<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">assumption</span><span class="main"><span class="keyword3">|</span></span><span class="operator">rule</span> True<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Non-Failing Parameterization›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The proofs so far have been done modulo failure of the parameterization.
  In this locale, we assume that the parameterization does not fail,
  and derive the correctness proof of the DFS algorithm wrt. its invariant.
›</span></span>
<span class="comment1">(* Locale that assumes that parameterization does not fail *)</span>
<span class="keyword1"><span class="command">locale</span></span> DFS <span class="main">=</span>
  param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">param</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> parameterization"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nofail_on_init<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>on_init <span class="free">param</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> nofail_on_new_root<span class="main">:</span>
    <span class="quoted"><span class="quoted">"pre_on_new_root <span class="free">v0</span> <span class="free">s</span> <span class="main">⟹</span> nofail <span class="main">(</span>on_new_root <span class="free">param</span> <span class="free">v0</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> nofail_on_finish<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"pre_on_finish <span class="free">u</span> <span class="free">s</span> <span class="main">⟹</span> nofail <span class="main">(</span>on_finish <span class="free">param</span> <span class="free">u</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> nofail_on_cross_edge<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"pre_on_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">⟹</span> nofail <span class="main">(</span>on_cross_edge <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> nofail_on_back_edge<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"pre_on_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">⟹</span> nofail <span class="main">(</span>on_back_edge <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> nofail_on_discover<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"pre_on_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">⟹</span> nofail <span class="main">(</span>on_discover <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> nofails <span class="main">=</span> nofail_on_init nofail_on_new_root nofail_on_finish 
    nofail_on_cross_edge nofail_on_back_edge nofail_on_discover


  <span class="keyword1" id="Param_DFS-init_leof_invar"><span class="command">lemma</span></span> init_leof_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"init <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span>DFS_invar <span class="free">G</span> <span class="free">param</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rwof_eq_DFS_invar<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rwof_leof_init<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-it_dfs_eq_spec"><span class="command">lemma</span></span> it_dfs_eq_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"it_dfs <span class="main">=</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span>cond <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rwof_eq_DFS_invar<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> it_dfs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nofail_WHILE_eq_rwof<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> WHILE_eq_I_rwof<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> rwof_eq_DFS_invar
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_nofail<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Φ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> leofD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ init_leof_invar<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> weaken_SPEC<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> nofail_on_init<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> DFS_invar_step'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> nofail_on_init do_defs 
      get_pending_def get_new_root_def pred_defs
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI nofails<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_on_defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Param_DFS-it_dfs_correct"><span class="command">lemma</span></span> it_dfs_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"it_dfs <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span>cond <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> it_dfs_eq_spec<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-it_dfs_SPEC"><span class="command">lemma</span></span> it_dfs_SPEC<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span>cond <span class="bound">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"it_dfs <span class="main">≤</span> SPEC <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> weaken_SPEC<span class="main">[</span><span class="operator">OF</span> it_dfs_correct<span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Param_DFS-it_dfsT_correct"><span class="command">lemma</span></span> it_dfsT_correct<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite reachable"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"it_dfsT <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span>cond <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> it_dfsT_eq_it_dfs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> it_dfs_correct<span class="main">)</span>

  <span class="keyword1" id="Param_DFS-it_dfsT_SPEC"><span class="command">lemma</span></span> it_dfsT_SPEC<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite reachable"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span>DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span>cond <span class="bound">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"it_dfsT <span class="main">≤</span> SPEC <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> it_dfsT_eq_it_dfs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> it_dfs_SPEC<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DFS_Invars_Basic">
<div class="head">
<h1>Theory DFS_Invars_Basic</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Basic Invariant Library›</span></span>
<span class="keyword1"><span class="command">theory</span></span> DFS_Invars_Basic
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Param_DFS.html">../Param_DFS</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide more basic invariants of the DFS algorithm›</span></span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Timing Invariants›</span></span>

<span class="comment1">(* Timing *)</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_discovered</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> the <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_finished</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> the <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> timing_syntax
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(* Timing related syntax shortcuts *)</span> 
  <span class="keyword1"><span class="command">notation</span></span> the_discovered <span class="main">(</span><span class="quoted">"<span class="keyword1">δ</span>"</span><span class="main">)</span>
  <span class="keyword1"><span class="command">notation</span></span> the_finished <span class="main">(</span><span class="quoted">"<span class="keyword1">φ</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">timing_common_inv</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
  <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>δ s v &lt; φ s v›</span></span>›</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span><span class="main">)</span>

  <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>v ≠ w ⟶ δ s v ≠ δ s w ∧ φ s v ≠ φ s w›</span></span>›</span>
  <span class="comment1">― ‹Can't use <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>card dom = card ran›</span></span> as the maps may be infinite ...›</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span> <span class="main">≠</span> <span class="bound">w</span> <span class="main">⟶</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">≠</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span><span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span> <span class="main">≠</span> <span class="bound">w</span> <span class="main">⟶</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">≠</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span><span class="main">)</span>

  <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>δ s v &lt; counter ∧ φ s v &lt; counter›</span></span>›</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> counter <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>

  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span> <span class="main">∈</span> succ <span class="bound">v</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-timing_common_inv"><span class="command">lemma</span></span> timing_common_inv<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_invar timing_common_inv"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>
    
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> stack_not_finished stack_discovered hd_in_set<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword1"><span class="command">from</span></span> discovered_closed <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>E <span class="main">-</span> pending <span class="skolem">s</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discovered_closed_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> succ_hd<span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="skolem">s</span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span> 
      <span class="main">⟹</span> succ <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_irrefl<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_irrefl<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> succ_hd<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> finished_discovered <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> finished_imp_succ_discovered <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> new_root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> finished_discovered <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> finished_imp_succ_discovered <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> s_timing_common_inv <span class="main">=</span> 
    timing_common_inv<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="DFS_Invars_Basic-timing_less_counter"><span class="command">lemma</span></span> timing_less_counter<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> counter <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> counter <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> s_timing_common_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-disc_lt_fin"><span class="command">lemma</span></span> disc_lt_fin<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> s_timing_common_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-disc_unequal"><span class="command">lemma</span></span> disc_unequal<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≠</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> s_timing_common_inv assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-fin_unequal"><span class="command">lemma</span></span> fin_unequal<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≠</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> s_timing_common_inv assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-finished_succ_fin"><span class="command">lemma</span></span> finished_succ_fin<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms s_timing_common_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> timing_common_inv_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-i_prev_stack_discover_all"><span class="command">lemma</span></span> i_prev_stack_discover_all<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span> <span class="bound"><span class="bound">n</span></span> <span class="main">&lt;</span> length <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> 
                   <span class="keyword1">δ</span> <span class="bound">s</span> <span class="main">(</span>stack <span class="bound">s</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"stack <span class="skolem">s'</span> <span class="main">=</span> <span class="skolem">v</span><span class="main">#</span>stack <span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover stack_discovered <span class="keyword1"><span class="command">have</span></span> v_ni<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> stack_discovered timing_less_counter <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="bound">w</span> <span class="main">&lt;</span> counter <span class="skolem">s</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> v_ni <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="bound">w</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="bound">w</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="main">(</span>stack <span class="skolem">s'</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> v_ni <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">n</span> <span class="main">&lt;</span> <span class="main">(</span>length <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="bound">n</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">⟧</span>
      <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="main">(</span>stack <span class="skolem">s'</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>stack <span class="skolem">s'</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> discover<span class="main">(</span>1<span class="main">)</span> v_ni 
    <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">n</span> <span class="main">&lt;</span> <span class="main">(</span>length <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">;</span> <span class="bound">n</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="main">∀</span> <span class="bound">w</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span> <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="main">(</span>stack <span class="skolem">s'</span> <span class="main">!</span> <span class="bound">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="bound">w</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_set_dropD<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> drop_Suc_Cons length_drop length_pos_if_in_set length_tl 
        list.sel<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> neq0_conv nth_Cons_0 EQ<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> zero_less_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> prev_stack_discover_all 
    <span class="main">=</span> i_prev_stack_discover_all<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="DFS_Invars_Basic-prev_stack_discover"><span class="command">lemma</span></span> prev_stack_discover<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">n</span> <span class="main">&lt;</span> length <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prev_stack_discover_all<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-Suc_stack_discover"><span class="command">lemma</span></span> Suc_stack_discover<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> <span class="main">(</span>length <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> Suc <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> prev_stack_discover assms <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="bound">v</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> Suc <span class="free">n</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> in_set_conv_nth <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tl_lt_stack_hd_discover"><span class="command">lemma</span></span> tl_lt_stack_hd_discover<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> notempty<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> notempty <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="skolem">y</span><span class="main">#</span><span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> prev_stack_discover
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-stack_nth_order"><span class="command">lemma</span></span> stack_nth_order<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">i</span> <span class="main">&gt;</span> <span class="free">j</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="var">?i</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="var">?j</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="var">?i</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="var">?j</span>"</span></span>
    
    <span class="keyword1"><span class="command">from</span></span> l stack_set_def <span class="keyword1"><span class="command">have</span></span> 
      disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?i</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?j</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> disc_unequal<span class="main">[</span><span class="operator">OF</span> disc<span class="main">]</span> δ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> <span class="free">j</span>"</span></span>

      <span class="keyword1"><span class="command">with</span></span> l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> <span class="free">j</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> in_set_drop_conv_nth<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> <span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">with</span></span> prev_stack_discover l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> δ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&gt;</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&gt;</span> <span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> <span class="free">i</span> <span class="main">∈</span> set <span class="main">(</span>drop <span class="main">(</span>Suc <span class="free">j</span><span class="main">)</span> <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> in_set_drop_conv_nth<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">with</span></span> prev_stack_discover l <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="var">?i</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="var">?j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Paranthesis Theorem›</span></span>
<span class="comment1">(* Parenthesis Thm *)</span>
<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">parenthesis</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
    <span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span>
     <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span>
             <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span> <span class="comment1">― ‹disjoint›</span>
           <span class="main">∨</span> <span class="main">(</span><span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span> <span class="main">∧</span> <span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-i_parenthesis"><span class="command">lemma</span></span> i_parenthesis<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar parenthesis"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> discovered <span class="skolem">s</span>"</span></span> 
                    <span class="quoted"><span class="quoted">"counter <span class="skolem">s'</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> finished <span class="skolem">s</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword3"><span class="command">assume</span></span>  dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

      <span class="keyword1"><span class="command">note</span></span> assms <span class="main">=</span> dom δ f EQ

      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?DISJ</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?IN</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?DISJ</span> <span class="main">∨</span> <span class="var">?IN</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> x_is_hd <span class="main">=</span> this
        <span class="keyword1"><span class="command">hence</span></span> φx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">=</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> x_is_hd neq <span class="keyword1"><span class="command">have</span></span> y_not_hd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="comment1">― ‹y on stack is not possible: According to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [display] δ<span class="antiquote">}</span></span> it is discovered after <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"x (= hd (stack s))"</span><span class="antiquote">}</span></span>›</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> y_not_hd <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">with</span></span> tl_lt_stack_hd_discover<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span> δ x_is_hd <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> δ <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="comment1">― ‹y must be a successor of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"x (= (hd (stack s)))"</span><span class="antiquote">}</span></span>›</span>
          <span class="keyword1"><span class="command">from</span></span> dom <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> False discovered_not_stack_imp_finished  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> 
            <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> timing_less_counter φx <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> * disc_lt_fin φx <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> less_trans<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">with</span></span> y_not_hd <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> finish assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_def<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> stack_not_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> finish assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> parenthesis_def
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?DISJ</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span> 
                    <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> finished <span class="skolem">s</span>"</span></span>
                    <span class="quoted"><span class="quoted">"counter <span class="skolem">s'</span> <span class="main">=</span> Suc <span class="main">(</span>counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover finished_discovered <span class="keyword1"><span class="command">have</span></span> 
      V'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword3"><span class="command">assume</span></span>  dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?DISJ</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?IN</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span>"</span></span>
      
      <span class="keyword1"><span class="command">from</span></span> dom V' f <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?DISJ</span> <span class="main">∨</span> <span class="var">?IN</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">y</span> <span class="main">=</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> timing_less_counter x f <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="main">&lt;</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?DISJ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> dom <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> discover False δ f x <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_def<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">from</span></span> finished_discovered new_root <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> new_root timing_less_counter <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-parenthesis"><span class="command">lemma</span></span> parenthesis<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="comment1">― ‹disjoint›</span>
           <span class="main">∨</span> <span class="main">(</span><span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">using</span></span> i_parenthesis<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> finished_discovered
    <span class="keyword1"><span class="command">unfolding</span></span> parenthesis_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="DFS_Invars_Basic-parenthesis_contained"><span class="command">lemma</span></span> parenthesis_contained<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> parenthesis assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  
  <span class="keyword1" id="DFS_Invars_Basic-parenthesis_disjoint"><span class="command">lemma</span></span> parenthesis_disjoint<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&gt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> parenthesis assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

  <span class="keyword1" id="DFS_Invars_Basic-finished_succ_contained"><span class="command">lemma</span></span> finished_succ_contained<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finished_succ_fin finished_imp_succ_discovered parenthesis_contained
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Edge Types›</span></span>
<span class="keyword1"><span class="command">context</span></span> param_DFS 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∪</span> cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∪</span> back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="comment1">(* Demo for simple invariant proof *)</span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> finite <span class="main">(</span>edges <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Sometimes it's useful to just chose between tree-edges and non-tree.›</span></span>
  <span class="keyword1" id="DFS_Invars_Basic-edgesE_CB"><span class="command">lemma</span></span> edgesE_CB<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges_basic</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
     Field <span class="main">(</span>back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span> back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊆</span> E <span class="main">-</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span>
   <span class="main">∧</span> Field <span class="main">(</span>cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span> cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊆</span> E <span class="main">-</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span>
   <span class="main">∧</span> Field <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∧</span> tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊆</span> E <span class="main">-</span> pending <span class="free"><span class="bound"><span class="entity">s</span></span></span>
   <span class="main">∧</span> back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∩</span> cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∩</span> tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∩</span> tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   "</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-i_edges_basic"><span class="command">lemma</span></span> i_edges_basic<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar edges_basic"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> edges_basic_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI_full<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> back_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pendingD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_edge <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> cross_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pendingD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="comment1">(* Speed optimized proof, using only auto takes too long *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def Range_def Domain_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> pendingD<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span><span class="main">)</span> 
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def<span class="main">)</span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DFS_invar<span class="main">)</span> edges_basic <span class="main">=</span> i_edges_basic<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    
  <span class="keyword1" id="DFS_Invars_Basic-i_edges_covered"><span class="command">lemma</span></span> i_edges_covered<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">-</span> pending <span class="bound">s</span> <span class="main">=</span> edges <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI_full<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>  

    <span class="keyword1"><span class="command">from</span></span> new_root empty_stack_imp_empty_pending 
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="skolem">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v0</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>›</span></span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> insert <span class="skolem">v0</span> <span class="main">(</span>dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">-</span> <span class="main">{</span><span class="skolem">v0</span><span class="main">}</span> <span class="main">×</span> succ <span class="skolem">v0</span> 
      <span class="main">=</span> E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">×</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> new_root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>  

    <span class="keyword1"><span class="command">from</span></span> cross_edge stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">with</span></span> cross_edge<span class="main">(</span>2-<span class="main">)</span> pending_ssE <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">-</span> <span class="main">(</span>pending <span class="skolem">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
      <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">-</span> pending <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> cross_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>  

    <span class="keyword1"><span class="command">from</span></span> back_edge stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">with</span></span> back_edge<span class="main">(</span>2-<span class="main">)</span> pending_ssE <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">-</span> <span class="main">(</span>pending <span class="skolem">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
      <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">-</span> pending <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> back_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>  

    <span class="keyword1"><span class="command">from</span></span> discover stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">with</span></span> discover<span class="main">(</span>2-<span class="main">)</span> pending_ssE <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"E <span class="main">∩</span> insert <span class="skolem">v</span> <span class="main">(</span>dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> UNIV 
        <span class="main">-</span> <span class="main">(</span>pending <span class="skolem">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">×</span> succ <span class="skolem">v</span><span class="main">)</span>
      <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>E <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">-</span> pending <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> discover <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> edges_covered <span class="main">=</span> 
    i_edges_covered<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="DFS_Invars_Basic-edges_ss_reachable_edges"><span class="command">lemma</span></span> edges_ss_reachable_edges<span class="main">:</span>
    <span class="quoted"><span class="quoted">"edges <span class="free">s</span> <span class="main">⊆</span> E <span class="main">∩</span> reachable <span class="main">×</span> UNIV"</span></span>
    <span class="keyword1"><span class="command">using</span></span> edges_covered discovered_reachable
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_image_advance_rtrancl<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-nc_edges_covered"><span class="command">lemma</span></span> nc_edges_covered<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_break <span class="free">param</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> reachable <span class="main">×</span> UNIV <span class="main">=</span> edges <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> cond_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pred_defs<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> empty_stack_imp_empty_pending<span class="main">)</span>
    
    
    <span class="keyword1"><span class="command">from</span></span> edges_covered nc_discovered_eq_reachable<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_edges_ssE"><span class="command">lemma</span></span> 
    tree_edges_ssE<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="free">s</span> <span class="main">⊆</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    tree_edges_not_pending<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="free">s</span> <span class="main">⊆</span> <span class="main">-</span> pending <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    tree_edge_is_succ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    tree_edges_discovered<span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>

    cross_edges_ssE<span class="main">:</span> <span class="quoted"><span class="quoted">"cross_edges <span class="free">s</span> <span class="main">⊆</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    cross_edges_not_pending<span class="main">:</span> <span class="quoted"><span class="quoted">"cross_edges <span class="free">s</span> <span class="main">⊆</span> <span class="main">-</span> pending <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    cross_edge_is_succ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    cross_edges_discovered<span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>cross_edges <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>

    back_edges_ssE<span class="main">:</span> <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">⊆</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    back_edges_not_pending<span class="main">:</span> <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">⊆</span> <span class="main">-</span> pending <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    back_edge_is_succ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    back_edges_discovered<span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="main">(</span>back_edges <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> edges_basic
    <span class="keyword1"><span class="command">unfolding</span></span> edges_basic_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Invars_Basic-edges_disjoint"><span class="command">lemma</span></span> edges_disjoint<span class="main">:</span> 
   <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">∩</span> cross_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
   <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">∩</span> tree_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
   <span class="quoted"><span class="quoted">"cross_edges <span class="free">s</span> <span class="main">∩</span> tree_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> edges_basic
    <span class="keyword1"><span class="command">unfolding</span></span> edges_basic_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_edge_imp_discovered"><span class="command">lemma</span></span> tree_edge_imp_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_edges_discovered
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_imp_discovered"><span class="command">lemma</span></span> back_edge_imp_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> back_edges_discovered
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-cross_edge_imp_discovered"><span class="command">lemma</span></span> cross_edge_imp_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cross_edges_discovered
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-edge_imp_discovered"><span class="command">lemma</span></span> edge_imp_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_edge_imp_discovered cross_edge_imp_discovered back_edge_imp_discovered
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_edges_finite"><span class="command">lemma</span></span> tree_edges_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> tree_edges_discovered discovered_finite<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="DFS_Invars_Basic-cross_edges_finite"><span class="command">lemma</span></span> cross_edges_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>cross_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> cross_edges_discovered discovered_finite<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edges_finite"><span class="command">lemma</span></span> back_edges_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>back_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> back_edges_discovered discovered_finite<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="DFS_Invars_Basic-edges_finite"><span class="command">lemma</span></span> edges_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of the DFS Tree›</span></span>
<span class="comment1">(* Tree *)</span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="DFS_Invars_Basic-tree_edge_disc_lt_fin"><span class="command">lemma</span></span> tree_edge_disc_lt_fin<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finished_succ_fin tree_edge_is_succ<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_disc_lt_fin"><span class="command">lemma</span></span> back_edge_disc_lt_fin<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finished_succ_fin back_edge_is_succ<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-cross_edge_disc_lt_fin"><span class="command">lemma</span></span> cross_edge_disc_lt_fin<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finished_succ_fin cross_edge_is_succ<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Stack &amp; Tree *)</span>
<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-i_stack_is_tree_path"><span class="command">lemma</span></span> i_stack_is_tree_path<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> stack <span class="bound">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span> <span class="main">∈</span> V0<span class="main">.</span> 
        path <span class="main">(</span>tree_edges <span class="bound">s</span><span class="main">)</span> <span class="bound">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s'</span> <span class="main">=</span> <span class="skolem">v</span> <span class="main">#</span> stack <span class="skolem">s</span>"</span></span>
                    <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span>
      <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> path_mono<span class="main">[</span><span class="operator">OF</span> _ this<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> EQ <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v0</span> <span class="main">∈</span> V0›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>

  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s'</span> <span class="main">=</span> tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span>
      <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s'</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> P A <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span>hd <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v0</span> <span class="main">∈</span> V0›</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span> <span class="bound">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_append_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> stack_is_tree_path <span class="main">=</span> 
    i_stack_is_tree_path<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

  <span class="keyword1" id="DFS_Invars_Basic-stack_is_path"><span class="command">lemma</span></span> stack_is_path<span class="main">:</span>
    <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_is_tree_path path_mono<span class="main">[</span><span class="operator">OF</span> tree_edges_ssE<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="DFS_Invars_Basic-hd_succ_stack_is_path"><span class="command">lemma</span></span> hd_succ_stack_is_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> succ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> succ <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> stack_is_path<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> succ <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span>
      <span class="quoted"><span class="quoted">"path E <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_append_conv<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ne
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tl_stack_hd_tree_path"><span class="command">lemma</span></span> tl_stack_hd_tree_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> stack_is_tree_path assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> assms path_member_reach_end<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">tree_discovered_inv</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
                       <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟶</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> V0 <span class="main">∧</span> <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="bound">v0</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">∧</span> <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0 <span class="main">∪</span> V0 <span class="main">=</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∪</span> V0<span class="main">)</span>"</span></span>


  <span class="keyword1" id="DFS_Invars_Basic-i_tree_discovered_inv"><span class="command">lemma</span></span> i_tree_discovered_inv<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_invar tree_discovered_inv"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s'</span> <span class="main">=</span> <span class="skolem">v</span> <span class="main">#</span> stack <span class="skolem">s</span>"</span></span>
                    <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">note</span></span> TDI <span class="main">=</span> <span class="quoted"><span class="quoted">‹tree_discovered_inv <span class="skolem">s</span>›</span></span><span class="main">[</span><span class="operator">unfolded</span> tree_discovered_inv_def<span class="main">]</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟶</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span> <span class="main">⊆</span> V0 <span class="main">∧</span> <span class="main">(</span>stack <span class="skolem">s'</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> stack <span class="skolem">s'</span> <span class="main">=</span> <span class="main">[</span><span class="bound">v0</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"tree_edges s' ≠ {}"</span><span class="antiquote">}</span></span>›</span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0 <span class="main">∪</span> V0"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> V0"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span> <span class="main">∪</span> V0"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> discover A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trancl_single<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> t_ne <span class="main">=</span> this

        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> y <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> trancl_induct<span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> tree_edge_imp_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">with</span></span> step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> V0›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> t_ne TDI <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> t_d <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span> <span class="main">∪</span> V0"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> V0"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0 <span class="main">∪</span> V0"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> trancl_single <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> True TDI <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> V0"</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">⊆</span> V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">∉</span>V0›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> t_ne <span class="main">=</span> this

        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">=</span><span class="skolem">v</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> TDI t_ne <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∉</span> V0›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> trancl_sub_insert_trancl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">from</span></span> t_ne TDI <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">∪</span> V0 <span class="main">=</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0 <span class="main">∪</span> V0"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> stack_is_tree_path<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v0</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> EQ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v0</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono_mp<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v0</span> <span class="main">∈</span> V0›</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtrancl_into_trancl1<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">with</span></span> t_d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> V0 <span class="main">∪</span> V0 <span class="main">=</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span> <span class="main">∪</span> V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_discovered_inv_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_discovered_inv_def<span class="main">)</span>
      
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DFS_invar<span class="main">)</span> tree_discovered_inv <span class="main">=</span> 
    i_tree_discovered_inv<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DFS_invar<span class="main">)</span> discovered_iff_tree_path<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∉</span> V0 <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_discovered_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_discovered_inv_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-i_tree_one_predecessor"><span class="command">lemma</span></span> i_tree_one_predecessor<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="bound">v</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">∉</span> tree_edges <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="skolem">w'</span> <span class="skolem">y</span>
      <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">w'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s'</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> discover stack_discovered <span class="keyword1"><span class="command">have</span></span> v_hd<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> discover tree_edges_discovered <span class="keyword1"><span class="command">have</span></span> 
        v_notin_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="skolem">v</span> <span class="main">∧</span> <span class="bound">x'</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Field_not_elem<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">w'</span><span class="main">)</span> <span class="main">∉</span> tree_edges <span class="skolem">s'</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> tree_edges <span class="skolem">s'</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s'</span>"</span></span> 
          <span class="keyword1"><span class="command">with</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">≠</span><span class="skolem">w</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> v_notin_tree <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">with</span></span> True * <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">≠</span><span class="skolem">w</span>›</span></span> v_hd <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> 
          <span class="keyword1"><span class="command">using</span></span> discover <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> v_notin_tree * <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">≠</span><span class="skolem">w</span>›</span></span> v_hd 
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w'</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">using</span></span> discover <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
 
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DFS_invar<span class="main">)</span> tree_one_predecessor<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∉</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms make_invar_thm<span class="main">[</span><span class="operator">OF</span> i_tree_one_predecessor<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> DFS_invar<span class="main">)</span> tree_eq_rule<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">=</span><span class="free">u</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_one_predecessor
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-i_tree_edge_disc"><span class="command">lemma</span></span> i_tree_edge_disc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="bound">s</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="bound">v'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>
    
    <span class="keyword1"><span class="command">from</span></span> discover tree_edges_discovered <span class="keyword1"><span class="command">have</span></span> 
      v_notin_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="skolem">v</span> <span class="main">∧</span> <span class="bound">x'</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Field_not_elem<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> discover stack_discovered <span class="keyword1"><span class="command">have</span></span> 
      v_hd<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s'</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> T v_notin_tree <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> hd_in_set NE subsetD<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> v_hd True timing_less_counter <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> v_notin_tree T <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> False <span class="quoted"><span class="quoted">‹<span class="skolem">a</span><span class="main">≠</span><span class="skolem">v</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> new_root <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> tree_edge_imp_discovered new_root <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span><span class="main">.</span> <span class="bound">v</span> <span class="main">≠</span> <span class="skolem">v0</span> <span class="main">∧</span> <span class="bound">v'</span> <span class="main">≠</span> <span class="skolem">v0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> new_root <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_edge_disc"><span class="command">lemma</span></span> tree_edge_disc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i_tree_edge_disc<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
  <span class="keyword1" id="DFS_Invars_Basic-tree_path_disc"><span class="command">lemma</span></span> tree_path_disc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trancl_induct <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tree_edge_disc<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-no_loop_in_tree"><span class="command">lemma</span></span> no_loop_in_tree<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_path_disc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_acyclic"><span class="command">lemma</span></span> tree_acyclic<span class="main">:</span>
    <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> acyclicI no_loop_in_tree<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-no_self_loop_in_tree"><span class="command">lemma</span></span> no_self_loop_in_tree<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∉</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tree_edge_disc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_edge_unequal"><span class="command">lemma</span></span> tree_edge_unequal<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> no_self_loop_in_tree<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_path_unequal"><span class="command">lemma</span></span> tree_path_unequal<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> no_loop_in_tree<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_subpath'"><span class="command">lemma</span></span> tree_subpath'<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> x <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">px</span></span> <span class="keyword2"><span class="keyword">where</span></span> px<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">x</span> <span class="skolem">px</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">px</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> trancl_is_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">from</span></span> y <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">py</span></span> <span class="keyword2"><span class="keyword">where</span></span> py<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">y</span> <span class="skolem">py</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">py</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> trancl_is_path <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">px</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">py</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> px py
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_nonempty_induct2'<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>single<span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> tree_eq_rule <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span><span class="main">≠</span><span class="free">y</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snocl <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> snocl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">x</span> <span class="skolem">as</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">x</span> <span class="skolem">as</span> <span class="free">y</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> tree_eq_rule
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> path_is_trancl <span class="quoted"><span class="quoted">‹<span class="skolem">as</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snocr _ <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> snocr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">y</span> <span class="skolem">as</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">y</span> <span class="skolem">as</span> <span class="free">x</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> tree_eq_rule
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> path_is_trancl <span class="quoted"><span class="quoted">‹<span class="skolem">as</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoclr <span class="skolem">a</span> <span class="skolem">as</span> <span class="skolem">b</span> <span class="skolem">bs</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> 
        <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">x</span> <span class="skolem">as</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">y</span> <span class="skolem">bs</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="skolem">b</span>"</span></span>  <span class="keyword1"><span class="command">using</span></span> tree_eq_rule <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> snoclr.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_subpath"><span class="command">lemma</span></span> tree_subpath<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> δ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms tree_subpath' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> δ tree_path_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-on_stack_is_tree_path"><span class="command">lemma</span></span> on_stack_is_tree_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> x <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> y <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
    
    <span class="keyword1"><span class="command">with</span></span> i δ stack_nth_order <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    
    <span class="keyword1"><span class="command">from</span></span> x <span class="keyword1"><span class="command">have</span></span> ne<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span><span class="skolem">i</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> nth_mem nth_tl<span class="main">[</span><span class="operator">OF</span> ne<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span> i
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> tl_stack_hd_tree_path <span class="keyword1"><span class="command">have</span></span> 
      x_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">=</span><span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> hd_conv_nth ne<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> x_path <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> nth_mem nth_tl<span class="main">[</span><span class="operator">OF</span> ne<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span> j
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> tl_stack_hd_tree_path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> x_path δ <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> tree_subpath
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-hd_stack_tree_path_finished"><span class="command">lemma</span></span> hd_stack_tree_path_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">from</span></span> assms no_loop_in_tree <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">≠</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> tl_stack_hd_tree_path assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> trancl_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> no_loop_in_tree <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tranclE<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> tree_edge_imp_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stack_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_edge_impl_parenthesis"><span class="command">lemma</span></span> tree_edge_impl_parenthesis<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> 
      <span class="main">∧</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>
      <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> "</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> tree_edge_disc_lt_fin assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> f tree_edge_imp_discovered<span class="main">[</span><span class="operator">OF</span> t<span class="main">]</span> tree_edge_disc<span class="main">[</span><span class="operator">OF</span> t<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> parenthesis_contained
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_path_impl_parenthesis"><span class="command">lemma</span></span> tree_path_impl_parenthesis<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> 
      <span class="main">∧</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>
      <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> "</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trancl_induct <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tree_edge_impl_parenthesis<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-nc_reachable_v0_parenthesis"><span class="command">lemma</span></span> nc_reachable_v0_parenthesis<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_break <span class="free">param</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> reachable"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∉</span> V0"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">v0</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∈</span> V0"</span></span>
                 <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v0</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v0</span> "</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> nc_discovered_eq_reachable<span class="main">[</span><span class="operator">OF</span> C<span class="main">]</span> discovered_iff_tree_path v
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v0</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> nc_V0_finished<span class="main">[</span><span class="operator">OF</span> C<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> tree_path_impl_parenthesis that<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">v0</span> <span class="main">∈</span> V0›</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">paren_imp_tree_reach</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">paren_imp_tree_reach</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span> 
        <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="keyword1">φ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">w</span><span class="main">)</span> 
               <span class="main">⟶</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-paren_imp_tree_reach"><span class="command">lemma</span></span> paren_imp_tree_reach<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar paren_imp_tree_reach"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> paren_imp_tree_reach_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> finished <span class="skolem">s</span>"</span></span>
                    <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ballI impI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> F<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">b</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">∨</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">a</span> <span class="main">&gt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">b</span><span class="main">)</span>"</span></span>
        
      <span class="keyword1"><span class="command">from</span></span> F finished_discovered discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> D <span class="quoted"><span class="quoted">‹<span class="skolem">b</span><span class="main">≠</span><span class="skolem">v</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"counter <span class="skolem">s</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> F <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> finished_discovered <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> timing_less_counter <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">b</span> <span class="main">&lt;</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">b</span><span class="main">≠</span><span class="skolem">v</span>›</span></span> F D discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> trancl_mono_mp<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span>"</span></span>
                    <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> discovered <span class="skolem">s</span>"</span></span>
                    <span class="quoted"><span class="quoted">"stack <span class="skolem">s'</span> <span class="main">=</span> tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ballI impI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> paren<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s'</span> <span class="skolem">b</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">∨</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">a</span> <span class="main">&gt;</span> <span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">b</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> φb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s'</span> <span class="skolem">b</span> <span class="main">=</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> stack_set_def
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword1"><span class="command">from</span></span> F <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">from</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">a</span><span class="main">≠</span><span class="skolem">b</span>›</span></span> φb paren <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">⟶</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">a</span> <span class="main">&gt;</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> timing_less_counter <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">qed</span></span> 
        <span class="keyword1"><span class="command">with</span></span> paren True on_stack_is_tree_path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> trancl_mono_mp<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> b_not_hd <span class="main">=</span> this
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> b_not_hd F paren finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> paren b_not_hd F <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>  <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">b</span>"</span></span>  
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> True stack_not_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> new_root finished_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> timing_less_counter finished_discovered
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> new_root <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> s_paren_imp_tree_reach <span class="main">=</span>
    paren_imp_tree_reach<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
  
  <span class="keyword1" id="DFS_Invars_Basic-parenthesis_impl_tree_path_not_finished"><span class="command">lemma</span></span> parenthesis_impl_tree_path_not_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> s_paren_imp_tree_reach assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> paren_imp_tree_reach_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-parenthesis_impl_tree_path"><span class="command">lemma</span></span> parenthesis_impl_tree_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> finished_discovered <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> s_paren_imp_tree_reach assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> paren_imp_tree_reach_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-tree_path_iff_parenthesis"><span class="command">lemma</span></span> tree_path_iff_parenthesis<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⟷</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> parenthesis_impl_tree_path tree_path_impl_parenthesis<span class="main">)</span> 

  <span class="keyword1" id="DFS_Invars_Basic-no_pending_succ_impl_path_in_tree"><span class="command">lemma</span></span> no_pending_succ_impl_path_in_tree<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True 
    <span class="keyword1"><span class="command">with</span></span> assms assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> finished_succ_fin finished_imp_succ_discovered 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">with</span></span> True δ <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> parenthesis_contained parenthesis_impl_tree_path
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> False v δ <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parenthesis_impl_tree_path_not_finished<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>›</span></span> no_pending_imp_succ_discovered v w <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stack_set_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> on_stack_is_tree_path δ <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-finished_succ_impl_path_in_tree"><span class="command">lemma</span></span> finished_succ_impl_path_in_tree<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> no_pending_succ_impl_path_in_tree finished_no_pending finished_discovered
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of Cross Edges›</span></span>
<span class="comment1">(* Cross Edges *)</span>
<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-i_cross_edges_finished"><span class="command">lemma</span></span> i_cross_edges_finished<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cross_edges <span class="bound">s</span><span class="main">.</span> 
    <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">⟶</span> <span class="keyword1">φ</span> <span class="bound">s</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="bound">s</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI_full<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">e</span><span class="main">)</span>
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">from</span></span> finish stack_not_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> timing_less_counter<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">e</span><span class="main">)</span>
    <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">from</span></span> cross_edge stack_not_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> cross_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> timing_less_counter<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> cross_edges_finished 
    <span class="main">=</span> i_cross_edges_finished<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="DFS_Invars_Basic-cross_edges_target_finished"><span class="command">lemma</span></span> cross_edges_target_finished<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cross_edges <span class="free">s</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> cross_edges_finished <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Invars_Basic-cross_edges_finished_decr"><span class="command">lemma</span></span> cross_edges_finished_decr<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cross_edges <span class="free">s</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span>dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">u</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> cross_edges_finished <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Invars_Basic-cross_edge_unequal"><span class="command">lemma</span></span> cross_edge_unequal<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cross<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> cross_edges_target_finished<span class="main">[</span><span class="operator">OF</span> cross<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      w_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> cross_edges_finished_decr<span class="main">[</span><span class="operator">OF</span> cross<span class="main">]</span> 
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> w_fin <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> 
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of Back Edges›</span></span>
<span class="comment1">(* Back Edges *)</span>
<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1" id="DFS_Invars_Basic-i_back_edge_impl_tree_path"><span class="command">lemma</span></span> i_back_edge_impl_tree_path<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="bound">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">∨</span> <span class="bound">w</span> <span class="main">=</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI_full<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> back_edge <span class="keyword1"><span class="command">have</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> stack_set_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
   
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">∨</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjCI<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> st back_edge <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> not_hd_in_tl<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> tl_lt_stack_hd_discover st back_edge <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> on_stack_is_tree_path st <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> back_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> discover <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> trancl_sub_insert_trancl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_impl_tree_path"><span class="command">lemma</span></span> back_edge_impl_tree_path<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="free">w</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i_back_edge_impl_tree_path<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_disc"><span class="command">lemma</span></span> back_edge_disc<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">≠</span><span class="free">w</span>"</span></span> 
    <span class="keyword1"><span class="command">with</span></span> assms back_edge_impl_tree_path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> tree_path_disc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edges_tree_disjoint"><span class="command">lemma</span></span> back_edges_tree_disjoint<span class="main">:</span>
    <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">∩</span> tree_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> back_edge_disc tree_edge_disc
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edges_tree_pathes_disjoint"><span class="command">lemma</span></span> back_edges_tree_pathes_disjoint<span class="main">:</span>
    <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">∩</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> back_edge_disc tree_path_disc
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_finished"><span class="command">lemma</span></span> back_edge_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">=</span><span class="free">w</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> back_edge_impl_tree_path assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> tree_path_impl_parenthesis assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="comment1">(* The lemma should probably replaced by:
     is_invar (λs. ∀(v,w) ∈ (tree_edges s)<span class="hidden">⇧</span><sup>+</sup>. v ∈ succ w ⟶ (w,v) ∈ back_edges s ∨ (w,v) ∈ pending s)
  *)</span>
  <span class="keyword1" id="DFS_Invars_Basic-i_disc_imp_back_edge_or_pending"><span class="command">lemma</span></span> i_disc_imp_back_edge_or_pending<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">.</span> 
        <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span>
      <span class="main">∧</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="bound">v</span> <span class="main">≥</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="bound">w</span>
      <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="bound">s</span> <span class="bound">w</span> <span class="main">≥</span> <span class="keyword1">φ</span> <span class="bound">s</span> <span class="bound">v</span><span class="main">)</span>
      <span class="main">⟶</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="bound">s</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> pending <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_invarI_full<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> cross_edge stack_not_finished<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">u</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hd_in_set
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> cross_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> 
      IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">w</span> <span class="main">∈</span> succ <span class="bound">v</span><span class="main">;</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">;</span> 
                  <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="bound">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="bound">v</span><span class="main">;</span>
                  <span class="main">(</span><span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="bound">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="bound">v</span> <span class="main">≤</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="bound">w</span><span class="main">)</span><span class="main">⟧</span>
                 <span class="main">⟹</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="skolem">s</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> pending <span class="skolem">s</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> ne<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
                 <span class="keyword2"><span class="keyword">and</span></span> p<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="skolem">s</span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> disc<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
                            <span class="keyword2"><span class="keyword">and</span></span> not_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> stack_discovered stack_not_finished
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span>
      <span class="keyword3"><span class="command">assume</span></span> w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> succ <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≠</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">⟶</span> counter <span class="skolem">s</span> <span class="main">≤</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">with</span></span> timing_less_counter <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">with</span></span> finish w δ disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> succ <span class="skolem">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≠</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="skolem">w</span></span><span class="main">]</span> disc not_fin <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> finished_discovered finished_no_pending<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> finish
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> timing_less_counter
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> new_root empty_stack_imp_empty_pending <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pending <span class="skolem">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> new_root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> timing_less_counter
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-disc_imp_back_edge_or_pending"><span class="command">lemma</span></span> disc_imp_back_edge_or_pending<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span><span class="main">;</span>
      <span class="main">(</span><span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span><span class="main">)</span><span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> pending <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i_disc_imp_back_edge_or_pending<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="DFS_Invars_Basic-finished_imp_back_edge"><span class="command">lemma</span></span> finished_imp_back_edge<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">;</span> 
      <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span><span class="main">;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">w</span><span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> disc_imp_back_edge_or_pending finished_discovered finished_no_pending
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

  <span class="keyword1" id="DFS_Invars_Basic-finished_not_finished_imp_back_edge"><span class="command">lemma</span></span> finished_not_finished_imp_back_edge<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">w</span> <span class="main">∈</span> succ <span class="free">v</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">;</span>
      <span class="free">w</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span><span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> disc_imp_back_edge_or_pending finished_discovered finished_no_pending
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

  <span class="keyword1" id="DFS_Invars_Basic-finished_self_loop_in_back_edges"><span class="command">lemma</span></span> finished_self_loop_in_back_edges<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">using</span></span> finished_imp_back_edge
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Back edges and Cycles *)</span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span> 

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
    <span class="comment1">(* Cross and tree_edges edges are always acyclic *)</span>
    <span class="keyword1" id="DFS_Invars_Basic-tree_cross_acyclic"><span class="command">lemma</span></span> tree_cross_acyclic<span class="main">:</span>
      <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>tree_edges <span class="free">s</span> <span class="main">∪</span> cross_edges <span class="free">s</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="var">?E</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
        <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">u</span> <span class="main">∧</span> <span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
          <span class="keyword3"><span class="command">case</span></span> base <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff * cross_edges_finished_decr cross_edges_target_finished tree_edge_impl_parenthesis<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">v</span> <span class="skolem">w</span><span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">w</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">v</span> <span class="main">∧</span> <span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff cross_edges_finished_decr cross_edges_target_finished tree_edge_impl_parenthesis<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux <span class="main">=</span> this

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> acyclic <span class="var">?E</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">with</span></span> aux path <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> 
        <span class="keyword1"><span class="command">from</span></span> no_loop_in_tree <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">with</span></span> trancl_union_outside<span class="main">[</span><span class="operator">OF</span> path<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> cross_edges_target_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> * <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_eq_or_trancl<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> aux<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-cycle_contains_back_edge"><span class="command">lemma</span></span> cycle_contains_back_edge<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> cycle<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> tree_cross_acyclic <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>tree_edges <span class="free">s</span> <span class="main">∪</span> cross_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> trancl_union_outside<span class="main">[</span><span class="operator">OF</span> cycle<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-cycle_needs_back_edge"><span class="command">lemma</span></span> cycle_needs_back_edge<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> acyclic <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span> <span class="main">∪</span> cross_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> tree_cross_acyclic <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_closes_cycle"><span class="command">lemma</span></span> back_edge_closes_cycle<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> acyclic <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> be<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">=</span><span class="skolem">w</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False 
      <span class="keyword1"><span class="command">with</span></span> be back_edge_impl_tree_path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> trancl_mono_mp<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> be <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-back_edge_closes_reachable_cycle"><span class="command">lemma</span></span> back_edge_closes_reachable_cycle<span class="main">:</span>
    <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">¬</span> acyclic <span class="main">(</span>E <span class="main">∩</span> reachable <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> back_edge_closes_cycle edges_ss_reachable_edges cyclic_subset<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_Basic-cycle_iff_back_edges"><span class="command">lemma</span></span> cycle_iff_back_edges<span class="main">:</span>
    <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> back_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> back_edge_closes_cycle cycle_needs_back_edge<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> 


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹White Path Theorem›</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">white_path</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">white_path</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">≠</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> 
       <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> path E <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> 
               <span class="main">(</span><span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="bound">p</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="DFS_Invars_Basic-white_path"><span class="command">lemma</span></span> white_path<span class="main">:</span>
    <span class="quoted"><span class="quoted">"it_dfs <span class="main">≤</span> SPEC<span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> reachable<span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> reachable<span class="main">.</span> <span class="main">¬</span> is_break <span class="free">param</span> <span class="bound">s</span> <span class="main">⟶</span> 
            white_path <span class="bound">s</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="bound">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> it_dfs_SPEC<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> ballI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> DI<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="skolem">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_break <span class="free">param</span> <span class="skolem">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> reach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> reachable"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> reachable"</span></span>

    <span class="keyword1"><span class="command">from</span></span> DI <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">note</span></span> fin_eq_reach <span class="main">=</span> nc_finished_eq_reachable<span class="main">[</span><span class="operator">OF</span> C<span class="main">]</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"white_path <span class="skolem">s</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">=</span><span class="skolem">y</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> white_path_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtranclD<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">p</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> trancl_is_path<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> tree_edges_ssE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">x</span> <span class="skolem">p</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_mono<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> E<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s</span>"</span></span><span class="main">]</span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> 
        <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="skolem">p</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span>›</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_tl_induct<span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>single <span class="skolem">u</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> tree_edge_disc<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>›</span></span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> step <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tree_edge_disc<span class="main">)</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"white_path <span class="skolem">s</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span>›</span></span> white_path_def<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"white_path <span class="skolem">s</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
            P<span class="main">:</span><span class="quoted"><span class="quoted">"path E <span class="skolem">x</span> <span class="skolem">p</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
            white<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="skolem">p</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> white_path_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P white reach<span class="main">(</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_nonempty_induct<span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> single <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> succ <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> reach single <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
            <span class="keyword1"><span class="command">using</span></span> fin_eq_reach finished_succ_impl_path_in_tree<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">u</span> <span class="skolem">us</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">x</span> <span class="skolem">us</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_append_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> reach <span class="keyword1"><span class="command">have</span></span> ureach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> reachable"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_image_advance_rtrancl<span class="main">)</span> 
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> snoc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span>tl <span class="skolem">us</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="bound">v</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> x_u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> snoc.IH<span class="main">)</span>
            
          <span class="keyword1"><span class="command">from</span></span> snoc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> succ <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_append_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> snoc<span class="main">(</span>5<span class="main">)</span> fin_eq_reach finished_discovered <span class="keyword1"><span class="command">have</span></span> 
            y_f_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> succ <span class="skolem">u</span>›</span></span> ureach fin_eq_reach <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> finished_succ_fin <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> x_u <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_eq_or_trancl<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> fin_eq_reach reach <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">x</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> tree_path_impl_parenthesis
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="skolem">s</span> <span class="skolem">x</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> reach fin_eq_reach y_f_d snoc
            <span class="keyword1"><span class="command">using</span></span> parenthesis_contained
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> reach fin_eq_reach y_f_d snoc
            <span class="keyword1"><span class="command">using</span></span> parenthesis_impl_tree_path
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DFS_Invars_SCC">
<div class="head">
<h1>Theory DFS_Invars_SCC</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Invariants for SCCs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> DFS_Invars_SCC
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="DFS_Invars_Basic.html">DFS_Invars_Basic</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">scc_root'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> state_scheme  <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> bool"</span></span>
    <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">v</span></span><span class="antiquote">}</span></span> is a root of its scc 
        iff all the discovered parts of the scc can be reached by tree edges from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">v</span></span><span class="antiquote">}</span></span>›</span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">scc_root'</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span> <span class="main">⟷</span> is_scc <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span> 
                       <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span>
                       <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> 
                       <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">scc</span></span></span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS_defs <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc_root</span> <span class="main">≡</span> scc_root' E"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> scc_root_def <span class="main">=</span> scc_root'_def

  <span class="keyword1" id="DFS_Invars_SCC-scc_rootI"><span class="command">lemma</span></span> scc_rootI<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc_roots</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="main">∃</span><span class="bound">scc</span><span class="main">.</span> scc_root <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">v</span> <span class="bound">scc</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="DFS_Invars_SCC-scc_root_is_discovered"><span class="command">lemma</span></span> scc_root_is_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_scc_tree_rtrancl"><span class="command">lemma</span></span> scc_root_scc_tree_rtrancl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_scc_reach"><span class="command">lemma</span></span> scc_root_scc_reach<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> is_scc_connected assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_reach_scc_root"><span class="command">lemma</span></span> scc_reach_scc_root<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">r</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> is_scc_connected assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_scc_tree_trancl"><span class="command">lemma</span></span> scc_root_scc_tree_trancl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms scc_root_scc_tree_rtrancl
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_eq_or_trancl<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_unique_scc"><span class="command">lemma</span></span> scc_root_unique_scc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span> <span class="main">⟹</span> scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc'</span> <span class="main">⟹</span> <span class="free">scc</span> <span class="main">=</span> <span class="free">scc'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> scc_root_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> is_scc_unique<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_unique_root"><span class="command">lemma</span></span> scc_root_unique_root<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> scc1<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> scc2<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v'</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">v'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="free">v'</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> scc1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> scc_root_scc_tree_trancl<span class="main">[</span><span class="operator">OF</span> scc2<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≠</span> <span class="free">v'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> scc2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> scc_root_scc_tree_trancl<span class="main">[</span><span class="operator">OF</span> scc1<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="free">v'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> no_loop_in_tree <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_unique_is_scc"><span class="command">lemma</span></span> scc_root_unique_is_scc<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="main">(</span>scc_of E <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> scc_of E <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="main">(</span>scc_of E <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">=</span> scc_of E <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> is_scc_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_finished_impl_scc_finished"><span class="command">lemma</span></span> scc_root_finished_impl_scc_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Restr E <span class="free">scc</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>Restr E <span class="free">scc</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_scc_connected'<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> rtrancl_is_path <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?E</span> <span class="free">v</span> <span class="skolem">p</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?E</span> <span class="free">v</span> <span class="skolem">ys</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_append_conv<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> snoc.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> finished_imp_succ_discovered
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> assms scc_root_scc_tree_trancl tree_path_impl_parenthesis
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="DFS_Invars_SCC-scc_root_disc_le"><span class="command">lemma</span></span> scc_root_disc_le<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">v</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> assms scc_root_scc_tree_trancl tree_path_disc <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">x</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_fin_ge"><span class="command">lemma</span></span> scc_root_fin_ge<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≥</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">v</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">from</span></span> assms scc_root_finished_impl_scc_finished <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finished_discovered <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> scc_root_scc_tree_trancl <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> tree_path_impl_parenthesis assms False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_is_Min_disc"><span class="command">lemma</span></span> scc_root_is_Min_disc<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="main">(</span><span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Min <span class="var">?S</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Min_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> discovered_finite <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> scc_root_disc_le<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="var">?S</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">∈</span> <span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-Min_disc_is_scc_root"><span class="command">lemma</span></span> Min_disc_is_scc_root<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="main">(</span><span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="free">scc</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> assms disc_unequal A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> scc_disc <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> A scc_disc <span class="keyword1"><span class="command">have</span></span> δ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> stack_set_def assms <span class="keyword1"><span class="command">have</span></span> 
            v_stack<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True 
            <span class="keyword1"><span class="command">with</span></span> parenthesis_impl_tree_path_not_finished<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> assms δ False
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> A stack_set_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> v_stack δ <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">using</span></span> on_stack_is_tree_path
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> v_fin <span class="main">=</span> this

          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Restr E <span class="free">scc</span>"</span></span>

          <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> succ <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> finished_imp_succ_discovered v_fin <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> scc_disc <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">≠</span> <span class="skolem">y</span>›</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> * finished_succ_impl_path_in_tree v_fin <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> trancl_base <span class="main">=</span> this

          <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_scc_connected'<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_eq_or_trancl<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="skolem">x</span>›</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> trancl_base <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> step trancl_base <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> step <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">with</span></span> tree_path_impl_parenthesis<span class="main">[</span><span class="operator">OF</span> _ v_fin<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
                y_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> 
                <span class="keyword2"><span class="keyword">and</span></span> y_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">with</span></span> finished_discovered <span class="keyword1"><span class="command">have</span></span> y_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

              <span class="keyword1"><span class="command">from</span></span> step <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> succ <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">with</span></span> finished_imp_succ_discovered y_fin <span class="keyword1"><span class="command">have</span></span> 
                z_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">with</span></span> * <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="skolem">z</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> δz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_disc<span class="main">)</span>
              

              <span class="keyword1"><span class="command">from</span></span> * edges_covered finished_no_pending<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>›</span></span><span class="main">]</span> 
                   y_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">assume</span></span> CE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span>"</span></span> 
                <span class="keyword1"><span class="command">with</span></span> cross_edges_finished_decr y_fin y_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> 
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> δz
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> CE cross_edges_target_finished <span class="keyword1"><span class="command">have</span></span> 
                  <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
                  <span class="keyword1"><span class="command">using</span></span> parenthesis_impl_tree_path<span class="main">[</span><span class="operator">OF</span> v_fin<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">assume</span></span> BE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span> 
                <span class="keyword1"><span class="command">with</span></span> back_edge_disc_lt_fin y_fin y_t <span class="keyword1"><span class="command">have</span></span> 
                  <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> δz
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> z_disc
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> 
                  <span class="keyword1"><span class="command">using</span></span> parenthesis_contained<span class="main">[</span><span class="operator">OF</span> v_fin<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
                <span class="keyword1"><span class="command">with</span></span> δz <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
                  <span class="keyword1"><span class="command">using</span></span> parenthesis_impl_tree_path<span class="main">[</span><span class="operator">OF</span> v_fin<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> scc_rootI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_iff_Min_disc"><span class="command">lemma</span></span> scc_root_iff_Min_disc<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span> <span class="main">⟷</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="main">(</span><span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">r</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">⟷</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> scc_root_is_Min_disc <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> Min_disc_is_scc_root assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>   

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_exists"><span class="command">lemma</span></span> scc_root_exists<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> scc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> scc_root <span class="free">s</span> <span class="bound">r</span> <span class="free">scc</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> discovered_finite <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span><span class="main">`</span><span class="var">?S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> scc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?S</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="main">(</span><span class="bound">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="bound">f</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> <span class="bound">f</span> <span class="main">`</span> <span class="bound">A</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="bound">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
      <span class="comment1">― ‹autogenerated by sledgehammer›</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="var">?S</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="bound">x</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Min_in<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Min_disc_is_scc_root <span class="quoted"><span class="quoted">‹is_scc E <span class="free">scc</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_of_node_exists"><span class="command">lemma</span></span> scc_root_of_node_exists<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> scc_root <span class="free">s</span> <span class="bound">r</span> <span class="main">(</span>scc_of E <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="main">(</span>scc_of E <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> scc_of E <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_of E <span class="free">v</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> scc_root_exists <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_transfer'"><span class="command">lemma</span></span> scc_root_transfer'<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"discovered <span class="free">s</span> <span class="main">=</span> discovered <span class="free">s'</span>"</span></span> <span class="quoted"><span class="quoted">"tree_edges <span class="free">s</span> <span class="main">=</span> tree_edges <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span> <span class="main">⟷</span> scc_root <span class="free">s'</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> scc_root_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

  <span class="keyword1" id="DFS_Invars_SCC-scc_root_transfer"><span class="command">lemma</span></span> scc_root_transfer<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> inv<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> r_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span>"</span></span>
               <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="bound">x</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="bound">x</span>"</span></span>
               <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span> <span class="main">-</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="bound">x</span> <span class="main">≥</span> counter <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="free">s</span> <span class="main">⊆</span> tree_edges <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span> <span class="main">⟷</span> scc_root <span class="free">s'</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="free">s'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?sd</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?sd'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?sdd</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">∩</span> <span class="main">(</span>dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span> <span class="main">-</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> r_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="free">scc</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> r_d <span class="keyword1"><span class="command">have</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s'</span><span class="main">`</span><span class="var">?sd</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> discovered_finite <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
      <span class="keyword1"><span class="command">from</span></span> timing_less_counter d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">&lt;</span> counter <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> Min<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span> <span class="main">&lt;</span> counter <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Min_less_iff<span class="main">[</span><span class="operator">OF</span> fin<span class="main">]</span> ne <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword1"><span class="command">from</span></span> d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?sd'</span> <span class="main">=</span> <span class="var">?sd</span> <span class="main">∪</span> <span class="var">?sdd</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd'</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd</span> <span class="main">∪</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sdd</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?sdd</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">from</span></span> d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sdd</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">≥</span> counter <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> ne'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sdd</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> s'.discovered_finite <span class="keyword1"><span class="command">have</span></span> fin'<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sdd</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sdd</span><span class="main">)</span> <span class="main">≥</span> counter <span class="free">s</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> Min_ge_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
        <span class="keyword1"><span class="command">with</span></span> Min Min_Un<span class="main">[</span><span class="operator">OF</span> fin ne fin' ne'<span class="main">]</span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> r_d d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s'</span> <span class="free">r</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> r scc_root_is_Min_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> r aux <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s'</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> r_d d r<span class="main">[</span><span class="operator">unfolded</span> scc_root_def<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> s'.Min_disc_is_scc_root<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> r'<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s'</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> r_d d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> r' s'.scc_root_is_Min_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s'</span> <span class="free">r</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> r' aux <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> <span class="var">?sd'</span><span class="main">)</span> <span class="main">=</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> <span class="var">?sd</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> r_d d r'<span class="main">[</span><span class="operator">unfolded</span> scc_root_def<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_disc_is_scc_root<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="General_DFS_Structure">
<div class="head">
<h1>Theory General_DFS_Structure</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generic DFS and Refinement›</span></span>
<span class="keyword1"><span class="command">theory</span></span> General_DFS_Structure
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Param_DFS.html">../../Param_DFS</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define the generic structure of DFS algorithms, 
  and use this to define a notion of refinement between DFS algorithms.
›</span></span>


<span class="comment1">(*        Generic plot: 
          Define generic DFS-scheme (paramDFS is instance)
          Make basic assumptions on DFS scheme parameters: 
            discovered increasing, new_root_discovered, …
          Show how to implement scheme by FOREACH/WHILE, etc
          This gives a generic implementation for all things that follow basic DFS scheme

          Then define simplified DFS-variants (using general DFS scheme): 
            With on-stack, without on-stack
          Also refine without on-stack to restriction (?)

          Orthogonal refinements:
            1. Refine algorithmic structure, operations remain the same: i.e. fe_impl, rec_impl, ...
            2. Refine operations, structure remains the same:
                 Special case: Refine operations while keeping parametrization
*)</span>


<span class="keyword1"><span class="command">named_theorems</span></span> DFS_code_unfold <span class="quoted">‹DFS framework: Unfolding theorems to prepare term for automatic refinement›</span>
<span class="comment1">(*ML {*
  structure DFS_code_unfold = Named_Thms (
    val name = @{binding DFS_code_unfold}
    val description = "DFS framework: Unfolding theorems to prepare term for automatic refinement"
  )
*}
setup DFS_code_unfold.setup*)</span>

<span class="comment1">(* Basic setup *)</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> 
  REC_annot_def <span class="comment1">(* TODO: Setup REC_annot for autoref!*)</span>
  GHOST_elim_Let <span class="comment1">(* TODO: Unfold in autoref. Can we (ab)use autoref_op_pat_def for that *)</span>
  comp_def <span class="comment1">(* TODO: Setup transfer package to handle this ((RETURN o f) x) *)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generic DFS Algorithm›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span> gen_dfs_struct <span class="main">=</span> 
  gds_init <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> nres"</span></span>
  gds_is_break <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gds_is_empty_stack <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gds_new_root <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gds_get_pending <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span> option <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span> nres"</span></span>
  gds_finish <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gds_is_discovered <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gds_is_finished <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gds_back_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gds_cross_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gds_discover <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>


<span class="keyword1"><span class="command">locale</span></span> gen_dfs_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">gds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span> gen_dfs_struct"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_step</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">if</span> gds_is_empty_stack <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v0</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span><span class="main">.</span> <span class="bound">v0</span><span class="main">∈</span><span class="free">V0</span> <span class="main">∧</span> <span class="main">¬</span>gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
    <span class="main">}</span> <span class="keyword1">else</span>  <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> gds_get_pending <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
        <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> 
          None <span class="main">⇒</span> gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span> 
        <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="main">(</span>
            <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span>
              gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
            <span class="keyword1">else</span>
              gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
          <span class="main">)</span> <span class="keyword1">else</span> 
            gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
        <span class="main">}</span>
      <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_cond</span>  <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
    <span class="main">≡</span> <span class="main">(</span><span class="free">V0</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span> <span class="main">⟶</span> <span class="main">¬</span>gds_is_empty_stack <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_dfs</span> 
    <span class="main">≡</span> gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILE gen_cond gen_step"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_dfsT</span> 
    <span class="main">≡</span> gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILET gen_cond gen_step"</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_discovered</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">v</span> <span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span>"</span></span>


  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_rwof</span> <span class="main">≡</span> rwof <span class="main">(</span>gds_init <span class="free">gds</span><span class="main">)</span> gen_cond gen_step"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_new_root</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    gen_rwof <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> gds_is_empty_stack <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
    <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">∈</span><span class="free">V0</span> <span class="main">-</span> gen_discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_get_pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
    gen_rwof <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> <span class="main">¬</span>gds_is_empty_stack <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">post_get_pending</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">Vs</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> pre_get_pending <span class="free"><span class="bound"><span class="entity">s0</span></span></span> 
    <span class="main">∧</span> inres <span class="main">(</span>gds_get_pending <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Vs</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_finish</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> post_get_pending <span class="free"><span class="bound"><span class="entity">u</span></span></span> None <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_cross_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    post_get_pending <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> gds_is_discovered <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
    <span class="main">∧</span> gds_is_finished <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_back_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    post_get_pending <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> gds_is_discovered <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
      <span class="main">∧</span> <span class="main">¬</span>gds_is_finished <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_discover</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    post_get_pending <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> <span class="main">¬</span>gds_is_discovered <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> pre_defs <span class="main">=</span> pre_new_root_def pre_get_pending_def post_get_pending_def
    pre_finish_def pre_cross_edge_def pre_back_edge_def pre_discover_def

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_step_assert</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">if</span> gds_is_empty_stack <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v0</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span><span class="main">.</span> <span class="bound">v0</span><span class="main">∈</span><span class="free">V0</span> <span class="main">∧</span> <span class="main">¬</span>gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      ASSERT <span class="main">(</span>pre_new_root <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span>pre_get_pending <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">s0</span><span class="main">=</span>GHOST <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
        <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> gds_get_pending <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
        <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> 
          None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>ASSERT <span class="main">(</span>pre_finish <span class="bound">u</span> <span class="bound">s0</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span> gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span><span class="main">}</span>
        <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
              ASSERT <span class="main">(</span>pre_cross_edge <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s0</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
              gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
            <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
              ASSERT <span class="main">(</span>pre_back_edge <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s0</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
              gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
            <span class="main">}</span>
          <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
            ASSERT <span class="main">(</span>pre_discover <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s0</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
            gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
          <span class="main">}</span>
        <span class="main">}</span>
      <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_dfs_assert</span> 
    <span class="main">≡</span> gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILE gen_cond gen_step_assert"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_dfsT_assert</span> 
    <span class="main">≡</span> gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILET gen_cond gen_step_assert"</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_rwof_assert</span> <span class="main">≡</span> rwof <span class="main">(</span>gds_init <span class="free">gds</span><span class="main">)</span> gen_cond gen_step_assert"</span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_step_eq_assert"><span class="command">lemma</span></span> gen_step_eq_assert<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>gen_cond <span class="free">s</span><span class="main">;</span> gen_rwof <span class="free">s</span><span class="main">⟧</span>
       <span class="main">⟹</span> gen_step <span class="free">s</span> <span class="main">=</span> gen_step_assert <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>  
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>    
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine'<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
  <span class="keyword1" id="General_DFS_Structure-gen_dfs_eq_assert"><span class="command">lemma</span></span> gen_dfs_eq_assert<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs <span class="main">=</span> gen_dfs_assert"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfs_def gen_dfs_assert_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>    
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> WHILE_eq_I_rwof<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine'<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_dfsT_eq_assert"><span class="command">lemma</span></span> gen_dfsT_eq_assert<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfsT <span class="main">=</span> gen_dfsT_assert"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfsT_def gen_dfsT_assert_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> WHILET_eq_I_rwof<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine'<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1" id="General_DFS_Structure-gen_rwof_eq_assert"><span class="command">lemma</span></span> gen_rwof_eq_assert<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NF<span class="main">:</span> <span class="quoted"><span class="quoted">"nofail gen_dfs"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gen_rwof <span class="main">=</span> gen_rwof_assert"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rwof_step_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> gen_dfs_assert_def gen_dfs_eq_assert<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> NF<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leofI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine'<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main"><span class="keyword3">,</span></span>
              <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rwof_step_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> gen_dfs_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> NF<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> gen_step_assert_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> GHOST_elim_Let<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leofI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine'<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main"><span class="keyword3">,</span></span>
              <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_dfs_le_gen_dfsT"><span class="command">lemma</span></span> gen_dfs_le_gen_dfsT<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs <span class="main">≤</span> gen_dfsT"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfs_def gen_dfsT_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_mono<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">unfolding</span></span> WHILET_def WHILE_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILEI_le_WHILEIT<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> gen_dfs <span class="main">=</span> gen_dfs_defs <span class="quoted"><span class="free">gds</span></span> <span class="quoted"><span class="free">V0</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span> gen_dfs_struct"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">V0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>

<span class="comment1">(* Formalize the structure of a parameterized DFS *)</span>

<span class="comment1">(* Define the operations on the basic state *)</span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_basic_dfs_struct <span class="main">=</span> 
  gbs_init <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'es</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gbs_is_empty_stack <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gbs_new_root <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gbs_get_pending <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span> option <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span> nres"</span></span>
  gbs_finish <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gbs_is_discovered <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gbs_is_finished <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  gbs_back_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gbs_cross_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  gbs_discover <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>



<span class="keyword1"><span class="command">locale</span></span> gen_param_dfs_defs <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">gbs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_basic_dfs_struct"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">param</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_parameterization"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">upd_ext</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'es</span><span class="main">⇒</span><span class="tfree">'es</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_action</span> <span class="free"><span class="bound"><span class="entity">bf</span></span></span> <span class="free"><span class="bound"><span class="entity">ef</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">s</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">bf</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">e</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ef</span></span></span> <span class="bound">s</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="free">upd_ext</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">e</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_init</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">e</span> <span class="main">←</span> on_init <span class="free">param</span><span class="main">;</span>
    gbs_init <span class="free">gbs</span> <span class="bound">e</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_new_root</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> 
    <span class="main">≡</span> do_action <span class="main">(</span>gbs_new_root <span class="free">gbs</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">)</span> <span class="main">(</span>on_new_root <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">)</span>"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_finish</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> 
    <span class="main">≡</span> do_action <span class="main">(</span>gbs_finish <span class="free">gbs</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">(</span>on_finish <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_back_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
    <span class="main">≡</span> do_action <span class="main">(</span>gbs_back_edge <span class="free">gbs</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>on_back_edge <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_cross_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
    <span class="main">≡</span> do_action <span class="main">(</span>gbs_cross_edge <span class="free">gbs</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>on_cross_edge <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">do_discover</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
    <span class="main">≡</span> do_action <span class="main">(</span>gbs_discover <span class="free">gbs</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span>on_discover <span class="free">param</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> do_action_defs<span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> 
    do_action_def do_init_def do_new_root_def
    do_finish_def do_back_edge_def do_cross_edge_def do_discover_def

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gds</span> <span class="main">≡</span> <span class="main">⦇</span>
    gds_init <span class="main">=</span> do_init<span class="main">,</span>
    gds_is_break <span class="main">=</span> is_break <span class="free">param</span><span class="main">,</span>
    gds_is_empty_stack <span class="main">=</span> gbs_is_empty_stack <span class="free">gbs</span><span class="main">,</span>
    gds_new_root <span class="main">=</span> do_new_root<span class="main">,</span>
    gds_get_pending <span class="main">=</span> gbs_get_pending <span class="free">gbs</span><span class="main">,</span>
    gds_finish <span class="main">=</span> do_finish<span class="main">,</span>
    gds_is_discovered <span class="main">=</span> gbs_is_discovered <span class="free">gbs</span><span class="main">,</span>
    gds_is_finished <span class="main">=</span> gbs_is_finished <span class="free">gbs</span><span class="main">,</span>
    gds_back_edge <span class="main">=</span> do_back_edge<span class="main">,</span>
    gds_cross_edge <span class="main">=</span> do_cross_edge<span class="main">,</span>
    gds_discover <span class="main">=</span> do_discover
  <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> gds_simps<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">DFS_code_unfold</span><span class="main">]</span> 
    <span class="main">=</span> gen_dfs_struct.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> gds_def<span class="main">]</span>

  <span class="keyword1"><span class="command">sublocale</span></span> gen_dfs_defs <span class="quoted">gds</span> <span class="quoted"><span class="free">V0</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> gen_param_dfs <span class="main">=</span> gen_param_dfs_defs <span class="quoted"><span class="free">gbs</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="free">upd_ext</span></span> <span class="quoted"><span class="free">V0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gbs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_basic_dfs_struct"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">param</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">,</span><span class="tfree">'es</span><span class="main">)</span> gen_parameterization"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">upd_ext</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'es</span><span class="main">⇒</span><span class="tfree">'es</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">V0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS_defs <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gbs</span> <span class="main">≡</span> <span class="main">⦇</span>
    gbs_init <span class="main">=</span> RETURN <span class="keyword1">o</span> empty_state<span class="main">,</span>
    gbs_is_empty_stack <span class="main">=</span> is_empty_stack <span class="main">,</span>
    gbs_new_root <span class="main">=</span> RETURN <span class="keyword1">oo</span> new_root <span class="main">,</span>
    gbs_get_pending <span class="main">=</span> get_pending <span class="main">,</span>
    gbs_finish <span class="main">=</span> RETURN <span class="keyword1">oo</span> finish <span class="main">,</span>
    gbs_is_discovered <span class="main">=</span> is_discovered <span class="main">,</span>
    gbs_is_finished <span class="main">=</span> is_finished <span class="main">,</span>
    gbs_back_edge <span class="main">=</span> RETURN <span class="keyword1">ooo</span> back_edge <span class="main">,</span>
    gbs_cross_edge <span class="main">=</span> RETURN <span class="keyword1">ooo</span> cross_edge <span class="main">,</span>
    gbs_discover <span class="main">=</span> RETURN <span class="keyword1">ooo</span> discover
  <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> gbs_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> gen_basic_dfs_struct.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> gbs_def<span class="main">]</span>

  <span class="keyword1"><span class="command">sublocale</span></span> gen_dfs<span class="main">:</span> gen_param_dfs_defs <span class="quoted">gbs</span> <span class="quoted"><span class="free">param</span></span> <span class="quoted">state.more_update</span> <span class="quoted">V0</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_cond_simp"><span class="command">lemma</span></span> gen_cond_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs.gen_cond <span class="main">=</span> cond"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> cond_def gen_dfs.gen_cond_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="General_DFS_Structure-gen_step_simp"><span class="command">lemma</span></span> gen_step_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs.gen_step <span class="main">=</span> step"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfs.gen_step_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
      <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong option.case_cong 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_dfs.do_action_defs<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">unfolding</span></span> step_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> do_defs get_new_root_def pred_defs
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
      <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong option.case_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_init_simp"><span class="command">lemma</span></span> gen_init_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs.do_init <span class="main">=</span> init"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> init_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_dfs.do_action_defs<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_dfs_simp"><span class="command">lemma</span></span> gen_dfs_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs.gen_dfs <span class="main">=</span> it_dfs"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> it_dfs_def gen_dfs.gen_dfs_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_dfsT_simp"><span class="command">lemma</span></span> gen_dfsT_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs.gen_dfsT <span class="main">=</span> it_dfsT"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> it_dfsT_def gen_dfs.gen_dfsT_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> gen_dfs<span class="main">:</span> gen_param_dfs <span class="quoted">gbs</span> <span class="quoted"><span class="free">param</span></span> <span class="quoted">state.more_update</span> <span class="quoted">V0</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement Between DFS Implementations›</span></span>
<span class="comment1">(* This locale expresses refinement between two general DFS implementations *)</span>

<span class="keyword1"><span class="command">locale</span></span> gen_dfs_refine_defs <span class="main">=</span>
  c<span class="main">:</span> gen_dfs_defs <span class="quoted"><span class="free">gdsi</span></span> <span class="quoted"><span class="free">V0i</span></span> <span class="main">+</span> a<span class="main">:</span> gen_dfs_defs <span class="quoted"><span class="free">gds</span></span> <span class="quoted"><span class="free">V0</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gdsi</span> <span class="free">V0i</span> <span class="free">gds</span> <span class="free">V0</span>

<span class="keyword1"><span class="command">locale</span></span> gen_dfs_refine <span class="main">=</span>
  c<span class="main">:</span> gen_dfs <span class="quoted"><span class="free">gdsi</span></span> <span class="quoted"><span class="free">V0i</span></span> <span class="main">+</span> a<span class="main">:</span> gen_dfs <span class="quoted"><span class="free">gds</span></span> <span class="quoted"><span class="free">V0</span></span> <span class="main">+</span> gen_dfs_refine_defs <span class="quoted"><span class="free">gdsi</span></span> <span class="quoted"><span class="free">V0i</span></span> <span class="quoted"><span class="free">gds</span></span> <span class="quoted"><span class="free">V0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gdsi</span> <span class="free">V0i</span> <span class="free">gds</span> <span class="free">V0</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="free">S</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BIJV<span class="main">[</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bijective <span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> V0_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">V0i</span><span class="main">,</span><span class="free">V0</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_discovered_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* TODO: Add preconditions for predicate refinement assumption *)</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gds_is_discovered <span class="free">gdsi</span><span class="main">,</span>gds_is_discovered <span class="free">gds</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">→</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_finished_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gds_is_finished <span class="free">gdsi</span><span class="main">,</span>gds_is_finished <span class="free">gds</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">→</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_empty_stack_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gds_is_empty_stack <span class="free">gdsi</span><span class="main">,</span>gds_is_empty_stack <span class="free">gds</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_break_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gds_is_break <span class="free">gdsi</span><span class="main">,</span>gds_is_break <span class="free">gds</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> init_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"gds_init <span class="free">gdsi</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gds_init <span class="free">gds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> new_root_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">v0i</span><span class="main">,</span><span class="free">v0</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_new_root <span class="free">gdsi</span> <span class="free">v0i</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gds_new_root <span class="free">gds</span> <span class="free">v0</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> get_pending_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_get_pending <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">⟧</span>
      <span class="main">⟹</span> gds_get_pending <span class="free">gdsi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">S</span><span class="main">)</span> <span class="main">(</span>gds_get_pending <span class="free">gds</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finish_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_finish <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_finish <span class="free">gdsi</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gds_finish <span class="free">gds</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cross_edge_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_cross_edge <span class="free">gdsi</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gds_cross_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> back_edge_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_back_edge <span class="free">gdsi</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gds_back_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> discover_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_discover <span class="free">gdsi</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gds_discover <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">"gds_is_discovered <span class="free">gdsi</span>"</span></span>

  <span class="comment1">(*sublocale bij_rel_param!: bij_rel_param V using BIJV by unfold_locales*)</span>

  <span class="keyword1" id="General_DFS_Structure-select_v0_refine"><span class="command">lemma</span></span> select_v0_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> s_param<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span><span class="main">.</span> <span class="bound">v0</span> <span class="main">∈</span> <span class="free">V0i</span> <span class="main">∧</span> <span class="main">¬</span> gds_is_discovered <span class="free">gdsi</span> <span class="bound">v0</span> <span class="free">si</span><span class="main">)</span>
           <span class="main">≤</span> <span class="main">⇓</span> <span class="free">V</span> <span class="main">(</span>SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span><span class="main">.</span> <span class="bound">v0</span> <span class="main">∈</span> <span class="free">V0</span> <span class="main">∧</span> <span class="main">¬</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> RES_refine<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Bex_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> conjE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> set_relD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> V0_param<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> bexE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> bexI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> is_discovered_param<span class="main">[</span><span class="operator">param_fo</span><span class="main">,</span> <span class="operator">OF</span> _ s_param<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_rwof_refine"><span class="command">lemma</span></span> gen_rwof_refine<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> NF<span class="main">:</span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>a.gen_dfs<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> RW<span class="main">:</span> <span class="quoted"><span class="quoted">"c.gen_rwof <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">s'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"a.gen_rwof <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> NF <span class="keyword1"><span class="command">have</span></span> NFa<span class="main">:</span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>a.gen_dfs_assert<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> a.gen_dfs_eq_assert <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">∧</span> a.gen_rwof_assert <span class="bound">s'</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rwof_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RW NFa<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> a.gen_dfs_assert_def<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leofI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> init_refine<span class="main">)</span>
    
      <span class="comment1">(* TODO: Proof duplication between this and gen_dfs_refine.
        Hope for better rwof/mgi-theory!
      *)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> c.gen_cond_def a.gen_cond_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> subset_Collect_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span> 
    
      <span class="keyword1"><span class="command">unfolding</span></span> c.gen_step_def a.gen_step_assert_def GHOST_elim_Let
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leofI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> IdD<span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">|</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> a.gen_rwof_eq_assert<span class="main">[</span><span class="operator">OF</span> NF<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_step_refine"><span class="command">lemma</span></span> gen_step_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span> <span class="main">⟹</span> c.gen_step <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span><span class="free">S</span> <span class="main">(</span>a.gen_step_assert <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> c.gen_step_def a.gen_step_assert_def GHOST_elim_Let
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> IdD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> IdD<span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">|</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    


  <span class="keyword1" id="General_DFS_Structure-gen_dfs_refine"><span class="command">lemma</span></span> gen_dfs_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"c.gen_dfs <span class="main">≤</span> <span class="main">⇓</span><span class="free">S</span> a.gen_dfs"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> c.gen_dfs_def a.gen_dfs_eq_assert<span class="main">[</span><span class="operator">unfolded</span> a.gen_dfs_assert_def<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command">unfolding</span></span> c.gen_cond_def a.gen_cond_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> IdD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> subset_Collect_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="General_DFS_Structure-gen_dfsT_refine"><span class="command">lemma</span></span> gen_dfsT_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"c.gen_dfsT <span class="main">≤</span> <span class="main">⇓</span><span class="free">S</span> a.gen_dfsT"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> c.gen_dfsT_def a.gen_dfsT_eq_assert<span class="main">[</span><span class="operator">unfolded</span> a.gen_dfsT_assert_def<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command">unfolding</span></span> c.gen_cond_def a.gen_cond_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> IdD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> subset_Collect_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="comment1">(* Locale that states refinement of basic operations, without making 
  assumptions on parameterization *)</span>
<span class="keyword1"><span class="command">locale</span></span> gbs_refinement <span class="main">=</span>
  c<span class="main">:</span> gen_param_dfs <span class="quoted"><span class="free">gbsi</span></span> <span class="quoted"><span class="free">parami</span></span> <span class="quoted"><span class="free">upd_exti</span></span> <span class="quoted"><span class="free">V0i</span></span> <span class="main">+</span>
  a<span class="main">:</span> gen_param_dfs <span class="quoted"><span class="free">gbs</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="free">upd_ext</span></span> <span class="quoted"><span class="free">V0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gbsi</span> <span class="free">parami</span> <span class="free">upd_exti</span> <span class="free">V0i</span> <span class="free">gbs</span> <span class="free">param</span> <span class="free">upd_ext</span> <span class="free">V0</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="free">S</span> <span class="free">ES</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BIJV<span class="main">:</span> <span class="quoted"><span class="quoted">"bijective <span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> V0_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">V0i</span><span class="main">,</span><span class="free">V0</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>set_rel"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> is_discovered_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gbs_is_discovered <span class="free">gbsi</span><span class="main">,</span>gbs_is_discovered <span class="free">gbs</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">→</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> is_finished_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gbs_is_finished <span class="free">gbsi</span><span class="main">,</span>gbs_is_finished <span class="free">gbs</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span><span class="main">→</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> is_empty_stack_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>gbs_is_empty_stack <span class="free">gbsi</span><span class="main">,</span>gbs_is_empty_stack <span class="free">gbs</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> is_break_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>is_break <span class="free">parami</span><span class="main">,</span>is_break <span class="free">param</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">→</span>bool_rel"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_init_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span> <span class="free">e</span><span class="main">)</span> <span class="main">∈</span> <span class="free">ES</span> <span class="main">⟹</span> gbs_init <span class="free">gbsi</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gbs_init <span class="free">gbs</span> <span class="free">e</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_new_root_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">v0i</span><span class="main">,</span> <span class="free">v0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span>
       <span class="main">⟹</span> gbs_new_root <span class="free">gbsi</span> <span class="free">v0i</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gbs_new_root <span class="free">gbs</span> <span class="free">v0</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_get_pending_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_get_pending <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span>
            <span class="main">⟹</span> gbs_get_pending <span class="free">gbsi</span> <span class="free">si</span>
                <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">S</span><span class="main">)</span> <span class="main">(</span>gbs_get_pending <span class="free">gbs</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_finish_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_finish <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span>
       <span class="main">⟹</span> gbs_finish <span class="free">gbsi</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gbs_finish <span class="free">gbs</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_cross_edge_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span>
      <span class="main">⟹</span> gbs_cross_edge <span class="free">gbsi</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gbs_cross_edge <span class="free">gbs</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_back_edge_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span>
      <span class="main">⟹</span> gbs_back_edge <span class="free">gbsi</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gbs_back_edge <span class="free">gbs</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> gbs_discover_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">⟧</span>
      <span class="main">⟹</span> gbs_discover <span class="free">gbsi</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">S</span> <span class="main">(</span>gbs_discover <span class="free">gbs</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>

<span class="comment1">(* Locale that states refinement of parameterization, without making
  assumptions on basic operations *)</span>
<span class="keyword1"><span class="command">locale</span></span> param_refinement <span class="main">=</span>
  c<span class="main">:</span> gen_param_dfs <span class="quoted"><span class="free">gbsi</span></span> <span class="quoted"><span class="free">parami</span></span> <span class="quoted"><span class="free">upd_exti</span></span> <span class="quoted"><span class="free">V0i</span></span> <span class="main">+</span>
  a<span class="main">:</span> gen_param_dfs <span class="quoted"><span class="free">gbs</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="free">upd_ext</span></span> <span class="quoted"><span class="free">V0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gbsi</span> <span class="free">parami</span> <span class="free">upd_exti</span> <span class="free">V0i</span> <span class="free">gbs</span> <span class="free">param</span> <span class="free">upd_ext</span> <span class="free">V0</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="free">S</span> <span class="free">ES</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> upd_ext_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">upd_exti</span><span class="main">,</span> <span class="free">upd_ext</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span><span class="free">ES</span> <span class="main">→</span> <span class="free">ES</span><span class="main">)</span> <span class="main">→</span> <span class="free">S</span> <span class="main">→</span> <span class="free">S</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_init_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"on_init <span class="free">parami</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">ES</span> <span class="main">(</span>on_init <span class="free">param</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> is_break_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>is_break <span class="free">parami</span><span class="main">,</span> is_break <span class="free">param</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">→</span> bool_rel"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_new_root_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">v0i</span><span class="main">,</span> <span class="free">v0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span>
        <span class="main">(</span><span class="free">si'</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> nf_inres <span class="main">(</span>gbs_new_root <span class="free">gbs</span> <span class="free">v0</span> <span class="free">s</span><span class="main">)</span> <span class="free">s'</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_new_root <span class="free">parami</span> <span class="free">v0i</span> <span class="free">si'</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">ES</span> <span class="main">(</span>on_new_root <span class="free">param</span> <span class="free">v0</span> <span class="free">s'</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_finish_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_finish <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> <span class="main">(</span><span class="free">si'</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span>
        nf_inres <span class="main">(</span>gbs_finish <span class="free">gbs</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="free">s'</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_finish <span class="free">parami</span> <span class="free">vi</span> <span class="free">si'</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">ES</span> <span class="main">(</span>on_finish <span class="free">param</span> <span class="free">v</span> <span class="free">s'</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_cross_edge_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span>
        <span class="main">(</span><span class="free">si'</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> nf_inres <span class="main">(</span>gbs_cross_edge <span class="free">gbs</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="free">s'</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_cross_edge <span class="free">parami</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si'</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">ES</span> <span class="main">(</span>on_cross_edge <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_back_edge_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span>
        <span class="main">(</span><span class="free">si'</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> nf_inres <span class="main">(</span>gbs_back_edge <span class="free">gbs</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="free">s'</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_back_edge <span class="free">parami</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si'</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">ES</span> <span class="main">(</span>on_back_edge <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_discover_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span>
        <span class="main">(</span><span class="free">si'</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span><span class="main">;</span> nf_inres <span class="main">(</span>gbs_discover <span class="free">gbs</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="free">s'</span><span class="main">⟧</span>
       <span class="main">⟹</span> on_discover <span class="free">parami</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si'</span> <span class="main">≤</span> <span class="main">⇓</span> <span class="free">ES</span> <span class="main">(</span>on_discover <span class="free">param</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">locale</span></span> gen_param_dfs_refine_defs <span class="main">=</span>
  c<span class="main">:</span> gen_param_dfs_defs <span class="quoted"><span class="free">gbsi</span></span> <span class="quoted"><span class="free">parami</span></span> <span class="quoted"><span class="free">upd_exti</span></span> <span class="quoted"><span class="free">V0i</span></span> <span class="main">+</span>
  a<span class="main">:</span> gen_param_dfs_defs <span class="quoted"><span class="free">gbs</span></span> <span class="quoted"><span class="free">param</span></span> <span class="quoted"><span class="free">upd_ext</span></span> <span class="quoted"><span class="free">V0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">gbsi</span> <span class="free">parami</span> <span class="free">upd_exti</span> <span class="free">V0i</span> <span class="free">gbs</span> <span class="free">param</span> <span class="free">upd_ext</span> <span class="free">V0</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> gen_dfs_refine_defs <span class="quoted">c.gds</span> <span class="quoted"><span class="free">V0i</span></span> <span class="quoted">a.gds</span> <span class="quoted"><span class="free">V0</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> gen_param_dfs_refine <span class="main">=</span>
  gbs_refinement <span class="keyword2"><span class="keyword">where</span></span> V<span class="main">=</span><span class="quoted"><span class="free">V</span></span> <span class="keyword2"><span class="keyword">and</span></span> S<span class="main">=</span><span class="quoted"><span class="free">S</span></span> <span class="keyword2"><span class="keyword">and</span></span> ES<span class="main">=</span><span class="quoted"><span class="free">ES</span></span> 
<span class="main">+</span> param_refinement <span class="keyword2"><span class="keyword">where</span></span> V<span class="main">=</span><span class="quoted"><span class="free">V</span></span> <span class="keyword2"><span class="keyword">and</span></span> S<span class="main">=</span><span class="quoted"><span class="free">S</span></span> <span class="keyword2"><span class="keyword">and</span></span> ES<span class="main">=</span><span class="quoted"><span class="free">ES</span></span>
<span class="main">+</span> gen_param_dfs_refine_defs
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'si</span><span class="main">×</span><span class="tfree">'s</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ES</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'esi</span><span class="main">×</span><span class="tfree">'es</span><span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> gen_dfs_refine <span class="quoted">c.gds</span> <span class="quoted"><span class="free">V0i</span></span> <span class="quoted">a.gds</span> <span class="quoted"><span class="free">V0</span></span> <span class="quoted"><span class="free">V</span></span> <span class="quoted"><span class="free">S</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BIJV V0_param a.do_action_defs c.do_action_defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">parametricity</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine_abs'<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine_abs'<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine_abs'<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine_abs'<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine_abs'<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


</pre>
</div><div id="Tailrec_Impl">
<div class="head">
<h1>Theory Tailrec_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tail-Recursive Implementation›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Tailrec_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="General_DFS_Structure.html">General_DFS_Structure</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> tailrec_impl_defs <span class="main">=</span>
  graph_defs <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> gen_dfs_defs <span class="quoted"><span class="free">gds</span></span> <span class="quoted">V0</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">gds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span>gen_dfs_struct"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tr_impl_while_body</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> gds_get_pending <span class="free">gds</span> <span class="bound">s</span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span> 
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span>
          gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
        <span class="keyword1">else</span>
          gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
      <span class="main">}</span> <span class="keyword1">else</span> 
        gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tailrec_implT</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">tailrec_implT</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">s</span> <span class="main">←</span> gds_init <span class="free">gds</span><span class="main">;</span>

    FOREACHci 
      <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="bound">s</span><span class="main">.</span> 
          gen_rwof <span class="bound">s</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="main">⟶</span> gds_is_empty_stack <span class="free">gds</span> <span class="bound">s</span> <span class="main">)</span>
        <span class="main">∧</span> V0<span class="main">-</span><span class="bound">it</span> <span class="main">⊆</span> gen_discovered <span class="bound">s</span><span class="main">)</span> 
      V0
      <span class="main">(</span>Not <span class="keyword1">o</span> gds_is_break <span class="free">gds</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">let</span> <span class="comment1">― ‹ghost:›</span> <span class="bound">s0</span> <span class="main">=</span> <span class="bound">s</span><span class="main">;</span>
        <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span> <span class="keyword1">then</span>
          RETURN <span class="bound">s</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">s</span> <span class="main">←</span> gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span><span class="main">;</span>
          WHILEIT
            <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> gen_rwof <span class="bound">s</span> <span class="main">∧</span> insert <span class="bound">v0</span> <span class="main">(</span>gen_discovered <span class="bound">s0</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="bound">s</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span>gds_is_empty_stack <span class="free">gds</span> <span class="bound">s</span><span class="main">)</span> 
            tr_impl_while_body <span class="bound">s</span>
        <span class="main">}</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">s</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tailrec_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">tailrec_impl</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">s</span> <span class="main">←</span> gds_init <span class="free">gds</span><span class="main">;</span>

    FOREACHci 
      <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="bound">s</span><span class="main">.</span> 
          gen_rwof <span class="bound">s</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="main">⟶</span> gds_is_empty_stack <span class="free">gds</span> <span class="bound">s</span> <span class="main">)</span>
        <span class="main">∧</span> V0<span class="main">-</span><span class="bound">it</span> <span class="main">⊆</span> gen_discovered <span class="bound">s</span><span class="main">)</span> 
      V0
      <span class="main">(</span>Not <span class="keyword1">o</span> gds_is_break <span class="free">gds</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">let</span> <span class="comment1">― ‹ghost:›</span> <span class="bound">s0</span> <span class="main">=</span> <span class="bound">s</span><span class="main">;</span>
        <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span> <span class="keyword1">then</span>
          RETURN <span class="bound">s</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">s</span> <span class="main">←</span> gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span><span class="main">;</span>
          WHILEI
            <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> gen_rwof <span class="bound">s</span> <span class="main">∧</span> insert <span class="bound">v0</span> <span class="main">(</span>gen_discovered <span class="bound">s0</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="bound">s</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span>gds_is_empty_stack <span class="free">gds</span> <span class="bound">s</span><span class="main">)</span> 
            <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> gds_get_pending <span class="free">gds</span> <span class="bound">s</span><span class="main">;</span>
              <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> 
                None <span class="main">⇒</span> gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span> 
              <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span>
                    gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
                  <span class="keyword1">else</span>
                    gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
                <span class="main">}</span> <span class="keyword1">else</span> 
                  gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
              <span class="main">}</span>
            <span class="main">}</span><span class="main">)</span> <span class="bound">s</span>
        <span class="main">}</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">s</span>
    <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Implementation of general DFS with outer foreach-loop ›</span></span>
<span class="keyword1"><span class="command">locale</span></span> tailrec_impl <span class="main">=</span>
  fb_graph <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> gen_dfs <span class="quoted"><span class="free">gds</span></span> <span class="quoted">V0</span> <span class="main">+</span> tailrec_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">gds</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">gds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span>gen_dfs_struct"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> init_empty_stack<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"gds_init <span class="free">gds</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span>gds_is_empty_stack <span class="free">gds</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> new_root_discovered<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_new_root <span class="free">gds</span> <span class="free">v0</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
        insert <span class="free">v0</span> <span class="main">(</span>gen_discovered <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> get_pending_incr<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_get_pending <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gds_get_pending <span class="free">gds</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">.</span> 
        gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span> 
      <span class="comment1">⌦‹∧ gds_is_break gds s' = gds_is_break gds s›</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finish_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_finish <span class="free">u</span> <span class="free">s0</span> <span class="free">s</span><span class="main">⟧</span> 
    <span class="main">⟹</span> gds_finish <span class="free">gds</span> <span class="free">u</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cross_edge_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span> 
    <span class="main">⟹</span> gds_cross_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> back_edge_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span> 
    <span class="main">⟹</span> gds_back_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> discover_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span> 
    <span class="main">⟹</span> gds_discover <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>


  <span class="keyword1"><span class="command">context</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> nofail<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILE gen_cond gen_step<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1" id="Tailrec_Impl-gds_init_refine"><span class="command">lemma</span></span> gds_init_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"gds_init <span class="free">gds</span> 
      <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> gen_rwof <span class="bound">s</span> <span class="main">∧</span> gds_is_empty_stack <span class="free">gds</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rwof_init<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> init_empty_stack<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1" id="Tailrec_Impl-gds_new_root_refine"><span class="command">lemma</span></span> gds_new_root_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> PNR<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_new_root <span class="free">v0</span> <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gds_new_root <span class="free">gds</span> <span class="free">v0</span> <span class="free">s</span> 
        <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> gen_rwof <span class="bound">s'</span> 
            <span class="main">∧</span> insert <span class="free">v0</span> <span class="main">(</span>gen_discovered <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span> <span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>
    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> PNR <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def gen_cond_def pre_new_root_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> new_root_discovered<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PNR<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


    <span class="comment1">(* Establish state after get-pending *)</span>
    <span class="keyword1" id="Tailrec_Impl-get_pending_nofail"><span class="command">lemma</span></span> get_pending_nofail<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_get_pending <span class="free">s</span>"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>gds_get_pending <span class="free">gds</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="comment1">(* Get-pending is executed as part of the next step. 
        As the next step does not fail, get_pending cannot fail, too. *)</span>
      <span class="keyword1"><span class="command">from</span></span> A<span class="main">[</span><span class="operator">unfolded</span> pre_get_pending_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
        RWOF<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_rwof <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> gds_is_empty_stack <span class="free">gds</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> gds_is_break <span class="free">gds</span> <span class="free">s</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> C <span class="keyword1"><span class="command">have</span></span> COND<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_cond <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> gen_cond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> rwof_step<span class="main">[</span><span class="operator">OF</span> nofail RWOF COND<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gen_step <span class="free">s</span> <span class="main">≤</span> SPEC gen_rwof"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>gen_step <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main">)</span>

      <span class="keyword1"><span class="command">with</span></span> C <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> gen_step_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1" id="Tailrec_Impl-gds_get_pending_refine"><span class="command">lemma</span></span> gds_get_pending_refine<span class="main">:</span> 
      <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_get_pending <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gds_get_pending <span class="free">gds</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">.</span> 
          post_get_pending <span class="bound">u</span> <span class="bound">Vs</span> <span class="free">s</span> <span class="bound">s'</span> 
        <span class="main">∧</span> gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gds_get_pending <span class="free">gds</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">.</span> post_get_pending <span class="bound">u</span> <span class="bound">Vs</span> <span class="free">s</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> post_get_pending_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> PRE<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> get_pending_nofail<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> get_pending_incr<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff pw_leof_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1" id="Tailrec_Impl-gds_finish_refine"><span class="command">lemma</span></span> gds_finish_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_finish <span class="free">u</span> <span class="free">s0</span> <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gds_finish <span class="free">gds</span> <span class="free">u</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> gen_rwof <span class="bound">s'</span> 
            <span class="main">∧</span> gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>
    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> PRE 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def gen_cond_def pre_finish_def 
            post_get_pending_def pre_get_pending_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finish_incr<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1" id="Tailrec_Impl-gds_cross_edge_refine"><span class="command">lemma</span></span> gds_cross_edge_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gds_cross_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> gen_rwof <span class="bound">s'</span> 
            <span class="main">∧</span> gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>
    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> PRE 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def gen_cond_def pre_cross_edge_def 
            post_get_pending_def pre_get_pending_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cross_edge_incr<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1" id="Tailrec_Impl-gds_back_edge_refine"><span class="command">lemma</span></span> gds_back_edge_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gds_back_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> gen_rwof <span class="bound">s'</span> 
            <span class="main">∧</span> gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>
    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> PRE 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def gen_cond_def pre_back_edge_def 
            post_get_pending_def pre_get_pending_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> back_edge_incr<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


    <span class="keyword1" id="Tailrec_Impl-gds_discover_refine"><span class="command">lemma</span></span> gds_discover_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gds_discover <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> gen_rwof <span class="bound">s'</span> 
            <span class="main">∧</span> gen_discovered <span class="free">s</span> <span class="main">⊆</span> gen_discovered <span class="bound">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>
    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> PRE 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> gen_step_def gen_cond_def pre_discover_def 
            post_get_pending_def pre_get_pending_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> discover_incr<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1" id="Tailrec_Impl-gen_step_disc_incr"><span class="command">lemma</span></span> gen_step_disc_incr<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"nofail gen_dfs"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gen_rwof <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"insert <span class="free">v0</span> <span class="main">(</span>gen_discovered <span class="free">s0</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>gds_is_empty_stack <span class="free">gds</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gen_step <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> insert <span class="free">v0</span> <span class="main">(</span>gen_discovered <span class="free">s0</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step_def gen_dfs_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_init_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_new_root_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_get_pending_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_finish_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_cross_edge_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_back_edge_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_discover_refine<span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff gen_cond_def
      pre_new_root_def pre_get_pending_def pre_finish_def 
      pre_cross_edge_def pre_back_edge_def pre_discover_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    

  <span class="keyword1"><span class="command">theorem</span></span> tailrec_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"tailrec_impl <span class="main">≤</span> gen_dfs"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILE_refine_rwof<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> tailrec_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_init_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_new_root_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_get_pending_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_finish_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_cross_edge_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_back_edge_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_discover_refine<span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff gen_cond_def
      pre_new_root_def pre_get_pending_def pre_finish_def 
      pre_cross_edge_def pre_back_edge_def pre_discover_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Tailrec_Impl-tr_impl_while_body_gen_step"><span class="command">lemma</span></span> tr_impl_while_body_gen_step<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>gds_is_empty_stack <span class="free">gds</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tr_impl_while_body <span class="free">s</span> <span class="main">≤</span> gen_step <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> tr_impl_while_body_def gen_step_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="Tailrec_Impl-tailrecT_impl"><span class="command">lemma</span></span> tailrecT_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"tailrec_implT <span class="main">≤</span> gen_dfsT"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> le_nofailI<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?V</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rwof_rel <span class="main">(</span>gds_init <span class="free">gds</span><span class="main">)</span> gen_cond gen_step"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> NF<span class="main">:</span> <span class="quoted"><span class="quoted">"nofail gen_dfsT"</span></span>
    <span class="keyword1"><span class="command">from</span></span> nofail_WHILEIT_wf_rel<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"gds_init <span class="free">gds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True"</span></span> <span class="quoted">gen_cond</span> <span class="quoted">gen_step</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">and</span></span> this<span class="main">[</span><span class="operator">unfolded</span> gen_dfsT_def WHILET_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span><span class="var">?V</span><span class="main">¯</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> NF <span class="keyword1"><span class="command">have</span></span> NF'<span class="main">:</span> <span class="quoted"><span class="quoted">"nofail gen_dfs"</span></span> <span class="keyword1"><span class="command">using</span></span> gen_dfs_le_gen_dfsT
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> rwof_rel_spec<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"gds_init <span class="free">gds</span>"</span></span> <span class="quoted">gen_cond</span> <span class="quoted">gen_step</span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span>gen_rwof <span class="bound">s</span><span class="main">;</span> gen_cond <span class="bound">s</span><span class="main">⟧</span> <span class="main">⟹</span> gen_step <span class="bound">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">∈</span><span class="var">?V</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">hence</span></span> 
      aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span>gen_rwof <span class="bound">s</span><span class="main">;</span> gen_cond <span class="bound">s</span><span class="main">⟧</span> <span class="main">⟹</span> gen_step <span class="bound">s</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">∈</span><span class="var">?V</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leofD<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command">using</span></span> NF<span class="main">[</span><span class="operator">unfolded</span> gen_dfsT_def<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> WHILET_nofail_imp_rwof_nofail<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ gen_dfs_le_gen_dfsT<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ tailrec_impl<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tailrec_implT_def tailrec_impl_def
      <span class="keyword1"><span class="command">unfolding</span></span> tr_impl_while_body_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine' inj_on_id<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> WHILEIT_eq_WHILEI_tproof<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> V<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?V</span><span class="main">¯</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WF<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tr_impl_while_body_gen_step<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> aux<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  
<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Rec_Impl">
<div class="head">
<h1>Theory Rec_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Recursive DFS Implementation›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Rec_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="General_DFS_Structure.html">General_DFS_Structure</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> rec_impl_defs <span class="main">=</span>
  graph_defs <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> gen_dfs_defs <span class="quoted"><span class="free">gds</span></span> <span class="quoted">V0</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">gds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span>gen_dfs_struct"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pending</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'v</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">stack</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'v</span> list"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">choose_pending</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> option <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_step'</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> ASSERT <span class="main">(</span>gen_rwof <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> gds_is_empty_stack <span class="free">gds</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v0</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span><span class="main">.</span> <span class="bound">v0</span> <span class="main">∈</span> V0 <span class="main">∧</span> <span class="main">¬</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span><span class="free">stack</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="bound">Vs</span> <span class="main">←</span> SELECT <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="bound">s</span> <span class="main">←</span> <span class="free">choose_pending</span> <span class="bound">u</span> <span class="bound">Vs</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span>
      <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span>
         <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span>
         <span class="keyword1">then</span> <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
              <span class="keyword1">else</span> gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
         <span class="keyword1">else</span> gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
    <span class="main">}</span><span class="main">}</span>"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_dfs'</span> <span class="main">≡</span> gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILE gen_cond gen_step'"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_rwof'</span> <span class="main">≡</span> rwof <span class="main">(</span>gds_init <span class="free">gds</span><span class="main">)</span> gen_cond gen_step'"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">rec_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">rec_impl</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">s</span> <span class="main">←</span> gds_init <span class="free">gds</span><span class="main">;</span>

    FOREACHci 
      <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="bound">s</span><span class="main">.</span> 
          gen_rwof' <span class="bound">s</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="main">⟶</span> gds_is_empty_stack <span class="free">gds</span> <span class="bound">s</span>
            <span class="main">∧</span> V0<span class="main">-</span><span class="bound">it</span> <span class="main">⊆</span> gen_discovered <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
      V0
      <span class="main">(</span>Not <span class="keyword1">o</span> gds_is_break <span class="free">gds</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">let</span> <span class="bound">s0</span> <span class="main">=</span> GHOST <span class="bound">s</span><span class="main">;</span>
        <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span> <span class="keyword1">then</span>
          RETURN <span class="bound">s</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">s</span> <span class="main">←</span> gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span><span class="main">;</span>
          <span class="keyword1">if</span> gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="keyword1">then</span>
            RETURN <span class="bound">s</span>
          <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
            REC_annot
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> gen_rwof' <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span> 
                <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">stk</span><span class="main">.</span> <span class="free">stack</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">u</span><span class="main">#</span><span class="bound">stk</span><span class="main">)</span> 
                <span class="main">∧</span> E <span class="main">∩</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">×</span>UNIV <span class="main">⊆</span> <span class="free">pending</span> <span class="bound">s</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="bound">s'</span><span class="main">.</span> 
                  gen_rwof' <span class="bound">s'</span> 
                <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s'</span> <span class="main">⟶</span> 
                    <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> tl <span class="main">(</span><span class="free">stack</span> <span class="bound">s</span><span class="main">)</span> 
                  <span class="main">∧</span> <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">×</span> UNIV
                  <span class="main">∧</span> gen_discovered <span class="bound">s'</span> <span class="main">⊇</span> gen_discovered <span class="bound">s</span>
                  <span class="main">)</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">D</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="bound">s</span> <span class="main">←</span> FOREACHci 
                <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="bound">s'</span><span class="main">.</span> gen_rwof' <span class="bound">s'</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s'</span> <span class="main">⟶</span>
                    <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">stack</span> <span class="bound">s</span> 
                  <span class="main">∧</span> <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="main">(</span><span class="free">pending</span> <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">×</span><span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">-</span> <span class="bound">it</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">∧</span> gen_discovered <span class="bound">s'</span> <span class="main">⊇</span> gen_discovered <span class="bound">s</span> <span class="main">∪</span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">-</span> <span class="bound">it</span><span class="main">)</span>
                  <span class="main">)</span><span class="main">)</span> 
                <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span><span class="main">)</span> 
                <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="bound">s</span> <span class="main">←</span> <span class="free">choose_pending</span> <span class="bound">u</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
                  <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span>
                      gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
                    <span class="keyword1">else</span>
                      gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
                  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="bound">s</span> <span class="main">←</span> gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">;</span>
                    <span class="keyword1">if</span> gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="keyword1">then</span> RETURN <span class="bound">s</span> <span class="keyword1">else</span> <span class="bound">D</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> 
                  <span class="main">}</span>
                <span class="main">}</span><span class="main">)</span> 
                <span class="bound">s</span><span class="main">;</span>
              <span class="keyword1">if</span> gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="keyword1">then</span> 
                RETURN <span class="bound">s</span>
              <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="bound">s</span> <span class="main">←</span> <span class="free">choose_pending</span> <span class="bound">u</span> <span class="main">(</span>None<span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
                <span class="bound">s</span> <span class="main">←</span> gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span><span class="main">;</span>
                RETURN <span class="bound">s</span>
              <span class="main">}</span> 
            <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
          <span class="main">}</span>
        <span class="main">}</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">s</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">rec_impl_for_paper</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rec_impl_for_paper</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">s</span> <span class="main">←</span> gds_init <span class="free">gds</span><span class="main">;</span>
    FOREACHc V0 <span class="main">(</span>Not <span class="keyword1">o</span> gds_is_break <span class="free">gds</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span> <span class="keyword1">then</span> RETURN <span class="bound">s</span>
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">s</span> <span class="main">←</span> gds_new_root <span class="free">gds</span> <span class="bound">v0</span> <span class="bound">s</span><span class="main">;</span>
        <span class="keyword1">if</span> gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="keyword1">then</span> RETURN <span class="bound">s</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          REC <span class="main">(</span><span class="main">λ</span><span class="bound">D</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="bound">s</span> <span class="main">←</span> FOREACHc <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span>gds_is_break <span class="free">gds</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="bound">s</span> <span class="main">←</span> <span class="free">choose_pending</span> <span class="bound">u</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
                <span class="keyword1">if</span> gds_is_discovered <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="keyword1">if</span> gds_is_finished <span class="free">gds</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> gds_cross_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
                  <span class="keyword1">else</span> gds_back_edge <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="bound">s</span> <span class="main">←</span> gds_discover <span class="free">gds</span> <span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">;</span>
                  <span class="keyword1">if</span> gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="keyword1">then</span> RETURN <span class="bound">s</span> <span class="keyword1">else</span> <span class="bound">D</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> 
                <span class="main">}</span>
              <span class="main">}</span><span class="main">)</span> 
              <span class="bound">s</span><span class="main">;</span>
            <span class="keyword1">if</span> gds_is_break <span class="free">gds</span> <span class="bound">s</span> <span class="keyword1">then</span> RETURN <span class="bound">s</span>
            <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="bound">s</span> <span class="main">←</span> <span class="free">choose_pending</span> <span class="bound">u</span> <span class="main">(</span>None<span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
              gds_finish <span class="free">gds</span> <span class="bound">u</span> <span class="bound">s</span>
            <span class="main">}</span> 
          <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">}</span>
    <span class="main">}</span><span class="main">)</span> <span class="bound">s</span>
  <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Recursive implementation of general DFS *)</span>
<span class="keyword1"><span class="command">locale</span></span> rec_impl <span class="main">=</span>
  fb_graph <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> gen_dfs <span class="quoted"><span class="free">gds</span></span> <span class="quoted">V0</span> <span class="main">+</span> rec_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">gds</span></span> <span class="quoted"><span class="free">pending</span></span> <span class="quoted"><span class="free">stack</span></span> <span class="quoted"><span class="free">choose_pending</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">gds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'s</span><span class="main">)</span>gen_dfs_struct"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">pending</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'v</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">stack</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'v</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">choose_pending</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> option <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> nres"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"gds_is_empty_stack <span class="free">gds</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">stack</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> init_spec<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"gds_init <span class="free">gds</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">stack</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">pending</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> new_root_spec<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">⟧</span> 
      <span class="main">⟹</span> gds_new_root <span class="free">gds</span> <span class="free">v0</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
        <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> <span class="main">[</span><span class="free">v0</span><span class="main">]</span> <span class="main">∧</span> <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">×</span>E<span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span> <span class="main">∧</span>
        gen_discovered <span class="bound">s'</span> <span class="main">=</span> insert <span class="free">v0</span> <span class="main">(</span>gen_discovered <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> get_pending_fmt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> pre_get_pending <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> 
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">vo</span> <span class="main">←</span> SELECT <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pending</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">s</span> <span class="main">←</span> <span class="free">choose_pending</span> <span class="bound">u</span> <span class="bound">vo</span> <span class="free">s</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">vo</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
    <span class="main">}</span> 
  <span class="main">≤</span> gds_get_pending <span class="free">gds</span> <span class="free">s</span>"</span></span> <span class="comment1">(* TODO: ≤<span class="hidden">⇩</span><sub>n</sub> should be enough here! *)</span>

  <span class="keyword2"><span class="keyword">assumes</span></span> choose_pending_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_get_pending <span class="free">s</span><span class="main">;</span> <span class="free">u</span> <span class="main">=</span> hd <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">case</span> <span class="free">vo</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span><span class="main">∈</span><span class="free">pending</span> <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span>
  <span class="main">⟧</span> <span class="main">⟹</span>
    <span class="free">choose_pending</span> <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      <span class="main">(</span><span class="keyword1">case</span> <span class="free">vo</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="free">s</span>
      <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span>
      <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">stack</span> <span class="free">s</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="bound">s'</span> <span class="main">=</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="free">s</span><span class="main">)</span> 
      <span class="comment1">⌦‹∧ gds_is_break gds s' = gds_is_break gds s›</span>
    <span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finish_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_finish <span class="free">u</span> <span class="free">s0</span> <span class="free">s</span><span class="main">⟧</span> 
    <span class="main">⟹</span> gds_finish <span class="free">gds</span> <span class="free">u</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">∧</span>
      <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> tl <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="bound">s'</span> <span class="main">=</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cross_edge_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span> 
    <span class="main">⟹</span> gds_cross_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">stack</span> <span class="free">s</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="bound">s'</span> <span class="main">=</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> back_edge_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span> 
    <span class="main">⟹</span> gds_back_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">stack</span> <span class="free">s</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="bound">s'</span> <span class="main">=</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> discover_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span> 
    <span class="main">⟹</span> gds_discover <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> 
      <span class="free">pending</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">∪</span> <span class="main">(</span><span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> <span class="free">stack</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free">v</span><span class="main">#</span><span class="free">stack</span> <span class="free">s</span> <span class="main">∧</span>
      gen_discovered <span class="bound">s'</span> <span class="main">=</span> insert <span class="free">v</span> <span class="main">(</span>gen_discovered <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>



<span class="keyword2"><span class="keyword">begin</span></span>

    
  <span class="keyword1" id="Rec_Impl-gen_step'_refine"><span class="command">lemma</span></span> gen_step'_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>gen_rwof <span class="free">s</span><span class="main">;</span> gen_cond <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gen_step' <span class="free">s</span> <span class="main">≤</span> gen_step <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gen_step'_def gen_step_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ bind_mono<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_fmt order_refl<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span>
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1" id="Rec_Impl-gen_dfs'_refine"><span class="command">lemma</span></span> gen_dfs'_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs' <span class="main">≤</span> gen_dfs"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfs'_def gen_dfs_def WHILE_eq_I_rwof<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">gen_step</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_step'_refine<span class="main">)</span>

  <span class="keyword1" id="Rec_Impl-gen_rwof'_imp_rwof"><span class="command">lemma</span></span> gen_rwof'_imp_rwof<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NF<span class="main">:</span> <span class="quoted"><span class="quoted">"nofail gen_dfs"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_rwof' <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gen_rwof <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rwof_step_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> NF<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> gen_dfs_def<span class="main"><span class="main">]</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fact</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leof_lift<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gen_step'_refine<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1" id="Rec_Impl-reachable_invar"><span class="command">lemma</span></span> reachable_invar<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"gen_rwof' <span class="free">s</span> <span class="main">⟹</span> set <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> reachable <span class="main">∧</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">⊆</span> E 
      <span class="main">∧</span> set <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> gen_discovered <span class="free">s</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span>
      <span class="main">∧</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">⊆</span> set <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span> <span class="main">×</span> UNIV"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> establish_rwof_invar<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> init_spec<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> gen_step'_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span>
      leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> new_root_spec<span class="main"><span class="main">]</span></span>
      SELECT_rule<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> leof_lift<span class="main"><span class="main">]</span></span>
      leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> choose_pending_spec<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> leof_strengthen_SPEC<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
      leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> finish_spec<span class="main"><span class="main">]</span></span>
      leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cross_edge_spec<span class="main"><span class="main">]</span></span>
      leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> back_edge_spec<span class="main"><span class="main">]</span></span>
      leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> discover_spec<span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
    

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
        
        
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">unfold</span> pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pwD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_fmt<span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
          
          
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv gen_cond_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pwD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_fmt<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pwD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_fmt<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> ImageI SigmaD1 rtrancl_image_unfold_right subset_eq<span class="main">)</span>  

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
        
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fast</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">unfold</span> pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pwD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_fmt<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Rec_Impl-mk_spec_aux"><span class="command">lemma</span></span> mk_spec_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="free">Φ</span><span class="main">;</span> <span class="free">m</span><span class="main">≤</span>SPEC gen_rwof' <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> gen_rwof' <span class="bound">s</span> <span class="main">∧</span> <span class="free">Φ</span> <span class="bound">s</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule_conj_leofI1<span class="main">)</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">post_choose_pending</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">vo</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    gen_rwof' <span class="free"><span class="bound"><span class="entity">s0</span></span></span> 
  <span class="main">∧</span> gen_cond <span class="free"><span class="bound"><span class="entity">s0</span></span></span>
  <span class="main">∧</span> <span class="free">stack</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="main">≠</span> <span class="main">[]</span>
  <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">=</span>hd <span class="main">(</span><span class="free">stack</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">)</span>  
  <span class="main">∧</span> inres <span class="main">(</span><span class="free">choose_pending</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">vo</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
  <span class="main">∧</span> <span class="free">stack</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free">stack</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> gds_is_discovered <span class="free">gds</span> <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">)</span>
  <span class="comment1">⌦‹∧ gds_is_break gds s = gds_is_break gds s0›</span>
  <span class="main">∧</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">vo</span></span></span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">=</span><span class="main">{}</span> <span class="main">∧</span> <span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span>
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span> <span class="main">∧</span> <span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free">pending</span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">context</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> nofail<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>gds_init <span class="free">gds</span> <span class="main">⤜</span> WHILE gen_cond gen_step'<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> nofail2<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>gen_dfs<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1" id="Rec_Impl-pcp_imp_pgp"><span class="command">lemma</span></span> pcp_imp_pgp<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"post_choose_pending <span class="free">u</span> <span class="free">vo</span> <span class="free">s0</span> <span class="free">s</span> <span class="main">⟹</span> post_get_pending <span class="free">u</span> <span class="free">vo</span> <span class="free">s0</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> post_choose_pending_def pre_defs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_rwof'_imp_rwof<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail2<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pwD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_fmt<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_cond_def 
          gen_rwof'_imp_rwof<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail2<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_init_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?prop</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mk_spec_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> init_spec<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rwof_init<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nofail<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_new_root_refine<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">;</span> gen_rwof' <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gds_new_root <span class="free">gds</span> <span class="free">v0</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="var">?Φ</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mk_spec_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> new_root_spec<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> nofail<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">s</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gen_step'_def pre_new_root_def gen_cond_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_choose_pending_refine<span class="main">:</span> 
      <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_get_pending <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_rwof' <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span>hd <span class="main">(</span><span class="free">stack</span> <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="free">vo</span> <span class="keyword1">of</span> 
          None <span class="main">⇒</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>
        <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">pending</span> <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">choose_pending</span> <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="main">(</span>post_choose_pending <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> WHILE_nofail_imp_rwof_nofail<span class="main">[</span><span class="operator">OF</span> nofail 2<span class="main">]</span> 1 3 <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"nofail <span class="main">(</span><span class="free">choose_pending</span> <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pre_defs gen_step'_def gen_cond_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def 
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">choose_pending</span> <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="main">(</span>post_choose_pending <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> choose_pending_spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> 1 _ 3<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">THEN</span> leof_strengthen_SPEC<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leof_RES_rule<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> 1
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> post_choose_pending_def 2 pre_defs gen_cond_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> 3
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>leofD<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_finish_refine<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_finish <span class="free">u</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> post_choose_pending <span class="free">u</span> None <span class="free">s0</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gds_finish <span class="free">gds</span> <span class="free">u</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="var">?Φ</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mk_spec_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> finish_spec<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> nofail<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">s0</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gen_step'_def pre_defs gen_cond_def post_choose_pending_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_cross_edge_refine<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> post_choose_pending <span class="free">u</span> <span class="main">(</span>Some <span class="free">v</span><span class="main">)</span> <span class="free">s0</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gds_cross_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="var">?Φ</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mk_spec_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cross_edge_spec<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> nofail<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">s0</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gen_step'_def pre_defs gen_cond_def post_choose_pending_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_back_edge_refine<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> post_choose_pending <span class="free">u</span> <span class="main">(</span>Some <span class="free">v</span><span class="main">)</span> <span class="free">s0</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gds_back_edge <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="var">?Φ</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mk_spec_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> back_edge_spec<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> nofail<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">s0</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gen_step'_def pre_defs gen_cond_def post_choose_pending_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

    <span class="keyword1"><span class="command">schematic_goal</span></span> gds_discover_refine<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span>pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> post_choose_pending <span class="free">u</span> <span class="main">(</span>Some <span class="free">v</span><span class="main">)</span> <span class="free">s0</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> gds_discover <span class="free">gds</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> SPEC <span class="var">?Φ</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mk_spec_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> discover_spec<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rwof_step<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> nofail<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">s0</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gen_step'_def pre_defs gen_cond_def post_choose_pending_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> select_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
  <span class="keyword2"><span class="keyword">end</span></span>

  
  <span class="keyword1" id="Rec_Impl-rec_impl_aux"><span class="command">lemma</span></span> rec_impl_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xd</span><span class="main">∉</span>Domain <span class="free">P</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">-</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span> <span class="main">×</span> <span class="main">(</span>succ <span class="free">y</span> <span class="main">-</span> <span class="free">ita</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">xd</span><span class="main">)</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="free">xd</span><span class="main">}</span> <span class="main">×</span> UNIV <span class="main">=</span>
           <span class="free">P</span> <span class="main">-</span> insert <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">xd</span><span class="main">)</span> <span class="main">(</span><span class="main">{</span><span class="free">y</span><span class="main">}</span> <span class="main">×</span> <span class="main">(</span>succ <span class="free">y</span> <span class="main">-</span> <span class="free">ita</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
           

  <span class="keyword1" id="Rec_Impl-rec_impl"><span class="command">lemma</span></span> rec_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"rec_impl <span class="main">≤</span> gen_dfs"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_nofailI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ gen_dfs'_refine<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_dfs'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILE_refine_rwof<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> rec_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_init_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_choose_pending_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_new_root_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_finish_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_back_edge_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_cross_edge_refine<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gds_discover_refine<span class="main"><span class="main">]</span></span>
    <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reachable_invar<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">drule</span> pcp_imp_pgp<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main">)</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">drule</span> pcp_imp_pgp<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main">)</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">drule</span> pcp_imp_pgp<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main">)</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rprems</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SPEC_rule<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> post_choose_pending_def gen_rwof'_imp_rwof
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_rwof'_imp_rwof Un_Diff
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff neq_Nil_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rec_impl_aux<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> reachable_invar<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Domain.cases SigmaD1 mem_Collect_eq rev_subsetD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reachable_invar<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">drule</span> pcp_imp_pgp<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_defs gen_rwof'_imp_rwof<span class="main">)</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> post_choose_pending_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gen_cond_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Simple_Impl">
<div class="head">
<h1>Theory Simple_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Simple Data Structures›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Simple_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Rec_Impl.html">../Structural/Rec_Impl</a>"</span>
  <span class="quoted">"<a href="Tailrec_Impl.html">../Structural/Tailrec_Impl</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide some very basic data structures to implement the DFS state
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ Stack, Pending Stack, and Visited Set ›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> simple_state <span class="main">=</span>
  ss_stack <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span> set<span class="main">)</span> list"</span></span>
  on_stack <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
  visited <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">simple_state_rel</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span> <span class="main">.</span>
  ss_stack <span class="bound">s</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span>pending <span class="bound">s'</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
  on_stack <span class="bound">s</span> <span class="main">=</span> set <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
  visited <span class="bound">s</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
  dom <span class="main">(</span>finished <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span> <span class="comment1">― ‹TODO: Hmm, this is an invariant of the abstract›</span>
  set <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">,</span> state.more <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="Simple_Impl-simple_state_relI"><span class="command">lemma</span></span> simple_state_relI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
  <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="free">s'</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span>stack <span class="free">s'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="free">s'</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m'</span><span class="main">,</span> state.more <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">erel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⦇</span>
    ss_stack <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span>pending <span class="free">s'</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>stack <span class="free">s'</span><span class="main">)</span><span class="main">,</span>
    on_stack <span class="main">=</span> set <span class="main">(</span>stack <span class="free">s'</span><span class="main">)</span><span class="main">,</span>
    visited <span class="main">=</span> dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span><span class="main">,</span>
    <span class="main">…</span> <span class="main">=</span> <span class="free">m'</span>
  <span class="main">⦈</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">erel</span><span class="main">⟩</span>simple_state_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Simple_Impl-simple_state_more_refine"><span class="command">lemma</span></span> simple_state_more_refine<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state.more_update<span class="main">,</span> state.more_update<span class="main">)</span>
    <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">→</span> <span class="free">R</span><span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>simple_state_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>simple_state_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_state_rel_def<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ We outsource the definitions in a separate locale, as we want to re-use them
  for similar implementations ›</span></span>
<span class="keyword1"><span class="command">locale</span></span> pre_simple_impl <span class="main">=</span> graph_defs
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_impl</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> 
    <span class="main">≡</span> RETURN <span class="main">⦇</span> ss_stack <span class="main">=</span> <span class="main">[]</span><span class="main">,</span> on_stack <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> visited <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_empty_stack_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_discovered_impl</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>visited <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_finished_impl</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>visited <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">-</span> <span class="main">(</span>on_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">finish_impl</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>on_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span>ss_stack <span class="main">:=</span> tl <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">⦈</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦇</span>on_stack <span class="main">:=</span> on_stack <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">⦈</span><span class="main">;</span>
    RETURN <span class="bound">s</span>
    <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_pending_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">Vs</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span>
        RETURN <span class="main">(</span><span class="bound">u</span><span class="main">,</span>None<span class="main">,</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">v</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">Vs</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">Vs</span> <span class="main">=</span> <span class="bound">Vs</span> <span class="main">-</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> ss_stack <span class="main">:=</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">)</span> <span class="main">#</span> tl <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⦈</span><span class="main">;</span>
        RETURN <span class="main">(</span><span class="bound">u</span><span class="main">,</span> Some <span class="bound">v</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">discover_impl</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∉</span>on_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∉</span>visited <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span>ss_stack <span class="main">:=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span>E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">)</span> <span class="main">#</span> ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦇</span>on_stack <span class="main">:=</span> insert <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>on_stack <span class="bound">s</span><span class="main">)</span><span class="main">⦈</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦇</span>visited <span class="main">:=</span> insert <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>visited <span class="bound">s</span><span class="main">)</span><span class="main">⦈</span><span class="main">;</span>
    RETURN <span class="bound">s</span>
    <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">new_root_impl</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">∉</span>visited <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span>ss_stack <span class="main">:=</span> <span class="main">[</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">,</span>E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">]</span><span class="main">⦈</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦇</span>on_stack <span class="main">:=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">⦈</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦇</span>visited <span class="main">:=</span> insert <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span>visited <span class="bound">s</span><span class="main">)</span><span class="main">⦈</span><span class="main">;</span>
    RETURN <span class="bound">s</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gbs</span> <span class="main">≡</span> <span class="main">⦇</span>
    gbs_init <span class="main">=</span> init_impl<span class="main">,</span>
    gbs_is_empty_stack <span class="main">=</span> is_empty_stack_impl <span class="main">,</span>
    gbs_new_root <span class="main">=</span>  new_root_impl <span class="main">,</span>
    gbs_get_pending <span class="main">=</span> get_pending_impl <span class="main">,</span>
    gbs_finish <span class="main">=</span>  finish_impl <span class="main">,</span>
    gbs_is_discovered <span class="main">=</span> is_discovered_impl <span class="main">,</span>
    gbs_is_finished <span class="main">=</span> is_finished_impl <span class="main">,</span>
    gbs_back_edge <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="bound">s</span><span class="main">)</span> <span class="main">,</span>
    gbs_cross_edge <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="bound">s</span><span class="main">)</span> <span class="main">,</span>
    gbs_discover <span class="main">=</span> discover_impl
  <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> gbs_simps<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> gen_basic_dfs_struct.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> gbs_def<span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> impl_defs<span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span> 
  <span class="main">=</span> init_impl_def is_empty_stack_impl_def new_root_impl_def
    get_pending_impl_def finish_impl_def is_discovered_impl_def 
    is_finished_impl_def discover_impl_def

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Simple implementation of a DFS. This locale assumes a refinement of the
  parameters, and provides an implementation via a stack and a visited set.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> simple_impl_defs <span class="main">=</span>
  a<span class="main">:</span> param_DFS_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">param</span></span>
  <span class="main">+</span> c<span class="main">:</span> pre_simple_impl
  <span class="main">+</span> gen_param_dfs_refine_defs 
    <span class="keyword2"><span class="keyword">where</span></span> gbsi <span class="main">=</span> <span class="quoted">c.gbs</span> 
    <span class="keyword2"><span class="keyword">and</span></span> gbs <span class="main">=</span> <span class="quoted">a.gbs</span>
    <span class="keyword2"><span class="keyword">and</span></span> upd_exti <span class="main">=</span> <span class="quoted">simple_state.more_update</span>
    <span class="keyword2"><span class="keyword">and</span></span> upd_ext <span class="main">=</span> <span class="quoted">state.more_update</span>
    <span class="keyword2"><span class="keyword">and</span></span> V0i <span class="main">=</span> <span class="quoted">a.V0</span>
    <span class="keyword2"><span class="keyword">and</span></span> V0 <span class="main">=</span> <span class="quoted">a.V0</span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> tailrec_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">c.gds</span> <span class="keyword1"><span class="command">.</span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">×</span><span class="bound">Vs</span><span class="main">)</span> <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_stack</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> map fst <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">choose_pending</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> option <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> simple_state_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'d</span><span class="main">)</span> simple_state_scheme nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">choose_pending</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">vo</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">vo</span></span></span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> RETURN <span class="free"><span class="bound"><span class="entity">s</span></span></span>
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
        RETURN <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> ss_stack <span class="main">:=</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">-</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span><span class="main">#</span>tl <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span>
      <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> rec_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">c.gds</span> <span class="quoted">get_pending</span> <span class="quoted">get_stack</span> <span class="quoted">choose_pending</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
  

<span class="keyword1"><span class="command">locale</span></span> simple_impl <span class="main">=</span>
  a<span class="main">:</span> param_DFS
  <span class="main">+</span> simple_impl_defs
  <span class="main">+</span> param_refinement
    <span class="keyword2"><span class="keyword">where</span></span> gbsi <span class="main">=</span> <span class="quoted">c.gbs</span>
    <span class="keyword2"><span class="keyword">and</span></span> gbs <span class="main">=</span> <span class="quoted">a.gbs</span>
    <span class="keyword2"><span class="keyword">and</span></span> upd_exti <span class="main">=</span> <span class="quoted">simple_state.more_update</span>
    <span class="keyword2"><span class="keyword">and</span></span> upd_ext <span class="main">=</span> <span class="quoted">state.more_update</span>
    <span class="keyword2"><span class="keyword">and</span></span> V0i <span class="main">=</span> <span class="quoted">a.V0</span>
    <span class="keyword2"><span class="keyword">and</span></span> V0 <span class="main">=</span> <span class="quoted">a.V0</span>
    <span class="keyword2"><span class="keyword">and</span></span> V<span class="main">=</span><span class="quoted">Id</span>
    <span class="keyword2"><span class="keyword">and</span></span> S <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="Simple_Impl-init_impl"><span class="command">lemma</span></span> init_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span> <span class="free">e</span><span class="main">)</span> <span class="main">∈</span> <span class="free">ES</span> <span class="main">⟹</span>
    c.init_impl <span class="free">ei</span> <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> <span class="main">(</span>RETURN <span class="main">(</span>a.empty_state <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> c.init_impl_def a.empty_state_def simple_state_rel_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1" id="Simple_Impl-new_root_impl"><span class="command">lemma</span></span> new_root_impl<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.gen_dfs.pre_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">;</span> 
      <span class="main">(</span><span class="free">v0i</span><span class="main">,</span> <span class="free">v0</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">⟧</span>
      <span class="main">⟹</span> c.new_root_impl <span class="free">v0</span> <span class="free">si</span> <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> <span class="main">(</span>RETURN <span class="main">(</span>a.new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def a.gen_dfs.pre_new_root_def c.new_root_impl_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a.pred_defs<span class="main">)</span>
  
  <span class="keyword1" id="Simple_Impl-get_pending_impl"><span class="command">lemma</span></span> get_pending_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"
    <span class="main">⟦</span>a.gen_dfs.pre_get_pending <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">⟧</span>
      <span class="main">⟹</span> c.get_pending_impl <span class="free">si</span> 
          <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> <span class="main">(</span>a.get_pending <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> a.get_pending_def c.get_pending_impl_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine' Let_refine' IdI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_state_rel_def a.gen_dfs.pre_defs a.pred_defs neq_Nil_conv
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> DFS_invar.stack_distinct
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Simple_Impl-inres_get_pending_None_conv"><span class="command">lemma</span></span> inres_get_pending_None_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"inres <span class="main">(</span>a.get_pending <span class="free">s0</span><span class="main">)</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> None<span class="main">,</span> <span class="free">s</span><span class="main">)</span> 
      <span class="main">⟷</span> <span class="free">s</span><span class="main">=</span><span class="free">s0</span> <span class="main">∧</span> <span class="free">v</span><span class="main">=</span>hd <span class="main">(</span>stack <span class="free">s0</span><span class="main">)</span> <span class="main">∧</span> pending <span class="free">s0</span><span class="main">``</span><span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s0</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> a.get_pending_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Simple_Impl-inres_get_pending_Some_conv"><span class="command">lemma</span></span> inres_get_pending_Some_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"inres <span class="main">(</span>a.get_pending <span class="free">s0</span><span class="main">)</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span>Some <span class="free">Vs</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> 
      <span class="main">⟷</span> <span class="free">v</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free">s</span> <span class="main">=</span> <span class="free">s0</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="free">s0</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s0</span><span class="main">)</span><span class="main">,</span> <span class="free">Vs</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span>
       <span class="main">∧</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s0</span><span class="main">)</span><span class="main">,</span> <span class="free">Vs</span><span class="main">)</span> <span class="main">∈</span> pending <span class="free">s0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> a.get_pending_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Simple_Impl-finish_impl"><span class="command">lemma</span></span> finish_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.gen_dfs.pre_finish <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">⟧</span>
     <span class="main">⟹</span> c.finish_impl <span class="free">v</span> <span class="free">si</span> <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> <span class="main">(</span>RETURN <span class="main">(</span>a.finish <span class="free">v</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def a.gen_dfs.pre_defs c.finish_impl_def
       
      <span class="comment1">(* Proof is fine-tuned to optimize speed *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inres_get_pending_None_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> DFS_invar.stack_distinct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a.pred_defs map_tl<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword1" id="Simple_Impl-cross_edge_impl"><span class="command">lemma</span></span> cross_edge_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"
    <span class="main">⟦</span>a.gen_dfs.pre_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> 
      <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">⟧</span>
      <span class="main">⟹</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> a.cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def a.gen_dfs.pre_defs
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  <span class="keyword1" id="Simple_Impl-back_edge_impl"><span class="command">lemma</span></span> back_edge_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"
    <span class="main">⟦</span>a.gen_dfs.pre_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> 
      <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">⟧</span>
      <span class="main">⟹</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> a.back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def a.gen_dfs.pre_defs
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  <span class="keyword1" id="Simple_Impl-discover_impl"><span class="command">lemma</span></span> discover_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>a.gen_dfs.pre_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s0</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">⟧</span>
     <span class="main">⟹</span> c.discover_impl <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> <span class="main">(</span>RETURN <span class="main">(</span>a.discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def a.gen_dfs.pre_defs c.discover_impl_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ASSERT_leI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inres_get_pending_Some_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> DFS_invar.stack_discovered<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a.pred_defs<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inres_get_pending_Some_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> DFS_invar.stack_discovered<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> DFS_invar.pending_ssE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a.pred_defs<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> gen_param_dfs_refine 
    <span class="keyword2"><span class="keyword">where</span></span> gbsi <span class="main">=</span> <span class="quoted">c.gbs</span> 
    <span class="keyword2"><span class="keyword">and</span></span> gbs <span class="main">=</span> <span class="quoted">a.gbs</span>
    <span class="keyword2"><span class="keyword">and</span></span> upd_exti <span class="main">=</span> <span class="quoted">simple_state.more_update</span>
    <span class="keyword2"><span class="keyword">and</span></span> upd_ext <span class="main">=</span> <span class="quoted">state.more_update</span>
    <span class="keyword2"><span class="keyword">and</span></span> V0i <span class="main">=</span> <span class="quoted">a.V0</span>
    <span class="keyword2"><span class="keyword">and</span></span> V0 <span class="main">=</span> <span class="quoted">a.V0</span>
    <span class="keyword2"><span class="keyword">and</span></span> V <span class="main">=</span> <span class="quoted">Id</span>
    <span class="keyword2"><span class="keyword">and</span></span> S <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_break_param<span class="main">)</span> <span class="comment1">(* TODO: Strange effect,   
      the is_break_param subgoal should not be visible at all!*)</span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a.is_discovered_def c.is_discovered_impl_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a.is_finished_def c.is_finished_impl_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a.is_empty_stack_def c.is_empty_stack_impl_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> init_impl<span class="main">)</span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> new_root_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> get_pending_impl<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> finish_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> cross_edge_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> back_edge_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> discover_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Main outcome of this locale: The simple DFS-Algorithm, which is
    a general DFS scheme itself (and thus open to further refinements),
    and a refinement theorem that states correct refinement of the original DFS ›</span></span>

  <span class="keyword1" id="Simple_Impl-simple_refine"><span class="command">lemma</span></span> simple_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"c.gen_dfs <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> a.it_dfs"</span></span>
    <span class="keyword1"><span class="command">using</span></span> gen_dfs_refine
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="Simple_Impl-simple_refineT"><span class="command">lemma</span></span> simple_refineT<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"c.gen_dfsT <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> a.it_dfsT"</span></span>
    <span class="keyword1"><span class="command">using</span></span> gen_dfsT_refine
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Link with tail-recursive implementation›</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> tailrec_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">c.gds</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> c.do_action_defs c.impl_defs<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Simple_Impl-simple_tailrec_refine"><span class="command">lemma</span></span> simple_tailrec_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tailrec_impl <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> a.it_dfs"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> tailrec_impl <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> simple_refine <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Simple_Impl-simple_tailrecT_refine"><span class="command">lemma</span></span> simple_tailrecT_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tailrec_implT <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> a.it_dfsT"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> tailrecT_impl <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> simple_refineT <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Link to recursive implementation›</span></span>
  <span class="comment1">(* TODO: Currently, we have to prove this invar at several places.
    Maybe it's worth to share in a common locale!?
  *)</span>
  <span class="keyword1" id="Simple_Impl-reachable_invar"><span class="command">lemma</span></span> reachable_invar<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"c.gen_rwof <span class="free">s</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>map fst <span class="main">(</span>ss_stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> visited <span class="free">s</span> 
      <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="main">(</span>ss_stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_rwof_invar<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> -1<span class="main"><span class="main">,</span></span> <span class="operator">consumes</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> c.do_action_defs c.impl_defs<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">unfolding</span></span> c.gen_step_def c.do_action_defs c.impl_defs<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> c.gds_simps c.gbs_simps
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">sublocale</span></span> rec_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">c.gds</span> <span class="quoted">get_pending</span> <span class="quoted">get_stack</span> <span class="quoted">choose_pending</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">unfolding</span></span> get_pending_def get_stack_def choose_pending_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> c.do_action_defs c.impl_defs<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff select_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff select_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_ASSERTI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> c.pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> reachable_invar<span class="main">)</span>
      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff neq_Nil_conv
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>  

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> c.pre_defs<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> reachable_invar<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff select_def c.impl_defs neq_Nil_conv
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff select_def neq_Nil_conv c.pre_defs c.impl_defs
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split if_split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Simple_Impl-simple_rec_refine"><span class="command">lemma</span></span> simple_rec_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rec_impl <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> a.it_dfs"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> rec_impl <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> simple_refine <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Autoref Setup ›</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_impl <span class="main">=</span>
  ss_stack_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'si</span></span></span>
  ss_on_stack_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'nsi</span></span></span>
  ss_visited_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'nsi</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ss_impl_rel</span> <span class="free"><span class="bound"><span class="entity">s_rel</span></span></span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> 
  <span class="main">{</span><span class="main">(</span><span class="main">⦇</span>ss_stack_impl <span class="main">=</span> <span class="bound">si</span><span class="main">,</span> ss_on_stack_impl <span class="main">=</span> <span class="bound">osi</span><span class="main">,</span> ss_visited_impl <span class="main">=</span> <span class="bound">visi</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">mi</span><span class="main">⦈</span><span class="main">,</span>
    <span class="main">⦇</span>ss_stack <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> on_stack <span class="main">=</span> <span class="bound">os</span><span class="main">,</span> visited <span class="main">=</span> <span class="bound">vis</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">m</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span>
    <span class="bound">si</span> <span class="bound">osi</span> <span class="bound">visi</span> <span class="bound">mi</span> <span class="bound">s</span> <span class="bound">os</span> <span class="bound">vis</span> <span class="bound">m</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">si</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">s_rel</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="bound">osi</span><span class="main">,</span> <span class="bound">os</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="bound">visi</span><span class="main">,</span> <span class="bound">vis</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="bound">mi</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">consts</span></span> 
  i_simple_state <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface <span class="main">⇒</span> interface <span class="main">⇒</span> interface"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">ss_impl_rel</span> <span class="quoted">i_simple_state</span><span class="main">]</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">simple_state_ext</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">,</span> <span class="operator">param</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s_rel</span> <span class="free">ps_rel</span> <span class="free">vis_rel</span> <span class="free">erel</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">s_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="free">erel</span><span class="main">⟩</span>ss_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_stack_impl<span class="main">,</span> ss_stack<span class="main">)</span> <span class="main">∈</span>  <span class="free">R</span> <span class="main">→</span> <span class="free">s_rel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_on_stack_impl<span class="main">,</span> on_stack<span class="main">)</span> <span class="main">∈</span>  <span class="free">R</span> <span class="main">→</span> <span class="free">vis_rel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_visited_impl<span class="main">,</span> visited<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">vis_rel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_impl.more<span class="main">,</span> simple_state.more<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">erel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_stack_impl_update<span class="main">,</span> ss_stack_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">s_rel</span> <span class="main">→</span> <span class="free">s_rel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_on_stack_impl_update<span class="main">,</span> on_stack_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="free">vis_rel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_visited_impl_update<span class="main">,</span> visited_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="free">vis_rel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_impl.more_update<span class="main">,</span> simple_state.more_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">erel</span> <span class="main">→</span> <span class="free">erel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_impl_ext<span class="main">,</span> simple_state_ext<span class="main">)</span> <span class="main">∈</span> <span class="free">s_rel</span> <span class="main">→</span> <span class="free">vis_rel</span> <span class="main">→</span> <span class="free">vis_rel</span> <span class="main">→</span> <span class="free">erel</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ss_impl_rel_def R_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ Simple state without on-stack ›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ We can further refine the simple implementation and drop the on-stack set ›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_nos_impl <span class="main">=</span>
  ssnos_stack_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'si</span></span></span>
  ssnos_visited_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'nsi</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ssnos_impl_rel</span> <span class="free"><span class="bound"><span class="entity">s_rel</span></span></span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> 
  <span class="main">{</span><span class="main">(</span><span class="main">⦇</span>ssnos_stack_impl <span class="main">=</span> <span class="bound">si</span><span class="main">,</span> ssnos_visited_impl <span class="main">=</span> <span class="bound">visi</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">mi</span><span class="main">⦈</span><span class="main">,</span>
    <span class="main">⦇</span>ss_stack <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> on_stack <span class="main">=</span> <span class="bound">os</span><span class="main">,</span> visited <span class="main">=</span> <span class="bound">vis</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">m</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span>
    <span class="bound">si</span> <span class="bound">visi</span> <span class="bound">mi</span> <span class="bound">s</span> <span class="bound">os</span> <span class="bound">vis</span> <span class="bound">m</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">si</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">s_rel</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="bound">visi</span><span class="main">,</span> <span class="bound">vis</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="bound">mi</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">ssnos_impl_rel</span> <span class="quoted">i_simple_state</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">op_nos_on_stack_update</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">_</span> set <span class="main">⇒</span> <span class="main">_</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span>simple_state_scheme <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">op_nos_on_stack_update</span> <span class="main">≡</span> on_stack_update"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat_def</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"op_nos_on_stack_update <span class="free">f</span> <span class="free">s</span> 
  <span class="main">≡</span> <span class="keyword1">OP</span> <span class="main">(</span>op_nos_on_stack_update <span class="free">f</span><span class="main">)</span><span class="main">$</span><span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> ssnos_unfolds <span class="comment1">― ‹To be unfolded before autoref when using <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">ssnos_impl_rel</span><span class="antiquote">}</span></span>›</span>
  <span class="main">=</span> op_nos_on_stack_update_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">,</span> <span class="operator">param</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s_rel</span> <span class="free">vis_rel</span> <span class="free">erel</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">s_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="free">erel</span><span class="main">⟩</span>ssnos_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ssnos_stack_impl<span class="main">,</span> ss_stack<span class="main">)</span> <span class="main">∈</span>  <span class="free">R</span> <span class="main">→</span> <span class="free">s_rel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ssnos_visited_impl<span class="main">,</span> visited<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">vis_rel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_nos_impl.more<span class="main">,</span> simple_state.more<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">erel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ssnos_stack_impl_update<span class="main">,</span> ss_stack_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">s_rel</span> <span class="main">→</span> <span class="free">s_rel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">,</span> op_nos_on_stack_update <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ssnos_visited_impl_update<span class="main">,</span> visited_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="free">vis_rel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_nos_impl.more_update<span class="main">,</span> simple_state.more_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">erel</span> <span class="main">→</span> <span class="free">erel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">ns</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ps</span> <span class="bound">vs</span><span class="main">.</span> simple_state_nos_impl_ext <span class="bound">ns</span> <span class="bound">ps</span> <span class="bound">vs</span><span class="main">,</span> simple_state_ext<span class="main">)</span> 
    <span class="main">∈</span> <span class="free">s_rel</span> <span class="main">→</span> <span class="free">ANY_rel</span> <span class="main">→</span> <span class="free">vis_rel</span> <span class="main">→</span> <span class="free">erel</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ssnos_impl_rel_def R_def op_nos_on_stack_update_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Simple state without stack and on-stack›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Even further refinement yields an implementation without a stack.
  Note that this only works for structural implementations that provide their own
  stack (e.g., recursive)!›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_ns_impl <span class="main">=</span>
  ssns_visited_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'nsi</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ssns_impl_rel</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'b</span><span class="main">)</span> set<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> 
  <span class="main">{</span><span class="main">(</span><span class="main">⦇</span>ssns_visited_impl <span class="main">=</span> <span class="bound">visi</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">mi</span><span class="main">⦈</span><span class="main">,</span>
    <span class="main">⦇</span>ss_stack <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> on_stack <span class="main">=</span> <span class="bound">os</span><span class="main">,</span> visited <span class="main">=</span> <span class="bound">vis</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">m</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span>
    <span class="bound">visi</span> <span class="bound">mi</span> <span class="bound">s</span> <span class="bound">os</span> <span class="bound">vis</span> <span class="bound">m</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">visi</span><span class="main">,</span> <span class="bound">vis</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">vis_rel</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="bound">mi</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">ssns_impl_rel</span> <span class="quoted">i_simple_state</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">op_ns_on_stack_update</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">_</span> set <span class="main">⇒</span> <span class="main">_</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span>simple_state_scheme <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">op_ns_on_stack_update</span> <span class="main">≡</span> on_stack_update"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">op_ns_stack_update</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">_</span> list <span class="main">⇒</span> <span class="main">_</span> list<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span>simple_state_scheme <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">op_ns_stack_update</span> <span class="main">≡</span> ss_stack_update"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat_def</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"op_ns_on_stack_update <span class="free">f</span> <span class="free">s</span> 
  <span class="main">≡</span> <span class="keyword1">OP</span> <span class="main">(</span>op_ns_on_stack_update <span class="free">f</span><span class="main">)</span><span class="main">$</span><span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat_def</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"op_ns_stack_update <span class="free">f</span> <span class="free">s</span> 
  <span class="main">≡</span> <span class="keyword1">OP</span> <span class="main">(</span>op_ns_stack_update <span class="free">f</span><span class="main">)</span><span class="main">$</span><span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> simple_impl_defs <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">thm</span></span> choose_pending_def<span class="main">[</span><span class="operator">unfolded</span> op_ns_stack_update_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">no_vars</span><span class="main">]</span>

  <span class="keyword1" id="Simple_Impl-choose_pending_ns_unfold"><span class="command">lemma</span></span> choose_pending_ns_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"choose_pending <span class="free">u</span> <span class="free">vo</span> <span class="free">s</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">case</span> <span class="free">vo</span> <span class="keyword1">of</span> None <span class="main">⇒</span> RETURN <span class="free">s</span>
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main"><span class="bound">_</span></span> <span class="main">←</span> ASSERT <span class="main">(</span>ss_stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
          RETURN
           <span class="main">(</span>op_ns_stack_update 
             <span class="main">(</span> <span class="keyword1">let</span> 
                 <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">Vs</span><span class="main">)</span> <span class="main">=</span> hd <span class="main">(</span>ss_stack <span class="free">s</span><span class="main">)</span> 
               <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">Vs</span> <span class="main">-</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span> <span class="main">#</span> tl <span class="main">(</span>ss_stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>
             <span class="main">)</span>
             <span class="free">s</span>
           <span class="main">)</span>
        <span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> choose_pending_def op_ns_stack_update_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split prod.split<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> ssns_unfolds <span class="comment1">― ‹To be unfolded before autoref when using <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">ssns_impl_rel</span><span class="antiquote">}</span></span>.
    Attention: This lemma conflicts with the standard unfolding lemma in 
    <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">DFS_code_unfold</span><span class="antiquote">}</span></span>, so has to be placed first in an unfold-statement!›</span>
  <span class="main">=</span> op_ns_on_stack_update_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> op_ns_stack_update_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    choose_pending_ns_unfold

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">,</span> <span class="operator">param</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s_rel</span> <span class="free">vis_rel</span> <span class="free">erel</span> <span class="free">ANY_rel</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">ANY_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="free">erel</span><span class="main">⟩</span>ssns_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ssns_visited_impl<span class="main">,</span> visited<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">vis_rel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_ns_impl.more<span class="main">,</span> simple_state.more<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">erel</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">,</span> op_ns_stack_update <span class="bound">f</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">,</span> op_ns_on_stack_update <span class="bound">f</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ssns_visited_impl_update<span class="main">,</span> visited_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="free">vis_rel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>simple_state_ns_impl.more_update<span class="main">,</span> simple_state.more_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">erel</span> <span class="main">→</span> <span class="free">erel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">ps</span> <span class="bound">vs</span><span class="main">.</span> simple_state_ns_impl_ext <span class="bound">ps</span> <span class="bound">vs</span><span class="main">,</span> simple_state_ext<span class="main">)</span> 
    <span class="main">∈</span> <span class="free">ANY1_rel</span> <span class="main">→</span> <span class="free">ANY2_rel</span> <span class="main">→</span> <span class="free">vis_rel</span> <span class="main">→</span> <span class="free">erel</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ssns_impl_rel_def R_def op_ns_on_stack_update_def op_ns_stack_update_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">refine_transfer_post_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">a</span><span class="main">⦇</span>simple_state_nos_impl.more <span class="main">:=</span> <span class="bound">m</span><span class="main">::</span>unit<span class="main">⦈</span> <span class="main">=</span> <span class="bound">a</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">a</span><span class="main">⦇</span>simple_state_impl.more <span class="main">:=</span> <span class="bound">m</span><span class="main">::</span>unit<span class="main">⦈</span> <span class="main">=</span> <span class="bound">a</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">a</span><span class="main">⦇</span>simple_state_ns_impl.more <span class="main">:=</span> <span class="bound">m</span><span class="main">::</span>unit<span class="main">⦈</span> <span class="main">=</span> <span class="bound">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Restr_Impl">
<div class="head">
<h1>Theory Restr_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Restricting Nodes by Pre-Initializing Visited Set›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Restr_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Simple_Impl.html">Simple_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Implementation of node and edge restriction via pre-initialized visited set.

  We now further refine the simple implementation in case that the graph has
  the form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>G'=(rel_restrict E R, V0-R)›</span></span></span></span> for some <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fb_graph G=(E,V0)›</span></span></span></span>.
  If, additionally, the parameterization is not "too sensitive" to the 
  visited set, we can pre-initialize the visited set with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R›</span></span></span></span>, and use the
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>V0›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>E›</span></span></span></span> of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>G›</span></span></span></span>. This may be a more efficient implementation 
  than explicitely
  restricting <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>V0›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>E›</span></span></span></span>, as it saves additional membership queries in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R›</span></span></span></span> 
  on each successor function call. 
  
  Moreover, in applications where the restriction is updated between multiple 
  calls, we can use one linearly accessed restriction set.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">restr_rel</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">.</span> 
  <span class="main">(</span>ss_stack <span class="bound">s</span><span class="main">,</span> ss_stack <span class="bound">s'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">{</span><span class="main">(</span><span class="bound">U</span><span class="main">,</span><span class="bound">U'</span><span class="main">)</span><span class="main">.</span> <span class="bound">U</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="bound">U'</span><span class="main">}</span><span class="main">⟩</span>list_rel 
<span class="main">∧</span> on_stack <span class="bound">s</span> <span class="main">=</span> on_stack <span class="bound">s'</span>
<span class="main">∧</span> visited <span class="bound">s</span> <span class="main">=</span> visited <span class="bound">s'</span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> visited <span class="bound">s'</span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">{}</span>
<span class="main">∧</span> simple_state.more <span class="bound">s</span> <span class="main">=</span> simple_state.more <span class="bound">s'</span> <span class="main">}</span>"</span></span>

<span class="keyword1" id="Restr_Impl-restr_rel_simps"><span class="command">lemma</span></span> restr_rel_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>restr_rel <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"visited <span class="free">s</span> <span class="main">=</span> visited <span class="free">s'</span> <span class="main">∪</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"simple_state.more <span class="free">s</span> <span class="main">=</span> simple_state.more <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> restr_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>restr_rel <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> restr_rel_stackD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ss_stack <span class="free">s</span><span class="main">,</span> ss_stack <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">{</span><span class="main">(</span><span class="bound">U</span><span class="main">,</span><span class="bound">U'</span><span class="main">)</span><span class="main">.</span> <span class="bound">U</span><span class="main">-</span><span class="free">R</span> <span class="main">=</span> <span class="bound">U'</span><span class="main">}</span><span class="main">⟩</span>list_rel"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> restr_rel_vis_djD<span class="main">:</span> <span class="quoted"><span class="quoted">"visited <span class="free">s'</span> <span class="main">∩</span> <span class="free">R</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> restr_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">restr_simple_state_rel</span> <span class="free"><span class="bound"><span class="entity">ES</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span> <span class="main">.</span>
    <span class="main">(</span>ss_stack <span class="bound">s</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span>pending <span class="bound">s'</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">∈</span> <span class="main">⟨</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">{</span><span class="main">(</span><span class="bound">U</span><span class="main">,</span><span class="bound">U'</span><span class="main">)</span><span class="main">.</span> <span class="bound">U</span><span class="main">-</span><span class="free">R</span> <span class="main">=</span> <span class="bound">U'</span><span class="main">}</span><span class="main">⟩</span>list_rel <span class="main">∧</span>
    on_stack <span class="bound">s</span> <span class="main">=</span> set <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
    visited <span class="bound">s</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">∪</span> <span class="free">R</span> <span class="main">∧</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">∩</span> <span class="free">R</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span>
    dom <span class="main">(</span>finished <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
    set <span class="main">(</span>stack <span class="bound">s'</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="bound">s'</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">,</span> state.more <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">ES</span></span></span>
  <span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Restr_Impl-restr_simple_state_rel_combine"><span class="command">lemma</span></span> restr_simple_state_rel_combine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>restr_simple_state_rel <span class="free">R</span> <span class="main">=</span> restr_rel <span class="free">R</span> <span class="keyword1">O</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> restr_simple_state_rel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> relcompI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ simple_state_relI<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_rel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Locale that assumes a simple implementation, makes some 
  additional assumptions on the parameterization (intuitively, that it
  is not too sensitive to adding nodes from R to the visited set), and then
  provides a new implementation with pre-initialized visited set.
›</span></span>
<span class="comment1">(* 
  TODO/FIXME: The refinement step from simple_impl is not yet clean,
    as the parameterizatioin refinement is not handled properly.
    Ideally, one would assume the required parameterization refinement
    w.r.t. restr_simple_state_rel, and derive the refinement for 
    simple_state_rel.
 
*)</span>

<span class="keyword1"><span class="command">locale</span></span> restricted_impl_defs <span class="main">=</span>
  graph_defs <span class="quoted"><span class="free">G</span></span> <span class="main">+</span>
  a<span class="main">:</span> simple_impl_defs <span class="quoted"><span class="quoted">"graph_restrict <span class="free">G</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">R</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> pre_simple_impl <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel</span> <span class="main">≡</span> restr_rel <span class="free">R</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gbs'</span> <span class="main">≡</span> gbs <span class="main">⦇</span> 
    gbs_init <span class="main">:=</span> <span class="main">λ</span><span class="bound">e</span><span class="main">.</span> RETURN 
      <span class="main">⦇</span> ss_stack<span class="main">=</span><span class="main">[]</span><span class="main">,</span> on_stack<span class="main">=</span><span class="main">{}</span><span class="main">,</span> visited <span class="main">=</span> <span class="free">R</span><span class="main">,</span> <span class="main">…</span><span class="main">=</span><span class="bound">e</span> <span class="main">⦈</span> <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> gbs'_simps<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">DFS_code_unfold</span><span class="main">]</span>
    <span class="main">=</span> gen_basic_dfs_struct.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> gbs'_def<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator">unfolded</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> gbs_simps<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">sublocale</span></span> gen_param_dfs_defs <span class="quoted">gbs'</span> <span class="quoted"><span class="free">parami</span></span> <span class="quoted">simple_state.more_update</span> <span class="quoted">V0</span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="comment1">(* Seems to be fixed in Isabelle-2016
  (* Some ad-hoc fix for locale abbreviations not being properly printed *)
  abbreviation (output) "abbrev_gen_dfs ≡ gen_dfs"
  abbreviation (output) "abbrev__gen_cond ≡ gen_cond"
  abbreviation (output) "abbrev__gen_step ≡ gen_step"

  abbreviation (output) "abbrev__ac_gen_dfs ≡ a.c.gen_dfs"
  abbreviation (output) "abbrev__ac_gen_cond ≡ a.c.gen_cond"
  abbreviation (output) "abbrev__ac_gen_step ≡ a.c.gen_step"

  abbreviation "abbrev_do_new_root ≡ do_new_root"
  abbreviation "abbrev_do_cross_edge ≡ do_cross_edge"
  abbreviation "abbrev_do_back_edge ≡ do_back_edge"
  abbreviation "abbrev_do_discover ≡ do_discover"
  abbreviation "abbrev_do_finish ≡ do_finish"

  abbreviation "abbrev_ac_do_new_root ≡ a.c.do_new_root"
  abbreviation "abbrev_ac_do_cross_edge ≡ a.c.do_cross_edge"
  abbreviation "abbrev_ac_do_back_edge ≡ a.c.do_back_edge"
  abbreviation "abbrev_ac_do_discover ≡ a.c.do_discover"
  abbreviation "abbrev_ac_do_finish ≡ a.c.do_finish"
  *)</span>


  <span class="keyword1"><span class="command">sublocale</span></span> tailrec_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">gds</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> restricted_impl <span class="main">=</span> 
  fb_graph <span class="main">+</span>
  a<span class="main">:</span> simple_impl <span class="quoted"><span class="quoted">"graph_restrict <span class="free">G</span> <span class="free">R</span>"</span></span> <span class="main">+</span>
  restricted_impl_defs <span class="main">+</span>
  
  <span class="comment1">(* Cross and back edges must not cause any effect. 
    Intuitively, we will see spurious cross edges to nodes from R.
    TODO/FIXME: The condition here is a quite crude over-approximation!
    *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"on_cross_edge <span class="free">parami</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"on_back_edge <span class="free">parami</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="comment1">(* TODO/FIXME: The next 4 are crude approximations. One should include
    some precondition! *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> is_break_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>restr_rel <span class="free">R</span> <span class="main">⟧</span> 
      <span class="main">⟹</span> is_break <span class="free">parami</span> <span class="free">s</span> <span class="main">⟷</span> is_break <span class="free">parami</span> <span class="free">s'</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_new_root_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>restr_rel <span class="free">R</span> <span class="main">⟧</span> 
      <span class="main">⟹</span> on_new_root <span class="free">parami</span> <span class="free">v0</span> <span class="free">s</span> <span class="main">≤</span> on_new_root <span class="free">parami</span> <span class="free">v0</span> <span class="free">s'</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_finish_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>restr_rel <span class="free">R</span> <span class="main">⟧</span> 
      <span class="main">⟹</span> on_finish <span class="free">parami</span> <span class="free">u</span> <span class="free">s</span> <span class="main">≤</span> on_finish <span class="free">parami</span> <span class="free">u</span> <span class="free">s'</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> on_discover_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>restr_rel <span class="free">R</span> <span class="main">⟧</span> 
      <span class="main">⟹</span> on_discover <span class="free">parami</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> on_discover <span class="free">parami</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s'</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> rel_def <span class="main">=</span> restr_rel_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">R</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">sublocale</span></span> gen_param_dfs <span class="quoted">gbs'</span> <span class="quoted"><span class="free">parami</span></span> <span class="quoted">simple_state.more_update</span> <span class="quoted">V0</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="Restr_Impl-is_break_param'"><span class="command">lemma</span></span> is_break_param'<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>is_break <span class="free">parami</span><span class="main">,</span> is_break <span class="free">parami</span><span class="main">)</span><span class="main">∈</span>rel <span class="main">→</span> bool_rel"</span></span>
    <span class="keyword1"><span class="command">using</span></span> is_break_refine <span class="keyword1"><span class="command">unfolding</span></span> rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Restr_Impl-do_init_refine"><span class="command">lemma</span></span> do_init_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"do_init <span class="main">≤</span> <span class="main">⇓</span> rel <span class="main">(</span>a.c.do_init<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> do_action_defs a.c.do_action_defs
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_def a.c.init_impl_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Restr_Impl-gen_cond_param"><span class="command">lemma</span></span> gen_cond_param<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gen_cond<span class="main">,</span>a.c.gen_cond<span class="main">)</span><span class="main">∈</span>rel <span class="main">→</span> bool_rel"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> is_break_param'<span class="main"><span class="main">[</span></span><span class="operator">param_fo</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_cond_def a.c.gen_cond_def rel_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">unfolding</span></span> a.c.is_discovered_impl_def a.c.is_empty_stack_impl_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1" id="Restr_Impl-cross_back_id"><span class="command">lemma</span></span> cross_back_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"do_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">=</span> RETURN <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"do_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">=</span> RETURN <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"a.c.do_cross_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">=</span> RETURN <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"a.c.do_back_edge <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">=</span> RETURN <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> do_action_defs a.c.do_action_defs
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

  <span class="keyword1" id="Restr_Impl-pred_rel_simps"><span class="command">lemma</span></span> pred_rel_simps<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>rel"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"a.c.is_discovered_impl <span class="free">u</span> <span class="free">s</span> <span class="main">⟷</span> a.c.is_discovered_impl <span class="free">u</span> <span class="free">s'</span> <span class="main">∨</span> <span class="free">u</span><span class="main">∈</span><span class="free">R</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"a.c.is_empty_stack_impl <span class="free">s</span> <span class="main">⟷</span> a.c.is_empty_stack_impl <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> a.c.is_discovered_impl_def a.c.is_empty_stack_impl_def 
    <span class="keyword1"><span class="command">unfolding</span></span> rel_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Restr_Impl-no_pending_refine"><span class="command">lemma</span></span> no_pending_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>a.c.is_empty_stack_impl <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>ss_stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> hd <span class="main">(</span>ss_stack <span class="free">s'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> a.c.is_empty_stack_impl_def rel_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ss_stack <span class="free">s'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> list_relE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Restr_Impl-do_new_root_refine"><span class="command">lemma</span></span> do_new_root_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">v0i</span><span class="main">,</span><span class="free">v0</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>rel<span class="main">;</span> <span class="free">v0</span><span class="main">∉</span><span class="free">R</span> <span class="main">⟧</span> 
      <span class="main">⟹</span> do_new_root <span class="free">v0i</span> <span class="free">si</span> <span class="main">≤</span> <span class="main">⇓</span> rel <span class="main">(</span>a.c.do_new_root <span class="free">v0</span> <span class="free">s</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> do_action_defs a.c.do_action_defs
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">rel</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a.c.new_root_impl_def new_root_impl_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_def rel_restrict_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">Id</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> on_new_root_refine<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Restr_Impl-do_finish_refine"><span class="command">lemma</span></span> do_finish_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> rel<span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">u'</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">⟧</span>
       <span class="main">⟹</span> do_finish <span class="free">u</span> <span class="free">s</span> <span class="main">≤</span> <span class="main">⇓</span> rel <span class="main">(</span>a.c.do_finish <span class="free">u'</span> <span class="free">s'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> do_action_defs a.c.do_action_defs
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">rel</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish_impl_def is_empty_stack_impl_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_def rel_restrict_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">Id</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> on_finish_refine<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Restr_Impl-aux_cnv_pending"><span class="command">lemma</span></span> aux_cnv_pending<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> rel<span class="main">;</span> 
      <span class="main">¬</span> is_empty_stack_impl <span class="free">s</span><span class="main">;</span> <span class="free">vs</span><span class="main">∈</span><span class="free">Vs</span><span class="main">;</span> <span class="free">vs</span><span class="main">∉</span><span class="free">R</span><span class="main">;</span>
      hd <span class="main">(</span>ss_stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">Vs</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span>
      hd <span class="main">(</span>ss_stack <span class="free">s'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span>insert <span class="free">vs</span> <span class="main">(</span><span class="free">Vs</span><span class="main">-</span><span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="comment1">(* Conc-Pending node that is also in abs-visited is also abs-pending *)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> rel_def is_empty_stack_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ss_stack <span class="free">s'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> list_relE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    

  <span class="keyword1" id="Restr_Impl-get_pending_refine"><span class="command">lemma</span></span> get_pending_refine<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> rel"</span></span> <span class="quoted"><span class="quoted">"gen_cond <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_empty_stack_impl <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
      get_pending_impl <span class="free">s</span> <span class="main">≤</span> <span class="main">(</span>sup 
        <span class="main">(</span><span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span>Id<span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> rel<span class="main">)</span> <span class="main">(</span>inf 
          <span class="main">(</span>get_pending_impl <span class="free">s'</span><span class="main">)</span> 
          <span class="main">(</span>SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">Vs</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span><span class="main">∉</span><span class="free">R</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span>Id<span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> rel<span class="main">)</span> <span class="main">(</span>
          SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Vs</span><span class="main">,</span><span class="bound">s''</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="bound">Vs</span><span class="main">=</span>Some <span class="bound">v</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span><span class="free">R</span> <span class="main">∧</span> <span class="bound">s''</span><span class="main">=</span><span class="free">s'</span><span class="main">)</span> 
        <span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ss_stack <span class="free">s'</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ss_stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rel_def impl_defs 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> get_pending_impl_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Let_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ASSERT_leI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> impl_defs gen_cond_def rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">split</span> prod.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> allI impI<span class="main">)</span>      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lhs_step_If<span class="main">)</span>
        <span class="comment1">(* No pending *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_supI1<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pred_rel_simps no_pending_refine restr_rel_simps
          RETURN_RES_refine_iff<span class="main">)</span>
  
        <span class="comment1">(* Pending *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lhs_step_bind<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> v<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">v</span><span class="main">∈</span><span class="free">R</span>"</span></span><span class="main">)</span>
          <span class="comment1">(* Spurious node from R *)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_supI2<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> RETURN_SPEC_refine<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_def is_empty_stack_impl_def neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ss_stack <span class="free">s'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> list_relE<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
          <span class="comment1">(* Non-spurious node *)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_supI1<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> aux_cnv_pending<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_pending_refine pred_rel_simps memb_imp_not_empty<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> nofail_inf_serialize<span class="main"><span class="keyword3">,</span></span> 
            <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rhs_step_bind_RES<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_def is_empty_stack_impl_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ss_stack <span class="free">s'</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> list_relE<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Restr_Impl-do_discover_refine"><span class="command">lemma</span></span> do_discover_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> rel<span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">u'</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="free">v'</span> <span class="main">∉</span> <span class="free">R</span> <span class="main">⟧</span>
       <span class="main">⟹</span> do_discover <span class="free">u</span> <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> <span class="main">⇓</span> rel <span class="main">(</span>a.c.do_discover <span class="free">u'</span> <span class="free">v'</span> <span class="free">s'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> do_action_defs a.c.do_action_defs
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">rel</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discover_impl_def a.c.discover_impl_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_def rel_restrict_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">Id</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> on_discover_refine<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Restr_Impl-aux_R_node_discovered"><span class="command">lemma</span></span> aux_R_node_discovered<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>rel<span class="main">;</span> <span class="free">v</span><span class="main">∈</span><span class="free">R</span><span class="main">⟧</span> <span class="main">⟹</span> is_discovered_impl <span class="free">v</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pred_rel_simps<span class="main">)</span>

  <span class="keyword1" id="Restr_Impl-re_refine_aux"><span class="command">lemma</span></span> re_refine_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs <span class="main">≤</span> <span class="main">⇓</span>rel a.c.gen_dfs"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> a.c.gen_dfs_def gen_dfs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps<span class="main">)</span>
    <span class="comment1">(* Some manual refinements for finer control *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_refine<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> WHILE_invisible_refine<span class="main">)</span>

    <span class="comment1">(* Condition *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> gen_cond_param<span class="main"><span class="main">[</span></span><span class="operator">param_fo</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main">)</span>

    <span class="comment1">(* Step *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> gen_cond_param<span class="main"><span class="main">[</span></span><span class="operator">param_fo</span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> IdD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gen_step_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong option.case_cong <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lhs_step_If<span class="main">)</span>
      <span class="comment1">(* new_root *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> pred_rel_simps<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_supI1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a.c.gen_step_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pred_rel_simps<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="comment1">(* pending edges *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> pred_rel_simps<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Not_eq_iff<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">symmetric</span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator"><span class="operator">THEN</span></span> iffD1<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD1<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">thm</span></span> order_trans<span class="main">[</span><span class="operator">OF</span> bind_mono<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_refine order_refl<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bind_mono<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> get_pending_refine order_refl<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> bind_distrib_sup1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sup_least<span class="main">)</span>
        <span class="comment1">(* Non-spurious node *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_supI1<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a.c.gen_step_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong if_cong<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bind_refine'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> conc_fun_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> monoD<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pred_rel_simps<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="comment1">(* Spurious node *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_supI2<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> RETURN_as_SPEC_refine<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conc_fun_SPEC<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> bind_refine'<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> aux_R_node_discovered<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>        

  <span class="keyword1"><span class="command">theorem</span></span> re_refine_aux2<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>rel <span class="keyword1">O</span> <span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>simple_state_rel<span class="main">)</span> a.a.it_dfs"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> re_refine_aux 
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> a.gen_dfs_refine
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conc_fun_chain <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> graph_restrict_simps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> re_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_dfs <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>restr_simple_state_rel <span class="free">R</span><span class="main">)</span> a.a.it_dfs"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> restr_simple_state_rel_combine
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> re_refine_aux2<span class="main">)</span>


  <span class="comment1">(* Link to tailrec_impl *)</span>
  <span class="keyword1"><span class="command">sublocale</span></span> tailrec_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">gds</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> do_action_defs impl_defs<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Restr_Impl-tailrec_refine"><span class="command">lemma</span></span> tailrec_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"tailrec_impl <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">ES</span><span class="main">⟩</span>restr_simple_state_rel <span class="free">R</span><span class="main">)</span> a.a.it_dfs"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> tailrec_impl <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> re_refine <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">(* TODO: Link to rec_impl *)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="DFS_Framework">
<div class="head">
<h1>Theory DFS_Framework</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Basic DFS Framework›</span></span>
<span class="keyword1"><span class="command">theory</span></span> DFS_Framework
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Param_DFS.html">Param_DFS</a>
  <span class="quoted">"<a href="DFS_Invars_Basic.html">Invars/DFS_Invars_Basic</a>"</span>
  <span class="quoted">"<a href="Tailrec_Impl.html">Impl/Structural/Tailrec_Impl</a>"</span>
  <span class="quoted">"<a href="Rec_Impl.html">Impl/Structural/Rec_Impl</a>"</span>
  <span class="quoted">"<a href="Simple_Impl.html">Impl/Data/Simple_Impl</a>"</span>  
  <span class="quoted">"<a href="Restr_Impl.html">Impl/Data/Restr_Impl</a>"</span>  
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Entry point for the DFS framework, with basic invariants,
    tail-recursive and recursive implementation, and basic state data 
    structures.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DFS_Chapter_Examples">
<div class="head">
<h1>Theory DFS_Chapter_Examples</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">"Examples"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This chapter contains examples of using the DFS Framework.
  Most examples are re-usable algorithms, that can easily be integrated into
  other (refinement framework based) developments.

  The cyclicity checker example contains a detailed description of how to 
  use the DFS framework, and can be used as a guideline for own 
  DFS-framework based developments.
›</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> DFS_Chapter_Examples
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Cyc_Check">
<div class="head">
<h1>Theory Cyc_Check</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Simple Cyclicity Checker›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Cyc_Check
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="DFS_Framework.html">../DFS_Framework</a>"</span>
  <a href="../CAVA_Automata/Digraph_Impl.html">CAVA_Automata.Digraph_Impl</a>
  <span class="quoted">"<a href="Impl_Rev_Array_Stack.html">../Misc/Impl_Rev_Array_Stack</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This example presents a simple cyclicity checker: 
    Given a directed graph with start nodes, decide whether it's reachable 
    part is cyclic.

  The example tries to be a tutorial on using the DFS framework, 
  explaining every required step in detail.

  We define two versions of the algorithm, a partial correct one assuming 
  only a finitely branching graph, and a total correct one assuming finitely 
  many reachable nodes.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Framework Instantiation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Define a state, based on the DFS-state. 
  In our case, we just add a break-flag.
›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> cycc_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> state"</span></span> <span class="main">+</span>
  break <span class="main">::</span> <span class="quoted">bool</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some utility lemmas for the simplifier, to handle idiosyncrasies of
  the record package. ›</span></span>
<span class="keyword1" id="Cyc_Check-break_more_cong"><span class="command">lemma</span></span> break_more_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> break <span class="free">s</span> <span class="main">=</span> break <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⦇</span> state.more <span class="main">:=</span> <span class="main">⦇</span> break <span class="main">=</span> <span class="free">foo</span> <span class="main">⦈</span> <span class="main">⦈</span> <span class="main">=</span> <span class="free">s</span> <span class="main">⦇</span> break <span class="main">:=</span> <span class="free">foo</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Define the parameterization. We start at a default parameterization, where
  all operations default to skip, and just add the operations we are 
  interested in: Initially, the break flag is false, it is set if we 
  encounter a back-edge, and once set, the algorithm shall terminate immediately. ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cycc_params</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit cycc_state_ext<span class="main">)</span> parameterization"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cycc_params</span> <span class="main">≡</span> dflt_parametrization state.more 
  <span class="main">(</span>RETURN <span class="main">⦇</span> break <span class="main">=</span> False <span class="main">⦈</span><span class="main">)</span> <span class="main">⦇</span>
  on_back_edge <span class="main">:=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> RETURN <span class="main">⦇</span> break <span class="main">=</span> True <span class="main">⦈</span><span class="main">,</span>
  is_break <span class="main">:=</span> break <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> cycc_params_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
  gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> cycc_params_def<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator">simplified</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> cycc<span class="main">:</span> param_DFS_defs <span class="keyword2"><span class="keyword">where</span></span> param<span class="main">=</span><span class="quoted">cycc_params</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now can define our cyclicity checker. 
  The partially correct version asserts a finitely branching graph:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checker</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> cycc.it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>break <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The total correct variant asserts finitely many reachable nodes.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checkerT</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> finite <span class="main">(</span>graph_defs.reachable <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> cycc.it_dfsT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>break <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, we define a locale for the cyclicity checker's
  precondition and invariant, by specializing the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>param_DFS›</span></span></span></span> locale.›</span></span>
<span class="keyword1"><span class="command">locale</span></span> cycc <span class="main">=</span> param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">cycc_params</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can easily show that our parametrization does not fail, thus we also
    get the DFS-locale, which gives us the correctness theorem for
    the DFS-scheme ›</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">cycc_params</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cycc_params_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">thm</span></span> it_dfs_correct  <span class="comment1">― ‹Partial correctness›</span>
  <span class="keyword1"><span class="command">thm</span></span> it_dfsT_correct <span class="comment1">― ‹Total correctness if set of reachable states is finite›</span> 
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Cyc_Check-cyccI"><span class="command">lemma</span></span> cyccI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cycc <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Cyc_Check-cyccI'"><span class="command">lemma</span></span> cyccI'<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> FR<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>graph_defs.reachable <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cycc <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">from</span></span> FR <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fb_graphI_fr<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we specialize the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">DFS_invar</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> locale to our parameterization.
  This locale contains all proven invariants. When proving new invariants,
  this locale is available as assumption, thus allowing us to re-use already 
  proven invariants.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> cycc_invar <span class="main">=</span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted">cycc_params</span> <span class="main">+</span> cycc

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ The lemmas to establish invariants only provide the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>DFS_invar›</span></span></span></span> locale.
  This lemma is used to convert it into the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cycc_invar›</span></span></span></span> locale.
›</span></span>
<span class="keyword1" id="Cyc_Check-cycc_invar_eq"><span class="command">lemma</span></span> cycc_invar_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> cycc_params <span class="free">s</span> <span class="main">⟷</span> cycc_invar <span class="free">G</span> <span class="free">s</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> cycc_params <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted">cycc_params</span> <span class="quoted"><span class="free">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cycc_invar <span class="free">G</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"cycc_invar <span class="free">G</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> cycc_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">s</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> cycc_params <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ We now enter the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cycc_invar›</span></span></span></span> locale, and show correctness of 
  our cyclicity checker.
›</span></span>
<span class="keyword1"><span class="command">context</span></span> cycc_invar <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that we break if and only if there are back edges. 
    This is straightforward from our parameterization, and we can use the 
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] establish_invarI<span class="antiquote"><span class="antiquote">}</span></span></span></span> rule provided by the DFS framework.

    We use this example to illustrate the general proof scheme:
    ›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> cycc<span class="main">)</span> i_brk_eq_back<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> break <span class="bound">s</span> <span class="main">⟷</span> back_edges <span class="bound">s</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> establish_invarI<span class="antiquote"><span class="antiquote">}</span></span></span></span> rule is used with the induction method, and 
    yields cases›</span></span>
  <span class="keyword1"><span class="command">print_cases</span></span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Our parameterization has only hooked into initialization and back-edges,
      so only these two cases are non-trivial›</span></span>
    <span class="keyword3"><span class="command">case</span></span> init <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_state_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹For proving invariant preservation, we may assume that the invariant 
      holds on the previous state. Interpreting the invariant locale makes 
      available all invariants ever proved into this locale (i.e., the invariants 
      from all loaded libraries, and the ones you proved yourself.).
      ›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> cycc_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹However, here we do not need them:›</span></span>
    <span class="keyword1"><span class="command">from</span></span> back_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> break_more_cong<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For technical reasons, invariants are proved in the basic locale, 
    and then transferred to the invariant locale:›</span></span>  
  <span class="keyword1"><span class="command">lemmas</span></span> brk_eq_back <span class="main">=</span> i_brk_eq_back<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The above lemma is simple enough to have a short apply-style proof:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> cycc<span class="main">)</span> i_brk_eq_back_short_proof<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> break <span class="bound">s</span> <span class="main">⟷</span> back_edges <span class="bound">s</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> break_more_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_state_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now, when we know that the break flag indicates back-edges,
    we can easily prove correctness, using a lemma from the invariant 
    library:›</span></span>
  <span class="keyword1"><span class="command">thm</span></span> cycle_iff_back_edges
  <span class="keyword1" id="Cyc_Check-cycc_correct_aux"><span class="command">lemma</span></span> cycc_correct_aux<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"break <span class="free">s</span> <span class="main">⟷</span> <span class="main">¬</span>acyclic <span class="main">(</span>E <span class="main">∩</span> reachable <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"break <span class="free">s</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"break <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> brk_eq_back <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> cycle_iff_back_edges <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>acyclic <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> acyclic_subset<span class="main">[</span><span class="operator">OF</span> _ edges_ss_reachable_edges<span class="main">]</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>acyclic <span class="main">(</span>E <span class="main">∩</span> reachable <span class="main">×</span> UNIV<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>break <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A brk_eq_back <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"back_edges <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> cycle_iff_back_edges <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> A nc_edges_covered<span class="main">[</span><span class="operator">OF</span> NC<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">s</span> <span class="main">=</span> E <span class="main">∩</span> reachable <span class="main">×</span> UNIV"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="main">(</span>E <span class="main">∩</span> reachable <span class="main">×</span> UNIV<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Again, we have a short two-line proof:›</span></span>
  <span class="keyword1" id="Cyc_Check-cycc_correct_aux_short_proof"><span class="command">lemma</span></span> cycc_correct_aux_short_proof<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"break <span class="free">s</span> <span class="main">⟷</span> <span class="main">¬</span>acyclic <span class="main">(</span>E <span class="main">∩</span> reachable <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nc_edges_covered<span class="main">[</span><span class="operator">OF</span> NC<span class="main">]</span> brk_eq_back cycle_iff_back_edges 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> acyclic_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ edges_ss_reachable_edges<span class="main"><span class="main">]</span></span><span class="main">)</span>

    
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we define a specification for cyclicity checking,
  and prove that our cyclicity checker satisfies the specification: ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checker_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">⟷</span> <span class="main">¬</span>acyclic <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∩</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> cyc_checker_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"cyc_checker <span class="free">G</span> <span class="main">≤</span> cyc_checker_spec <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checker_def cyc_checker_spec_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">refine_vcg</span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> DFS.it_dfs_correct<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp_all</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> cycc <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS <span class="free">G</span> cycc_params"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"cycc_invar <span class="free">G</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> cycc_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cycc.cond <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"break <span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> acyclic <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> cycc.reachable <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cycc_correct_aux<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The same for the total correct variant:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checkerT_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> finite <span class="main">(</span>graph_defs.reachable <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">⟷</span> <span class="main">¬</span>acyclic <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∩</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> cyc_checkerT_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"cyc_checkerT <span class="free">G</span> <span class="main">≤</span> cyc_checkerT_spec <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checkerT_def cyc_checkerT_spec_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">refine_vcg</span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> DFS.it_dfsT_correct<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp_all</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>graph_defs.reachable <span class="free">G</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fb_graphI_fr<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> cycc <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS <span class="free">G</span> cycc_params"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"cycc_invar <span class="free">G</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> cycc_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cycc.cond <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"break <span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> acyclic <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> cycc.reachable <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cycc_correct_aux<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The implementation has two aspects: Structural implementation and data implementation.
  The framework provides recursive and tail-recursive implementations, as well as a variety
  of data structures for the state.

  We will choose the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>simple_state›</span></span></span></span> implementation, which provides 
  a stack, an on-stack and a visited set, but no timing information.

  Note that it is common for state implementations to omit details from the
  very detailed abstract state. This means, that the algorithm's operations 
  must not access these details (e.g. timing). However, the algorithm's 
  correctness proofs may still use them.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We extend the state template to add a break flag›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> cycc_state_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> simple_state"</span></span> <span class="main">+</span>
  break <span class="main">::</span> <span class="quoted">bool</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition of refinement relation: The break-flag is refined by identity.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cycc_erel</span> <span class="main">≡</span> <span class="main">{</span> 
  <span class="main">(</span><span class="main">⦇</span> cycc_state_impl.break <span class="main">=</span> <span class="bound">b</span> <span class="main">⦈</span><span class="main">,</span> <span class="main">⦇</span> cycc_state.break <span class="main">=</span> <span class="bound">b</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">b</span><span class="main">.</span> True <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">cycc_rel</span> <span class="main">≡</span> <span class="main">⟨</span>cycc_erel<span class="main">⟩</span>simple_state_rel"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Implementation of the parameters›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cycc_params_impl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'v</span> cycc_state_impl<span class="main">,</span>unit cycc_state_impl_ext<span class="main">)</span> gen_parameterization"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cycc_params_impl</span> 
  <span class="main">≡</span> dflt_parametrization simple_state.more <span class="main">(</span>RETURN <span class="main">⦇</span> break <span class="main">=</span> False <span class="main">⦈</span><span class="main">)</span> <span class="main">⦇</span>
  on_back_edge <span class="main">:=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">⦇</span> break <span class="main">=</span> True <span class="main">⦈</span><span class="main">,</span>
  is_break <span class="main">:=</span> break <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> cycc_params_impl_simp<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> 
  gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> cycc_params_impl_def<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator">simplified</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note: In this simple case, the reformulation of the extension state and 
  parameterization is just redundant, However, in general the refinement will 
  also affect the parameterization.›</span></span>

<span class="keyword1" id="Cyc_Check-break_impl"><span class="command">lemma</span></span> break_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>cycc_rel 
  <span class="main">⟹</span> cycc_state_impl.break <span class="free">si</span> <span class="main">=</span> cycc_state.break <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_state_rel_def cycc_erel_def<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> cycc_impl<span class="main">:</span> simple_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">cycc_params_impl</span> <span class="quoted">cycc_params</span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The above interpretation creates an iterative and a recursive implementation ›</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">cycc_impl.tailrec_impl</span> <span class="keyword1"><span class="command">term</span></span> <span class="quoted">cycc_impl.rec_impl</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">cycc_impl.tailrec_implT</span> <span class="comment1">― ‹Note, for total correctness we currently only support tail-recursive implementations.›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We use both to derive a tail-recursive and a recursive cyclicity checker:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checker_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> cycc_impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>break <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checker_rec_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> cycc_impl.rec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>break <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cyc_checker_implT</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> finite <span class="main">(</span>graph_defs.reachable <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> cycc_impl.tailrec_implT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>break <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To show correctness of the implementation, we integrate the
  locale of the simple implementation into our cyclicity checker's locale:›</span></span>
<span class="keyword1"><span class="command">context</span></span> cycc <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> simple_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">cycc_params</span> <span class="quoted">cycc_params_impl</span> <span class="quoted">cycc_erel</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_state_rel_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cycc_erel_def break_impl simple_state_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We get that our implementation refines the abstrct DFS algorithm.›</span></span>  
  <span class="keyword1"><span class="command">lemmas</span></span> impl_refine <span class="main">=</span> simple_tailrec_refine simple_rec_refine simple_tailrecT_refine

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Unfortunately, the combination of locales and abbreviations gets to its 
    limits here, so we state the above lemma a bit more readable:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> 
    <span class="quoted"><span class="quoted">"cycc_impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'more</span><span class="main">)</span> <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span> cycc_rel it_dfs"</span></span>
    <span class="quoted"><span class="quoted">"cycc_impl.rec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'more</span><span class="main">)</span> <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span> cycc_rel it_dfs"</span></span>
    <span class="quoted"><span class="quoted">"cycc_impl.tailrec_implT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'more</span><span class="main">)</span> <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span> cycc_rel it_dfsT"</span></span>
    <span class="keyword1"><span class="command">using</span></span> impl_refine <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we get correctness of our cyclicity checker implementations›</span></span>
<span class="keyword1" id="Cyc_Check-cyc_checker_impl_refine"><span class="command">lemma</span></span> cyc_checker_impl_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"cyc_checker_impl <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>cyc_checker <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checker_impl_def cyc_checker_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> cycc.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> break_impl cyccI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1" id="Cyc_Check-cyc_checker_rec_impl_refine"><span class="command">lemma</span></span> cyc_checker_rec_impl_refine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"cyc_checker_rec_impl <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>cyc_checker <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checker_rec_impl_def cyc_checker_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> cycc.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> break_impl cyccI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Cyc_Check-cyc_checker_implT_refine"><span class="command">lemma</span></span> cyc_checker_implT_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"cyc_checker_implT <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>cyc_checkerT <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checker_implT_def cyc_checkerT_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> cycc.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> break_impl cyccI'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Synthesizing Executable Code›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Our algorithm's implementation is still abstract, as it uses abstract data 
  structures like sets and relations. In a last step, we use the Autoref tool
  to derive an implementation with efficient data structures.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Again, we derive our state implementation from the template provided by 
  the framework. The break-flag is implemented by a Boolean flag. 
  Note that, in general, the user-defined state extensions may be data-refined
  in this step.›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">,</span><span class="tfree">'psi</span><span class="main">)</span>cycc_state_impl' <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_impl"</span></span> <span class="main">+</span>
  break_impl <span class="main">::</span> <span class="quoted">bool</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the refinement relation for the state extension›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cycc_state_erel</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="main">⦇</span>break_impl <span class="main">=</span> <span class="bound">bi</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span>  <span class="bound">mi</span><span class="main">⦈</span><span class="main">,</span><span class="main">⦇</span>break <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">m</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">bi</span> <span class="bound">mi</span> <span class="bound">b</span> <span class="bound">m</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">bi</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">∈</span>bool_rel <span class="main">∧</span> <span class="main">(</span><span class="bound">mi</span><span class="main">,</span><span class="bound">m</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">erel</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹And register it with the Autoref tool:›</span></span>
<span class="keyword1"><span class="command">consts</span></span> 
  i_cycc_state_ext <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">cycc_state_erel</span> <span class="quoted">i_cycc_state_ext</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that the record operations on our extended state are parametric,
  and declare these facts to Autoref: ›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ns_rel</span> <span class="free">vis_rel</span> <span class="free">erel</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">ns_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="main">⟨</span><span class="free">erel</span><span class="main">⟩</span>cycc_state_erel<span class="main">⟩</span>ss_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>cycc_state_impl'_ext<span class="main">,</span> cycc_state_impl_ext<span class="main">)</span> <span class="main">∈</span> bool_rel <span class="main">→</span> <span class="free">erel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">erel</span><span class="main">⟩</span>cycc_state_erel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>break_impl<span class="main">,</span> cycc_state_impl.break<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cycc_state_erel_def ss_impl_rel_def R_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we can synthesize an implementation for our cyclicity checker,
  using the standard Autoref-approach:›</span></span>
<span class="keyword1"><span class="command">schematic_goal</span></span> cyc_checker_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>hashable<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> dres<span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>cyc_checker_impl <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">cyc_checker_code</span> <span class="keyword2"><span class="keyword">uses</span></span> cyc_checker_impl
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">cyc_checker_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Combining the refinement steps yields a correctness 
  theorem for the cyclicity checker implementation:›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> cyc_checker_code_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"cyc_checker_code <span class="free">Gi</span> <span class="main">=</span> dRETURN <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span>acyclic <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> cyc_checker_code.refine<span class="main">[</span><span class="operator">OF</span> 2<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cyc_checker_impl_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cyc_checker_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 4
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checker_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can repeat the same boilerplate for the recursive version of the algorithm:›</span></span>
<span class="keyword1"><span class="command">schematic_goal</span></span> cyc_checker_rec_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>hashable<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> dres<span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>cyc_checker_rec_impl <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">cyc_checker_rec_code</span> <span class="keyword2"><span class="keyword">uses</span></span> cyc_checker_rec_impl
<span class="keyword1"><span class="command">prepare_code_thms</span></span> cyc_checker_rec_code_def
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">cyc_checker_rec_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="Cyc_Check-cyc_checker_rec_code_correct"><span class="command">lemma</span></span> cyc_checker_rec_code_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"cyc_checker_rec_code <span class="free">Gi</span> <span class="main">=</span> dRETURN <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span>acyclic <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> cyc_checker_rec_code.refine<span class="main">[</span><span class="operator">OF</span> 2<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cyc_checker_rec_impl_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cyc_checker_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 4 
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checker_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹And, again, for the total correct version. 
  Note that we generate a plain implementation, not inside a monad:›</span></span>
<span class="keyword1"><span class="command">schematic_goal</span></span> cyc_checker_implT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>hashable<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>cyc_checker_implT <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">cyc_checker_codeT</span> <span class="keyword2"><span class="keyword">uses</span></span> cyc_checker_implT
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">cyc_checker_codeT</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">theorem</span></span> cyc_checker_codeT_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>graph_defs.reachable <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cyc_checker_codeT <span class="free">Gi</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span>acyclic <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> cyc_checker_codeT.refine<span class="main">[</span><span class="operator">OF</span> 2<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cyc_checker_implT_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cyc_checkerT_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1
  <span class="keyword1"><span class="command">unfolding</span></span> cyc_checkerT_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="DFS_Find_Path">
<div class="head">
<h1>Theory DFS_Find_Path</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Finding a Path between Nodes›</span></span>
<span class="keyword1"><span class="command">theory</span></span> DFS_Find_Path
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="DFS_Framework.html">../DFS_Framework</a>"</span>
  <a href="../CAVA_Automata/Digraph_Impl.html">CAVA_Automata.Digraph_Impl</a>
  <span class="quoted">"<a href="Impl_Rev_Array_Stack.html">../Misc/Impl_Rev_Array_Stack</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We instantiate the DFS framework to find a path to some reachable node 
  that satisfies a given predicate. We present four variants of the algorithm:
  Finding any path, and finding path of at least length one, combined with
  searching the whole graph, and searching the graph restricted to a given set 
  of nodes. The restricted variants are efficiently implemented by 
  pre-initializing the visited set (cf. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Restr_Impl.html"></a><a href="Restr_Impl.html">DFS_Framework.Restr_Impl</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>).

  The restricted variants can be used for incremental search, ignoring already 
  searched nodes in further searches. This is required, e.g., for the inner 
  search of nested DFS (Buchi automaton emptiness check).
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Including empty Path›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> fp0_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> state"</span></span> <span class="main">+</span>
  ppath <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> option"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> fp0_param <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> fp0_state_ext<span class="main">)</span> parameterization"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⦇</span> state.more <span class="main">:=</span> <span class="main">⦇</span> ppath <span class="main">=</span> <span class="free">foo</span> <span class="main">⦈</span> <span class="main">⦈</span> <span class="main">=</span> <span class="free">s</span> <span class="main">⦇</span> ppath <span class="main">:=</span> <span class="free">foo</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">no_path</span> <span class="main">≡</span> <span class="main">⦇</span> ppath <span class="main">=</span> None <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">a_path</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">⦇</span> ppath <span class="main">=</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fp0_params</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> fp0_param"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fp0_params</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
  on_init <span class="main">=</span> RETURN no_path<span class="main">,</span>
  on_new_root <span class="main">=</span> <span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v0</span> <span class="keyword1">then</span> RETURN <span class="main">(</span>a_path <span class="main">[]</span> <span class="bound">v0</span><span class="main">)</span> <span class="keyword1">else</span> RETURN no_path<span class="main">,</span>
  on_discover <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> 
                   <span class="keyword1">then</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>v›</span></span> is already on the stack, so we need to pop it again›</span>
                      RETURN <span class="main">(</span>a_path <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">v</span><span class="main">)</span> 
                   <span class="keyword1">else</span> RETURN no_path<span class="main">,</span>
  on_finish <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
  on_back_edge <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
  on_cross_edge <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
  is_break <span class="main">=</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ppath <span class="bound">s</span> <span class="main">≠</span> None <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> fp0_params_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> 
  <span class="main">=</span> gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> fp0_params_def<span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> fp0<span class="main">:</span> param_DFS_defs <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="free">P</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">locale</span></span> fp0 <span class="main">=</span> param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"ppath <span class="main">(</span>empty_state <span class="main">⦇</span>ppath <span class="main">=</span> <span class="free">e</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_state_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"ppath <span class="main">(</span><span class="free">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> state.more <span class="free">s'</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> ppath <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">sublocale</span></span> DFS <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="DFS_Find_Path-fp0I"><span class="command">lemma</span></span> fp0I<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fp0 <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">locale</span></span> fp0_invar <span class="main">=</span> fp0 <span class="main">+</span> 
  DFS_invar <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span>

<span class="keyword1" id="DFS_Find_Path-fp0_invar_eq"><span class="command">lemma</span></span> fp0_invar_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="main">(</span>fp0_params <span class="free">P</span><span class="main">)</span> <span class="main">=</span> fp0_invar <span class="free">G</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="main">(</span>fp0_params <span class="free">P</span><span class="main">)</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fp0_invar <span class="free">G</span> <span class="free">P</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fp0_invar <span class="free">G</span> <span class="free">P</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> fp0_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="main">(</span>fp0_params <span class="free">P</span><span class="main">)</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> fp0 <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="DFS_Find_Path-i_no_path_no_P_discovered"><span class="command">lemma</span></span> i_no_path_no_P_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ppath <span class="bound">s</span> <span class="main">=</span> None <span class="main">⟶</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">∩</span> Collect <span class="free">P</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> establish_invarI<span class="main">)</span> <span class="operator">simp_all</span>

  <span class="keyword1" id="DFS_Find_Path-i_path_to_P"><span class="command">lemma</span></span> i_path_to_P<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ppath <span class="bound">s</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">vs</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">P</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> establish_invarI<span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1" id="DFS_Find_Path-i_path_invar"><span class="command">lemma</span></span> i_path_invar<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ppath <span class="bound">s</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">vs</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">⟶</span> 
                   <span class="main">(</span><span class="free">vs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟶</span> hd <span class="free">vs</span> <span class="main">∈</span> V0 <span class="main">∧</span> path E <span class="main">(</span>hd <span class="free">vs</span><span class="main">)</span> <span class="free">vs</span> <span class="free">v</span><span class="main">)</span> 
                 <span class="main">∧</span> <span class="main">(</span><span class="free">vs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> <span class="free">v</span> <span class="main">∈</span> V0 <span class="main">∧</span> path E <span class="free">v</span> <span class="free">vs</span> <span class="free">v</span><span class="main">)</span>
                 <span class="main">∧</span> <span class="main">(</span>distinct <span class="main">(</span><span class="free">vs</span><span class="main">@</span><span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fp0_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword1"><span class="command">have</span></span> vnis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∉</span>set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> stack_discovered <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> pendingD discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> succ <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> hd_succ_stack_is_path<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> last_stack_in_V0 ne <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="main">(</span>rev <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>  <span class="main">(</span>rev <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>rev <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> V0"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hd_rev<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> path_hd<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"rev <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">]</span> ne
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> ne discover vnis <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stack_distinct<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> fp0_invar
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> no_path_no_P_discovered
    <span class="main">=</span> i_no_path_no_P_discovered<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> path_to_P
    <span class="main">=</span> i_path_to_P<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> path_invar
    <span class="main">=</span> i_path_invar<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

  <span class="keyword1" id="DFS_Find_Path-path_invar_nonempty"><span class="command">lemma</span></span> path_invar_nonempty<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ppath <span class="free">s</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">vs</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">vs</span> <span class="main">∈</span> V0"</span></span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="free">vs</span><span class="main">)</span> <span class="free">vs</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms path_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Find_Path-path_invar_empty"><span class="command">lemma</span></span> path_invar_empty<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ppath <span class="free">s</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">vs</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> V0"</span></span> <span class="quoted"><span class="quoted">"path E <span class="free">v</span> <span class="free">vs</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms path_invar
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="DFS_Find_Path-fp0_correct"><span class="command">lemma</span></span> fp0_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> ppath <span class="free">s</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="bound">v</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ppath <span class="free">s</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> assms nc_discovered_eq_reachable no_path_no_P_discovered <span class="keyword1"><span class="command">have</span></span>
      <span class="quoted"><span class="quoted">"reachable <span class="main">∩</span> Collect <span class="free">P</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> None<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">vvs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">vs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vvs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">vs</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vvs</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> Some path_invar<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">vs</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> path_to_P<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> fp0 <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="DFS_Find_Path-fp0_correct"><span class="command">lemma</span></span> fp0_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"it_dfs <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> ppath <span class="bound">s</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="bound">v</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> weaken_SPEC<span class="main"><span class="main">[</span></span><span class="operator">OF</span> it_dfs_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fp0_invar.fp0_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Interface›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use this interface, rather than the internal stuff above! ›</span></span>
<span class="comment1">(* Making it a well-defined interface. This interface should be used, not
  the internal stuff. If more information about the result is needed, this 
  interface should be extended! *)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> fp_result <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> option"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0_pred</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∩</span> Collect <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">{}</span>
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="bound">vs</span><span class="main">@</span><span class="main">[</span><span class="bound">v</span><span class="main">]</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v0</span> <span class="main">∈</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> path <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">v0</span> <span class="bound">vs</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path0_spec</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> fp_result nres"</span></span>
  <span class="comment1">― ‹Searches a path from the root nodes to some target node that satisfies a 
      given predicate. If such a path is found, the path and the target node
      are returned›</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">find_path0_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
    SPEC <span class="main">(</span>find_path0_pred <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path0</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> fp_result nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fp0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> fp0.it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'more</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>ppath <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="DFS_Find_Path-find_path0_correct"><span class="command">lemma</span></span> find_path0_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path0 <span class="free">G</span> <span class="free">P</span> <span class="main">≤</span> find_path0_spec <span class="free">G</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path0_def find_path0_spec_def find_path0_pred_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fp0.fp0_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> fp0I<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> find_path0_spec_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> 
  ASSERT_le_defI<span class="main">[</span><span class="operator">OF</span> find_path0_spec_def<span class="main">]</span>
  ASSERT_leof_defI<span class="main">[</span><span class="operator">OF</span> find_path0_spec_def<span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Restricting the Graph›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Extended interface, propagating set of already searched nodes (restriction) ›</span></span>
<span class="comment1">(* Invariant for restriction: The restriction is closed under E 
  and contains no P-nodes *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">restr_invar</span> 
  <span class="comment1">― ‹Invariant for a node restriction, i.e., a transition closed set of nodes 
    known to not contain a target node that satisfies a predicate.›</span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">restr_invar</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">``</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∩</span> Collect <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1" id="DFS_Find_Path-restr_invar_triv"><span class="command">lemma</span></span> restr_invar_triv<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"restr_invar <span class="free">E</span> <span class="main">{}</span> <span class="free">P</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="DFS_Find_Path-restr_invar_imp_not_reachable"><span class="command">lemma</span></span> restr_invar_imp_not_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"restr_invar <span class="free">E</span> <span class="free">R</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">R</span> <span class="main">∩</span> Collect <span class="free">P</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Image_closed_trancl<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> fpr_result <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">+</span> <span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0_restr_pred</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> 
    <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
      Inl <span class="bound">R'</span> <span class="main">⇒</span> <span class="bound">R'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> restr_invar <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">R'</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>
    <span class="main">|</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v0</span> <span class="main">∈</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">.</span> path <span class="main">(</span>rel_restrict <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="bound">v0</span> <span class="bound">vs</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path0_restr_spec</span> 
  <span class="comment1">― ‹Find a path to a target node that satisfies a predicate, not considering
      nodes from the given node restriction. If no path is found, an extended
      restriction is returned, that contains the start nodes›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0_restr_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> restr_invar <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span><span class="main">;</span>
    SPEC <span class="main">(</span>find_path0_restr_pred <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> find_path0_restr_spec_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> 
  ASSERT_le_defI<span class="main">[</span><span class="operator">OF</span> find_path0_restr_spec_def<span class="main">]</span>
  ASSERT_leof_defI<span class="main">[</span><span class="operator">OF</span> find_path0_restr_spec_def<span class="main">]</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path0_restr</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="tfree">'v</span> fpr_result nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0_restr</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  ASSERT <span class="main">(</span>fp0 <span class="main">(</span>graph_restrict <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> fp0.it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'more</span><span class="main">)</span> <span class="main">(</span>graph_restrict <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">;</span>
  <span class="keyword1">case</span> ppath <span class="bound">s</span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span>dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span>Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>
<span class="main">}</span>"</span></span>


<span class="keyword1" id="DFS_Find_Path-find_path0_restr_correct"><span class="command">lemma</span></span> find_path0_restr_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path0_restr <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="main">≤</span> find_path0_restr_spec <span class="free">G</span> <span class="free">P</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> le_ASSERT_defI1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path0_restr_spec_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span> 
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="quoted">"graph_restrict <span class="free">G</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> a.fb_graph_restrict<span class="main">)</span>

  <span class="keyword3"><span class="command">assume</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"restr_invar <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span> <span class="free">R</span> <span class="free">P</span>"</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">reachable</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">reachable</span> <span class="main">=</span> graph_defs.reachable <span class="main">(</span>graph_restrict <span class="free">G</span> <span class="free">R</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> fp0 <span class="quoted"><span class="quoted">"graph_restrict <span class="free">G</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> find_path0_restr_def find_path0_restr_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> it_dfs_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fp0_invar <span class="main">(</span>graph_restrict <span class="free">G</span> <span class="free">R</span><span class="main">)</span> <span class="free">P</span> <span class="skolem">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> NC<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>fp0.cond <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">(</span>graph_restrict <span class="free">G</span> <span class="free">R</span><span class="main">)</span> <span class="free">P</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fp0_invar <span class="quoted"><span class="quoted">"graph_restrict <span class="free">G</span> <span class="free">R</span>"</span></span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ppath <span class="skolem">s</span> <span class="main">=</span> None"</span></span>

      <span class="keyword1"><span class="command">from</span></span> nc_discovered_eq_finished 
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">from</span></span> nc_finished_eq_reachable 
      <span class="keyword1"><span class="command">have</span></span> DFR<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">reachable</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_def<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g_E <span class="free">G</span> <span class="main">``</span> <span class="free">R</span> <span class="main">⊆</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">reachable</span> <span class="main">⊆</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> reachable_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Image_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> rtrancl_mono<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_restrict_def<span class="main">)</span>

      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> DFR reachable_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> E_closed_restr_reach_cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ <span class="quoted"><span class="quoted">‹g_E <span class="free">G</span> <span class="main">``</span> <span class="free">R</span> <span class="main">⊆</span> <span class="free">R</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> nc_fin_closed I 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g_E <span class="free">G</span> <span class="main">``</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">R</span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_restrict_def<span class="main">)</span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> no_path_no_P_discovered nc_discovered_eq_finished I
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> Collect <span class="free">P</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> 
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"find_path0_restr_pred <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def find_path0_restr_pred_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">vs</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ppath <span class="skolem">s</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">vs</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> fp0_correct 
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"find_path0_restr_pred <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="main">(</span>Inr <span class="main">(</span><span class="skolem">vs</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> find_path0_restr_pred_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Path of Minimal Length One, with Restriction›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_restr_pred</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> 
      <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
        Inl <span class="bound">R'</span> <span class="main">⇒</span> <span class="bound">R'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> restr_invar <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">R'</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>
      <span class="main">|</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">vs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v0</span> <span class="main">∈</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> path <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∩</span> UNIV <span class="main">×</span> <span class="main">-</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="bound">v0</span> <span class="bound">vs</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path1_restr_spec</span> 
  <span class="comment1">― ‹Find a path of length at least one to a target node that satisfies P.
    Takes an initial node restriction, and returns an extended node restriction.›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_restr_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> restr_invar <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span><span class="main">;</span>
    SPEC <span class="main">(</span>find_path1_restr_pred <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> find_path1_restr_spec_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> 
  ASSERT_le_defI<span class="main">[</span><span class="operator">OF</span> find_path1_restr_spec_def<span class="main">]</span>
  ASSERT_leof_defI<span class="main">[</span><span class="operator">OF</span> find_path1_restr_spec_def<span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path1_restr</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="tfree">'v</span> fpr_result nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_restr</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> 
  FOREACHc <span class="main">(</span>g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> is_Inl <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>is_Inl <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="comment1">― ‹TODO: Add FOREACH-condition as precondition in autoref!›</span>
    <span class="keyword1">let</span> <span class="bound">R</span> <span class="main">=</span> projl <span class="bound">s</span><span class="main">;</span>
    <span class="bound">f0</span> <span class="main">←</span> find_path0_restr_spec <span class="main">(</span><span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">⦇</span> g_V0 <span class="main">:=</span> g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v0</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">R</span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">f0</span> <span class="keyword1">of</span> 
      Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RETURN <span class="bound">f0</span>
    <span class="main">|</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Inr <span class="main">(</span><span class="bound">v0</span><span class="main">#</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_tailrec_invar</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R0</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span>
    Inl <span class="bound">R</span> <span class="main">⇒</span> <span class="bound">R</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">R0</span></span></span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">(</span>g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">)</span> <span class="main">∧</span> restr_invar <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">R</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>
  <span class="main">|</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">vs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v0</span> <span class="main">∈</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span><span class="main">.</span> path <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∩</span> UNIV <span class="main">×</span> <span class="main">-</span><span class="free"><span class="bound"><span class="entity">R0</span></span></span><span class="main">)</span> <span class="bound">v0</span> <span class="bound">vs</span> <span class="bound">v</span><span class="main">)</span>"</span></span>


<span class="keyword1" id="DFS_Find_Path-find_path1_restr_correct"><span class="command">lemma</span></span> find_path1_restr_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path1_restr <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="main">≤</span> find_path1_restr_spec <span class="free">G</span> <span class="free">P</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> le_ASSERT_defI1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path1_restr_spec_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb0<span class="main">:</span> fb_graph <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⦇</span> g_E <span class="main">:=</span> g_E <span class="free">G</span> <span class="main">∩</span> UNIV <span class="main">×</span> <span class="main">-</span><span class="free">R</span> <span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> a.fb_graph_subset<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

  <span class="keyword3"><span class="command">assume</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"restr_invar <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span> <span class="free">R</span> <span class="free">P</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> aux2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v0</span><span class="main">.</span> <span class="bound">v0</span> <span class="main">∈</span> g_V0 <span class="free">G</span> <span class="main">⟹</span> fb_graph <span class="main">(</span><span class="free">G</span> <span class="main">⦇</span> g_V0 <span class="main">:=</span> g_E <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="bound">v0</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> a.fb_graph_subset<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v0</span> <span class="skolem">it</span> <span class="skolem">s</span>
    <span class="keyword3"><span class="command">assume</span></span> IT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">it</span> <span class="main">⊆</span> g_V0 <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> <span class="skolem">it</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"is_Inl <span class="skolem">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> FPI<span class="main">:</span> <span class="quoted"><span class="quoted">"find_path1_tailrec_invar <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="skolem">it</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> RI<span class="main">:</span> <span class="quoted"><span class="quoted">"restr_invar <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span> <span class="main">(</span>projl <span class="skolem">s</span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v0</span><span class="main">}</span><span class="main">)</span> <span class="free">P</span>"</span></span>

    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> Inl <span class="skolem">R'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> FPI <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">R'</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">(</span>g_V0 <span class="free">G</span> <span class="main">-</span> <span class="skolem">it</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> find_path1_tailrec_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"find_path1_tailrec_invar <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v0</span><span class="main">}</span><span class="main">)</span>
            <span class="main">(</span>Inl <span class="main">(</span>projl <span class="skolem">s</span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v0</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> RI
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> find_path1_tailrec_invar_def it_step_insert_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IT<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux4 <span class="main">=</span> this      

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v0</span> <span class="skolem">u</span> <span class="skolem">it</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="skolem">p</span>
    <span class="keyword3"><span class="command">assume</span></span> IT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">it</span> <span class="main">⊆</span> g_V0 <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> <span class="skolem">it</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"is_Inl <span class="skolem">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> FPI<span class="main">:</span> <span class="quoted"><span class="quoted">"find_path1_tailrec_invar <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="skolem">it</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> PV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>rel_restrict <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span> <span class="main">(</span>projl <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> PR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> projl <span class="skolem">s</span>"</span></span>

    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> Inl <span class="skolem">R'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> FPI <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">R'</span> <span class="main">=</span> <span class="free">R</span> <span class="main">∪</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">(</span>g_V0 <span class="free">G</span> <span class="main">-</span> <span class="skolem">it</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> find_path1_tailrec_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"find_path1_tailrec_invar <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>Inr <span class="main">(</span><span class="skolem">v0</span> <span class="main">#</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_path1_tailrec_invar_def PV<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">v0</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> PR PATH<span class="main">(</span>2<span class="main">)</span> path_mono<span class="main">[</span><span class="operator">OF</span> rel_restrict_mono2<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">R</span></span><span class="main"><span class="main">]</span></span> PATH<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path1_restr_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> IT <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux5 <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_path1_restr_def find_path1_restr_spec_def find_path1_restr_pred_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> le_ASSERTI
      <span class="dynamic"><span class="dynamic">refine_vcg</span></span> FOREACHc_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"find_path1_tailrec_invar <span class="free">G</span> <span class="free">P</span> <span class="free">R</span>"</span></span><span class="main"><span class="main">]</span></span>
      <span class="comment1">(*order_trans[OF find_path0_restr_correct]*)</span>
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_path1_tailrec_invar_def restr_invar_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> aux2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_path1_tailrec_invar_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> find_path0_restr_pred_def aux4 aux5
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trancl_Image_unfold_left<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_path1_tailrec_invar_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_pred</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> 
      <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∩</span> Collect <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">{}</span>
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">vs</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">vs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v0</span> <span class="main">∈</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> path <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">v0</span> <span class="bound">vs</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path1_spec</span> 
  <span class="comment1">― ‹Find a path of length at least one to a target node that satisfies 
      a given predicate.›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
    SPEC <span class="main">(</span>find_path1_pred <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> find_path1_spec_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> 
  ASSERT_le_defI<span class="main">[</span><span class="operator">OF</span> find_path1_spec_def<span class="main">]</span>
  ASSERT_leof_defI<span class="main">[</span><span class="operator">OF</span> find_path1_spec_def<span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Path of Minimal Length One, without Restriction›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_path1</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> fp_result nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">r</span> <span class="main">←</span> find_path1_restr_spec <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">{}</span><span class="main">;</span>
  <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
    Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RETURN None
  <span class="main">|</span> Inr <span class="bound">vsv</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Some <span class="bound">vsv</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="DFS_Find_Path-find_path1_correct"><span class="command">lemma</span></span> find_path1_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path1 <span class="free">G</span> <span class="free">P</span> <span class="main">≤</span> find_path1_spec <span class="free">G</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path1_def find_path1_spec_def find_path1_pred_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path1_restr_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> find_path1_restr_spec_def find_path1_restr_pred_def
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits 
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> restr_invar_imp_not_reachable tranclD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>

<span class="comment1">(* Implementation with stack *)</span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> fp0_state_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> simple_state"</span></span> <span class="main">+</span>
  ppath <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> option"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fp0_erel</span> <span class="main">≡</span> <span class="main">{</span> 
  <span class="main">(</span><span class="main">⦇</span> fp0_state_impl.ppath <span class="main">=</span> <span class="bound">p</span> <span class="main">⦈</span><span class="main">,</span> <span class="main">⦇</span> fp0_state.ppath <span class="main">=</span> <span class="bound">p</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span><span class="main">.</span> True <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">fp0_rel</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">⟨</span>fp0_erel<span class="main">⟩</span>restr_simple_state_rel <span class="free"><span class="bound"><span class="entity">R</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">no_path_impl</span> <span class="main">≡</span> <span class="main">⦇</span> fp0_state_impl.ppath <span class="main">=</span> None <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">a_path_impl</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">⦇</span> fp0_state_impl.ppath <span class="main">=</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1" id="DFS_Find_Path-fp0_rel_ppath_cong"><span class="command">lemma</span></span> fp0_rel_ppath_cong<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>fp0_rel <span class="free">R</span> <span class="main">⟹</span> fp0_state_impl.ppath <span class="free">s</span> <span class="main">=</span> fp0_state.ppath <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> restr_simple_state_rel_def fp0_erel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="DFS_Find_Path-fp0_ss_rel_ppath_cong"><span class="command">lemma</span></span> fp0_ss_rel_ppath_cong<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>fp0_erel<span class="main">⟩</span>simple_state_rel <span class="main">⟹</span> fp0_state_impl.ppath <span class="free">s</span> <span class="main">=</span> fp0_state.ppath <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> simple_state_rel_def fp0_erel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="DFS_Find_Path-fp0i_cong"><span class="command">lemma</span></span> fp0i_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"simple_state.more <span class="free">s</span> <span class="main">=</span> simple_state.more <span class="free">s'</span> 
  <span class="main">⟹</span> fp0_state_impl.ppath <span class="free">s</span> <span class="main">=</span> fp0_state_impl.ppath <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="DFS_Find_Path-fp0_erelI"><span class="command">lemma</span></span> fp0_erelI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p'</span> 
  <span class="main">⟹</span> <span class="main">(</span><span class="main">⦇</span> fp0_state_impl.ppath <span class="main">=</span> <span class="free">p</span> <span class="main">⦈</span><span class="main">,</span> <span class="main">⦇</span> fp0_state.ppath <span class="main">=</span> <span class="free">p'</span><span class="main">⦈</span><span class="main">)</span><span class="main">∈</span>fp0_erel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fp0_erel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fp0_params_impl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'v</span> fp0_state_impl<span class="main">,</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span>fp0_state_impl_ext<span class="main">)</span> gen_parameterization"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fp0_params_impl</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
  on_init <span class="main">=</span> RETURN no_path_impl<span class="main">,</span>
  on_new_root <span class="main">=</span> <span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> 
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v0</span> <span class="keyword1">then</span> RETURN <span class="main">(</span>a_path_impl <span class="main">[]</span> <span class="bound">v0</span><span class="main">)</span> <span class="keyword1">else</span> RETURN no_path_impl<span class="main">,</span>
  on_discover <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> 
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="keyword1">then</span> RETURN <span class="main">(</span>a_path_impl <span class="main">(</span>map fst <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>CAST <span class="main">(</span>ss_stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">v</span><span class="main">)</span>
    <span class="keyword1">else</span> RETURN no_path_impl<span class="main">,</span>
  on_finish <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
  on_back_edge <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
  on_cross_edge <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
  is_break <span class="main">=</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ppath <span class="bound">s</span> <span class="main">≠</span> None <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> fp0_params_impl_simp<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">DFS_code_unfold</span><span class="main">]</span> 
  <span class="main">=</span> gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> fp0_params_impl_def<span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> fp0_impl<span class="main">:</span>
  restricted_impl_defs <span class="quoted"><span class="quoted">"fp0_params_impl <span class="free">P</span>"</span></span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span> <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">R</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">locale</span></span> fp0_restr <span class="main">=</span> fb_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> fp0<span class="main">?</span><span class="main">:</span> fp0 <span class="quoted"><span class="quoted">"graph_restrict <span class="free">G</span> <span class="free">R</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fp0I<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fb_graph_restrict<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> impl<span class="main">:</span> restricted_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="quoted">"fp0_params <span class="free">P</span>"</span></span> <span class="quoted"><span class="quoted">"fp0_params_impl <span class="free">P</span>"</span></span> 
    <span class="quoted">fp0_erel</span> <span class="quoted"><span class="free">R</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fp0_erel_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rev_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> map_tl comp_def
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fp0_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>7<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_rel_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> IdD<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> list_rel_id_simp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0_restr_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  ASSERT <span class="main">(</span>fp0 <span class="main">(</span>graph_restrict <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> fp0_impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">;</span>
  <span class="keyword1">case</span> ppath <span class="bound">s</span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> RETURN <span class="main">(</span>Inl <span class="main">(</span>visited <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>
<span class="main">}</span>"</span></span>


<span class="keyword1" id="DFS_Find_Path-find_path0_restr_impl"><span class="command">lemma</span></span> find_path0_restr_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path0_restr_impl <span class="free">G</span> <span class="free">P</span> <span class="free">R</span> 
     <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span>Id<span class="main">,</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id<span class="main">⟩</span>sum_rel<span class="main">)</span> 
   <span class="main">(</span>find_path0_restr <span class="free">G</span> <span class="free">P</span> <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> refine_ASSERT_defI2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path0_restr_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> fp0_restr <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> find_path0_restr_impl_def find_path0_restr_def
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> impl.tailrec_refine<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_simple_state_rel_def<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path0_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fp0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> fp0_impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">{}</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>ppath <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="DFS_Find_Path-find_path0_impl"><span class="command">lemma</span></span> find_path0_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"find_path0_impl <span class="free">G</span> <span class="free">P</span> 
  <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span><span class="main">⟨</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id<span class="main">⟩</span>option_rel<span class="main">)</span> <span class="main">(</span>find_path0 <span class="free">G</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> refine_ASSERT_defI1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path0_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fp0 <span class="free">G</span>"</span></span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fp0 <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> r<span class="main">:</span> fp0_restr <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> find_path0_impl_def find_path0_def
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> r.impl.tailrec_refine<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Synthesis of Executable Code›</span></span>
<span class="comment1">(* Autoref *)</span>

<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>fp0_state_impl' <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_nos_impl"</span></span> <span class="main">+</span>
  ppath_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> option"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fp0_state_erel</span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="main">⦇</span>ppath_impl <span class="main">=</span> <span class="bound">pi</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span>  <span class="bound">mi</span><span class="main">⦈</span><span class="main">,</span><span class="main">⦇</span>ppath <span class="main">=</span> <span class="bound">p</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">m</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">pi</span> <span class="bound">mi</span> <span class="bound">p</span> <span class="bound">m</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">pi</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">⟩</span>option_rel <span class="main">∧</span> <span class="main">(</span><span class="bound">mi</span><span class="main">,</span><span class="bound">m</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">erel</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">consts</span></span> 
  i_fp0_state_ext <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">fp0_state_erel</span> <span class="quoted">i_fp0_state_ext</span><span class="main">]</span>


<span class="keyword1"><span class="command">term</span></span> <span class="quoted">fp0_state_impl_ext</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ns_rel</span> <span class="free">vis_rel</span> <span class="free">erel</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">ns_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="main">⟨</span><span class="free">erel</span><span class="main">⟩</span>fp0_state_erel<span class="main">⟩</span>ssnos_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>fp0_state_impl'_ext<span class="main">,</span> fp0_state_impl_ext<span class="main">)</span> 
      <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">⟩</span>option_rel <span class="main">→</span> <span class="free">erel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">erel</span><span class="main">⟩</span>fp0_state_erel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>ppath_impl<span class="main">,</span> fp0_state_impl.ppath<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">⟩</span>option_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fp0_state_erel_def ssnos_impl_rel_def R_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> find_path0_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">::</span> hashable<span class="main">,</span> <span class="main">_</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Pi</span><span class="main">,</span> <span class="free">P</span><span class="main">)</span> <span class="main">∈</span> Id <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>Id<span class="main">::</span><span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set<span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nres_of <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> dres<span class="main">)</span><span class="main">,</span> find_path0_impl <span class="free">G</span> <span class="free">P</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path0_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span> ssnos_unfolds
  <span class="keyword1"><span class="command">unfolding</span></span> if_cancel not_not comp_def nres_monad_laws
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_path0_code</span> <span class="keyword2"><span class="keyword">uses</span></span> find_path0_code
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_path0_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="DFS_Find_Path-find_path0_autoref_aux"><span class="command">lemma</span></span> find_path0_autoref_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Vid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rv</span> <span class="main">=</span> <span class="main">(</span>Id <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> hashable rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">G</span> <span class="bound">P</span><span class="main">.</span> nres_of <span class="main">(</span>find_path0_code <span class="bound">G</span> <span class="bound">P</span><span class="main">)</span><span class="main">,</span> find_path0_spec<span class="main">)</span> 
    <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">Rv</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="main">(</span><span class="free">Rv</span> <span class="main">→</span> bool_rel<span class="main">)</span> 
      <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">Rv</span><span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Vid
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> 
    order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path0_code.refine<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">param_fo</span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">THEN</span> nres_relD<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
    <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
    <span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> find_path0_impl find_path0_correct
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">lemmas</span></span> find_path0_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> find_path0_autoref_aux<span class="main">[</span><span class="operator">OF</span> PREFER_id_D<span class="main">]</span>  




<span class="keyword1"><span class="command">schematic_goal</span></span> find_path0_restr_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">vis_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'visi</span><span class="main">×</span><span class="tfree">'v</span> set<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">vis_rel</span></span> <span class="quoted"><span class="quoted">"i_set"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">I</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_insert</span><span class="main">,</span> insert<span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_memb</span><span class="main">,</span> <span class="main">(∈)</span><span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Pi</span><span class="main">,</span><span class="free">P</span><span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> bool_rel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ri</span><span class="main">,</span><span class="free">R</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nres_of <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> dres<span class="main">)</span><span class="main">,</span>
    find_path0_restr_impl 
      <span class="free">G</span>
      <span class="free">P</span> 
      <span class="main">(</span><span class="free">R</span><span class="keyword1">:::<span class="hidden">⇩</span><sub>r</sub></span><span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path0_restr_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span> ssnos_unfolds
  <span class="keyword1"><span class="command">unfolding</span></span> if_cancel not_not comp_def nres_monad_laws
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_path0_restr_code</span> <span class="keyword2"><span class="keyword">uses</span></span> find_path0_restr_code
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_path0_restr_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="DFS_Find_Path-find_path0_restr_autoref_aux"><span class="command">lemma</span></span> find_path0_restr_autoref_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_insert</span><span class="main">,</span> insert<span class="main">)</span><span class="main">∈</span><span class="free">Rv</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span><span class="free">vis_rel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_memb</span><span class="main">,</span> <span class="main">(∈)</span><span class="main">)</span><span class="main">∈</span><span class="free">Rv</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Vid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rv</span> <span class="main">=</span> Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">G</span> <span class="bound">P</span> <span class="bound">R</span><span class="main">.</span> nres_of <span class="main">(</span>find_path0_restr_code <span class="free">op_vis_insert</span> <span class="free">op_vis_memb</span> <span class="bound">G</span> <span class="bound">P</span> <span class="bound">R</span><span class="main">)</span><span class="main">,</span> 
    find_path0_restr_spec<span class="main">)</span> 
    <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">Rv</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="main">(</span><span class="free">Rv</span> <span class="main">→</span> bool_rel<span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span>
    <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span><span class="free">vis_rel</span><span class="main">,</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">Rv</span><span class="main">⟩</span>sum_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Vid
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> 
    order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path0_restr_code.refine<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> 1<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> Vid<span class="main"><span class="main"><span class="main">]</span></span></span> 2<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> Vid<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">param_fo</span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">THEN</span> nres_relD<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span>
    <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">using</span></span> find_path0_restr_impl find_path0_restr_correct
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">lemmas</span></span> find_path0_restr_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> find_path0_restr_autoref_aux<span class="main">[</span><span class="operator">OF</span> GEN_OP_D GEN_OP_D PREFER_id_D<span class="main">]</span>  

<span class="keyword1"><span class="command">schematic_goal</span></span> find_path1_restr_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">vis_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'visi</span><span class="main">×</span><span class="tfree">'v</span> set<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">vis_rel</span></span> <span class="quoted"><span class="quoted">"i_set"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">I</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_insert</span><span class="main">,</span> insert<span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_memb</span><span class="main">,</span> <span class="main">(∈)</span><span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Pi</span><span class="main">,</span><span class="free">P</span><span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> bool_rel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ri</span><span class="main">,</span><span class="free">R</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nres_of <span class="var">?c</span><span class="main">,</span>find_path1_restr <span class="free">G</span> <span class="free">P</span> <span class="free">R</span><span class="main">)</span>
  <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span>Id<span class="main">⟩</span><span class="free">vis_rel</span><span class="main">,</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">⟩</span>sum_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path1_restr_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_path1_restr_code</span> <span class="keyword2"><span class="keyword">uses</span></span> find_path1_restr_code
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_path1_restr_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="DFS_Find_Path-find_path1_restr_autoref_aux"><span class="command">lemma</span></span> find_path1_restr_autoref_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_insert</span><span class="main">,</span> insert<span class="main">)</span><span class="main">∈</span><span class="free">V</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span><span class="free">vis_rel</span>"</span></span>
             <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">op_vis_memb</span><span class="main">,</span> <span class="main">(∈)</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Vid<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">V</span><span class="main">=</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">G</span> <span class="bound">P</span> <span class="bound">R</span><span class="main">.</span> nres_of <span class="main">(</span>find_path1_restr_code <span class="free">op_vis_insert</span> <span class="free">op_vis_memb</span> <span class="bound">G</span> <span class="bound">P</span> <span class="bound">R</span><span class="main">)</span><span class="main">,</span>find_path1_restr_spec<span class="main">)</span>
  <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span><span class="free">vis_rel</span> <span class="main">→</span>
    <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span><span class="free">vis_rel</span><span class="main">,</span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">V</span><span class="main">⟩</span>sum_rel<span class="main">⟩</span>nres_rel"</span></span>
    
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> find_path1_restr_code.refine<span class="main">[</span><span class="operator">OF</span> G<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">param_fo</span><span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_path1_restr_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> find_path1_restr_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> find_path1_restr_autoref_aux<span class="main">[</span><span class="operator">OF</span> GEN_OP_D GEN_OP_D PREFER_id_D<span class="main">]</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> find_path1_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Vid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">=</span> <span class="main">(</span>Id <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> hashable rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> Vid<span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Pi</span><span class="main">,</span><span class="free">P</span><span class="main">)</span><span class="main">∈</span><span class="free">V</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="main">(</span>Id<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'a</span><span class="main">::</span>hashable<span class="main">)</span>set<span class="main">)</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nres_of <span class="var">?c</span><span class="main">,</span>find_path1 <span class="free">G</span> <span class="free">P</span><span class="main">)</span>
  <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">V</span><span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path1_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> Vid
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_path1_code</span> <span class="keyword2"><span class="keyword">uses</span></span> find_path1_code

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_path1_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="DFS_Find_Path-find_path1_code_autoref_aux"><span class="command">lemma</span></span> find_path1_code_autoref_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Vid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">=</span> <span class="main">(</span>Id <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> hashable rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">G</span> <span class="bound">P</span><span class="main">.</span> nres_of <span class="main">(</span>find_path1_code <span class="bound">G</span> <span class="bound">P</span><span class="main">)</span><span class="main">,</span> find_path1_spec<span class="main">)</span>
    <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">V</span><span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> find_path1_code.refine<span class="main">[</span><span class="operator">OF</span> Vid<span class="main">,</span> <span class="operator">param_fo</span><span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_path1_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> find_path1_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> find_path1_code_autoref_aux<span class="main">[</span><span class="operator">OF</span> PREFER_id_D<span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Conclusion›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We have synthesized an efficient implementation for an algorithm to find a path
  to a reachable node that satisfies a predicate. The algorithm comes in four variants,
  with and without empty path, and with and without node restriction.

  We have set up the Autoref tool, to insert this algorithms for the following 
  specifications:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"find_path0_spec <span class="free"><span class="free">G</span></span> <span class="free"><span class="free">P</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> --- find path to node that satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"find_path1_spec <span class="free"><span class="free">G</span></span> <span class="free"><span class="free">P</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> --- find non-empty path to node that satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"find_path0_restr_spec <span class="free"><span class="free">G</span></span> <span class="free"><span class="free">P</span></span> <span class="free"><span class="free">R</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> --- find path, with nodes from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> already searched.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"find_path1_restr_spec"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> --- find non-empty path, with nodes from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> already searched.

›</span></span>
<span class="keyword1"><span class="command">thm</span></span> find_path0_autoref
<span class="keyword1"><span class="command">thm</span></span> find_path1_autoref
<span class="keyword1"><span class="command">thm</span></span> find_path0_restr_autoref
<span class="keyword1"><span class="command">thm</span></span> find_path1_restr_autoref


<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Reachable_Nodes">
<div class="head">
<h1>Theory Reachable_Nodes</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Set of Reachable Nodes›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Reachable_Nodes
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="DFS_Framework.html">../DFS_Framework</a>"</span>
  <a href="../CAVA_Automata/Digraph_Impl.html">CAVA_Automata.Digraph_Impl</a>
  <span class="quoted">"<a href="Impl_Rev_Array_Stack.html">../Misc/Impl_Rev_Array_Stack</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory provides a re-usable algorithm to compute the set of reachable
  nodes in a graph.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>
<span class="keyword1" id="Reachable_Nodes-gen_obtain_finite_set"><span class="command">lemma</span></span> gen_obtain_finite_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">e</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span>insert<span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">xi</span><span class="main">.</span> <span class="main">(</span><span class="bound">xi</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Si</span><span class="main">.</span> <span class="main">(</span><span class="bound">Si</span><span class="main">,</span><span class="free">S</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S'</span> <span class="main">=</span> <span class="free">S</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span><span class="main">⊆</span><span class="skolem">S'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> F this <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">Si</span><span class="main">.</span> <span class="main">(</span><span class="bound">Si</span><span class="main">,</span><span class="free">S</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>  
      <span class="keyword1"><span class="command">using</span></span> E <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">S</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xi</span></span> <span class="skolem"><span class="skolem">Si</span></span> <span class="keyword2"><span class="keyword">where</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">Si</span><span class="main">,</span><span class="skolem">S</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xi</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> EE <span class="keyword1"><span class="command">unfolding</span></span> S'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> I<span class="main">[</span><span class="operator">THEN</span> fun_relD<span class="main">,</span> <span class="operator">OF</span> 2<span class="main">,</span> <span class="operator">THEN</span> fun_relD<span class="main">,</span> <span class="operator">OF</span> 1<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>        


<span class="keyword1" id="Reachable_Nodes-obtain_finite_ahs"><span class="command">lemma</span></span> obtain_finite_ahs<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">S</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">⟩</span>dflt_ahs_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> gen_obtain_finite_set<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">autoref</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">autoref</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Framework Instantiation›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unit_parametrization</span> <span class="main">≡</span> dflt_parametrization <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">)</span> <span class="main">(</span>RETURN <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> unit_parametrization_simp<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> 
  dflt_parametrization_simp<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span><span class="main">,</span> <span class="operator">OF</span> unit_parametrization_def<span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> unit_dfs<span class="main">:</span> param_DFS_defs <span class="keyword2"><span class="keyword">where</span></span> param<span class="main">=</span><span class="quoted">unit_parametrization</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">locale</span></span> unit_DFS <span class="main">=</span> param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">unit_parametrization</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">unit_parametrization</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Reachable_Nodes-unit_DFSI"><span class="command">lemma</span></span> unit_DFSI<span class="main">[</span><span class="operator">Pure.intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unit_DFS <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* Find Reachable Nodes *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_reachable</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> unit_dfs.it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_reachableT</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> unit_dfs.it_dfsT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness›</span></span>

<span class="keyword1"><span class="command">context</span></span> unit_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Reachable_Nodes-find_reachable_correct"><span class="command">lemma</span></span> find_reachable_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"find_reachable <span class="free">G</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> reachable<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_reachable_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> it_dfs_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> DFS_invar.nc_discovered_eq_reachable<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Reachable_Nodes-find_reachableT_correct"><span class="command">lemma</span></span> find_reachableT_correct<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"finite reachable <span class="main">⟹</span> find_reachableT <span class="free">G</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> reachable<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_reachableT_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> it_dfsT_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> DFS_invar.nc_discovered_eq_reachable<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> unit_DFS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(* Derive the implementation *)</span>
  <span class="keyword1"><span class="command">sublocale</span></span> simple_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">unit_parametrization</span> <span class="quoted">unit_parametrization</span> <span class="quoted">unit_rel</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemmas</span></span> impl_refine <span class="main">=</span> simple_tailrecT_refine simple_tailrec_refine simple_rec_refine
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">interpretation</span></span> unit_simple_impl<span class="main">:</span> 
  simple_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">unit_parametrization</span> <span class="quoted">unit_parametrization</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">unit_simple_impl.tailrec_impl</span> <span class="keyword1"><span class="command">term</span></span> <span class="quoted">unit_simple_impl.rec_impl</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">find_reachable_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> unit_simple_impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>simple_state.visited <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">find_reachable_implT</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> unit_simple_impl.tailrec_implT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>simple_state.visited <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">find_reachable_rec_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> unit_simple_impl.rec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>visited <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>


<span class="keyword1" id="Reachable_Nodes-find_reachable_impl_refine"><span class="command">lemma</span></span> find_reachable_impl_refine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"find_reachable_impl <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>find_reachable <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_reachable_impl_def find_reachable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> unit_DFS.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_DFSI simple_state_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Reachable_Nodes-find_reachable_implT_refine"><span class="command">lemma</span></span> find_reachable_implT_refine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"find_reachable_implT <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>find_reachableT <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_reachable_implT_def find_reachableT_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> unit_DFS.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_DFSI simple_state_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1" id="Reachable_Nodes-find_reachable_rec_impl_refine"><span class="command">lemma</span></span> find_reachable_rec_impl_refine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"find_reachable_rec_impl <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>find_reachable <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_reachable_rec_impl_def find_reachable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> unit_DFS.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_DFSI simple_state_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Synthesis of Executable Implementation›</span></span>
<span class="comment1">(* Autoref *)</span>
<span class="keyword1"><span class="command">schematic_goal</span></span> find_reachable_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>hashable<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> dres<span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>find_reachable_impl <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> if_cancel <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span> ssnos_unfolds
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_reachable_code</span> <span class="keyword2"><span class="keyword">uses</span></span> find_reachable_impl
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_reachable_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="Reachable_Nodes-find_reachable_code_correct"><span class="command">lemma</span></span> find_reachable_code_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"find_reachable_code <span class="free">Gi</span> <span class="main">=</span> dRETURN <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span><span class="main">,</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">⟩</span>dflt_ahs_rel"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">interpret</span></span> unit_DFS <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">note</span></span> find_reachable_code.refine<span class="main">[</span><span class="operator">OF</span> 2<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_reachable_impl_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_reachable_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 4 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RETURN_RES_refine_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">schematic_goal</span></span> find_reachable_implT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">eq</span><span class="main">,</span><span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="free">bhc</span>"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>find_reachable_implT <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> if_cancel <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span> ssnos_unfolds
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_reachable_codeT</span> <span class="keyword2"><span class="keyword">for</span></span> eq bhc sz Gi 
  <span class="keyword2"><span class="keyword">uses</span></span> find_reachable_implT
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_reachable_codeT</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="Reachable_Nodes-find_reachable_codeT_correct"><span class="command">lemma</span></span> find_reachable_codeT_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FR<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BHC<span class="main">:</span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">eq</span><span class="main">,</span><span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VDS<span class="main">:</span> <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_reachable_codeT <span class="free">eq</span> <span class="free">bhc</span> <span class="free">sz</span> <span class="free">Gi</span><span class="main">,</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="free">bhc</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> G <span class="keyword1"><span class="command">interpret</span></span> graph <span class="keyword1"><span class="command">by</span></span> <span class="operator">this</span>
  <span class="keyword1"><span class="command">from</span></span> FR <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="keyword1"><span class="command">using</span></span> fb_graphI_fr <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">interpret</span></span> unit_DFS <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">note</span></span> find_reachable_codeT.refine<span class="main">[</span><span class="operator">OF</span> BHC EQ VDS 2<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_reachable_implT_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_reachableT_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> FR <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RETURN_RES_refine_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">all_unit_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_unit_rel</span> <span class="main">≡</span> UNIV"</span></span>

<span class="keyword1" id="Reachable_Nodes-all_unit_refine"><span class="command">lemma</span></span> all_unit_refine<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">()</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∈</span>all_unit_rel"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> all_unit_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unit_list_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">×</span><span class="tfree">'a</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">unit_list_rel</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> UNIV"</span></span>

<span class="keyword1" id="Reachable_Nodes-unit_list_rel_refine"><span class="command">lemma</span></span> unit_list_rel_refine<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">()</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>unit_list_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unit_list_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">unit_list_rel</span> <span class="quoted">i_list</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">()</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>unit_list_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">,</span>tl<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>unit_list_rel<span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>unit_list_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">,</span><span class="main">(#)</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>unit_list_rel<span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>unit_list_rel"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>



<span class="keyword1"><span class="command">schematic_goal</span></span> find_reachable_rec_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">::</span>hashable<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">unfolded</span> V_def<span class="main">,</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nres_of <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> dres<span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>find_reachable_rec_impl <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unit_simple_impl.ssns_unfolds 
    <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span> if_cancel if_False option.case
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_reachable_rec_code</span> <span class="keyword2"><span class="keyword">uses</span></span> find_reachable_rec_impl
<span class="keyword1"><span class="command">prepare_code_thms</span></span> find_reachable_rec_code_def
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_reachable_rec_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="Reachable_Nodes-find_reachable_rec_code_correct"><span class="command">lemma</span></span> find_reachable_rec_code_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"find_reachable_rec_code <span class="free">Gi</span> <span class="main">=</span> dRETURN <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span><span class="main">,</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">⟩</span>dflt_ahs_rel"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">interpret</span></span> unit_DFS <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">note</span></span> find_reachable_rec_code.refine<span class="main">[</span><span class="operator">OF</span> 2<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_reachable_rec_impl_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_reachable_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 4 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RETURN_RES_refine_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">op_reachable</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span> <span class="main">=</span> op_reachable_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Reachable_Nodes-autoref_op_reachable"><span class="command">lemma</span></span> autoref_op_reachable<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span>graph <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FR<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BHC<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">eq</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VDS<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_reachable_codeT <span class="free">eq</span> <span class="free">bhc</span> <span class="free">sz</span> <span class="free">Gi</span><span class="main">,</span>
    <span class="main">(</span><span class="keyword1">OP</span> op_reachable <span class="main">:::</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="free">bhc</span><span class="main">)</span><span class="main">$</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="free">bhc</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_reachable_codeT_correct<span class="main">)</span>  

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Conclusions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We have defined an efficient DFS-based implementation for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> op_reachable<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  and declared it to Autoref.
›</span></span>


<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Feedback_Arcs">
<div class="head">
<h1>Theory Feedback_Arcs</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Find a Feedback Arc Set›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Feedback_Arcs
<span class="keyword2"><span class="keyword">imports</span></span>   
  <span class="quoted">"<a href="DFS_Framework.html">../DFS_Framework</a>"</span>
  <a href="../CAVA_Automata/Digraph_Impl.html">CAVA_Automata.Digraph_Impl</a>
  <a href="Reachable_Nodes.html">Reachable_Nodes</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A feedback arc set is a set of edges that breaks all reachable cycles.
  In this theory, we define an algorithm to find a feedback arc set.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_fas</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="tfree">'v</span> rel <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_fas</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">EC</span></span></span> <span class="main">≡</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span> <span class="bound">u</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">EC</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Feedback_Arcs-is_fas_alt"><span class="command">lemma</span></span> is_fas_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_fas <span class="free">G</span> <span class="free">EC</span> <span class="main">=</span> acyclic <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_fas_def acyclic_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span> <span class="main">×</span> UNIV <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>g_E <span class="free">G</span> <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> trancl_mono<span class="main">)</span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_tranclE<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>g_E <span class="free">G</span> <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v0</span>
  <span class="keyword3"><span class="command">assume</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span><span class="main">∈</span>g_V0 <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>g_E <span class="free">G</span> <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>Restr <span class="main">(</span>g_E <span class="free">G</span> <span class="main">-</span> <span class="free">EC</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> trancl_restrict_reachable<span class="main"><span class="main">[</span></span><span class="operator">OF</span> 3<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> S<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ rtrancl_image_unfold_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> 1 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span> <span class="main">×</span> UNIV <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> trancl_mono<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>g_E <span class="free">G</span> <span class="main">∩</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span> <span class="main">×</span> UNIV <span class="main">-</span> <span class="free">EC</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of the DFS-Framework›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> fas_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> state"</span></span> <span class="main">+</span>
  fas <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>

<span class="comment1">(* Some utility lemmas for the simplifier, to handle idiosyncrasies of
  the record package. *)</span>
<span class="keyword1" id="Feedback_Arcs-fas_more_cong"><span class="command">lemma</span></span> fas_more_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> fas <span class="free">s</span> <span class="main">=</span> fas <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⦇</span> state.more <span class="main">:=</span> <span class="main">⦇</span> fas <span class="main">=</span> <span class="free">foo</span> <span class="main">⦈</span> <span class="main">⦈</span> <span class="main">=</span> <span class="free">s</span> <span class="main">⦇</span> fas <span class="main">:=</span> <span class="free">foo</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fas_params</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> fas_state_ext<span class="main">)</span> parameterization"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fas_params</span> <span class="main">≡</span> dflt_parametrization state.more 
  <span class="main">(</span>RETURN <span class="main">⦇</span> fas <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">⦇</span>
    on_back_edge <span class="main">:=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">⦇</span> fas <span class="main">=</span> insert <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">(</span>fas <span class="bound">s</span><span class="main">)</span> <span class="main">⦈</span>
  <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> fas_params_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
  gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> fas_params_def<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator">simplified</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> fas<span class="main">:</span> param_DFS_defs <span class="keyword2"><span class="keyword">where</span></span> param<span class="main">=</span><span class="quoted">fas_params</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Find feedback arc set ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_fas</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  ASSERT <span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> fas.it_dfsT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>fas_state.fas <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> fas <span class="main">=</span>
  param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">fas_params</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> 
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_reachable<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">fas_params</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fas_params_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Feedback_Arcs-fasI"><span class="command">lemma</span></span> fasI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fas <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fb_graphI_fr<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>

<span class="keyword1"><span class="command">locale</span></span> fas_invar <span class="main">=</span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted">fas_params</span> <span class="main">+</span> fas
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> fas<span class="main">)</span> i_fas_eq_back<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> fas_state.fas <span class="bound">s</span> <span class="main">=</span> back_edges <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> fas_more_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_state_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> fas_eq_back <span class="main">=</span> i_fas_eq_back<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="Feedback_Arcs-find_fas_correct_aux"><span class="command">lemma</span></span> find_fas_correct_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_fas <span class="free">G</span> <span class="main">(</span>fas_state.fas <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> fas_eq_back  

    <span class="keyword1"><span class="command">from</span></span> nc_edges_covered<span class="main">[</span><span class="operator">OF</span> NC<span class="main">]</span> edges_disjoint <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"E <span class="main">∩</span> reachable <span class="main">×</span> UNIV <span class="main">-</span> back_edges <span class="free">s</span> <span class="main">=</span> tree_edges <span class="free">s</span> <span class="main">∪</span> cross_edges <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> tree_cross_acyclic <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"is_fas <span class="free">G</span> <span class="main">(</span>fas_state.fas <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_fas_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Feedback_Arcs-find_fas_correct"><span class="command">lemma</span></span> find_fas_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_fas <span class="free">G</span> <span class="main">≤</span> SPEC <span class="main">(</span>is_fas <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_fas_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">refine_vcg</span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> DFS.it_dfsT_correct<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fb_graphI_fr<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> fas <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS <span class="free">G</span> fas_params"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> fas_params <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted">fas_params</span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> fas_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>fas.cond <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"is_fas <span class="free">G</span> <span class="main">(</span>fas_state.fas <span class="skolem">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> find_fas_correct_aux<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>

<span class="comment1">(* Implementation with stack and sso_visited set *)</span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> fas_state_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> simple_state"</span></span> <span class="main">+</span>
  fas <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>

<span class="comment1">(* Definition of refinement relation: The break-flag is refined by identity.*)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fas_erel</span> <span class="main">≡</span> <span class="main">{</span> 
  <span class="main">(</span><span class="main">⦇</span> fas_state_impl.fas <span class="main">=</span> <span class="bound">f</span> <span class="main">⦈</span><span class="main">,</span> <span class="main">⦇</span> fas_state.fas <span class="main">=</span> <span class="bound">f</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f</span><span class="main">.</span> True <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">fas_rel</span> <span class="main">≡</span> <span class="main">⟨</span>fas_erel<span class="main">⟩</span>simple_state_rel"</span></span>

<span class="comment1">(* Implementation of the parameters *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fas_params_impl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'v</span> fas_state_impl<span class="main">,</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> fas_state_impl_ext<span class="main">)</span> gen_parameterization"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fas_params_impl</span> 
  <span class="main">≡</span> dflt_parametrization simple_state.more <span class="main">(</span>RETURN <span class="main">⦇</span> fas <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">⦇</span>
  on_back_edge <span class="main">:=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">⦇</span> fas <span class="main">=</span> insert <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">(</span>fas <span class="bound">s</span><span class="main">)</span> <span class="main">⦈</span><span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> fas_params_impl_simp<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> 
  gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> fas_params_impl_def<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator">simplified</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span>

<span class="keyword1" id="Feedback_Arcs-fas_impl"><span class="command">lemma</span></span> fas_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>fas_rel 
  <span class="main">⟹</span> fas_state_impl.fas <span class="free">si</span> <span class="main">=</span> fas_state.fas <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_state_rel_def fas_erel_def<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> fas_impl<span class="main">:</span> simple_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">fas_params_impl</span> <span class="quoted">fas_params</span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(* The above locale creates an iterative and a recursive implementation *)</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">fas_impl.tailrec_impl</span> <span class="keyword1"><span class="command">term</span></span> <span class="quoted">fas_impl.tailrec_implT</span> <span class="keyword1"><span class="command">term</span></span> <span class="quoted">fas_impl.rec_impl</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">DFS_code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">find_fas_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  ASSERT <span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> fas_impl.tailrec_implT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>fas <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">context</span></span> fas <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(* Derive the implementation *)</span>
  <span class="keyword1"><span class="command">sublocale</span></span> simple_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">fas_params</span> <span class="quoted">fas_params_impl</span> <span class="quoted">fas_erel</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_state_rel_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fas_erel_def fas_impl simple_state_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> impl_refine <span class="main">=</span> simple_tailrec_refine simple_tailrecT_refine simple_rec_refine
  <span class="keyword1"><span class="command">thm</span></span> simple_refine
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Feedback_Arcs-find_fas_impl_refine"><span class="command">lemma</span></span> find_fas_impl_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"find_fas_impl <span class="free">G</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>find_fas <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_fas_impl_def find_fas_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> fas.impl_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fas_impl fasI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Synthesis of Executable Code›</span></span>
<span class="comment1">(* Autoref *)</span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">,</span><span class="tfree">'fsi</span><span class="main">)</span>fas_state_impl' <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_impl"</span></span> <span class="main">+</span>
  fas_impl <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'fsi</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fas_state_erel</span> <span class="free"><span class="bound"><span class="entity">frel</span></span></span> <span class="free"><span class="bound"><span class="entity">erel</span></span></span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="main">⦇</span>fas_impl <span class="main">=</span> <span class="bound">fi</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span>  <span class="bound">mi</span><span class="main">⦈</span><span class="main">,</span><span class="main">⦇</span>fas <span class="main">=</span> <span class="bound">f</span><span class="main">,</span> <span class="main">…</span> <span class="main">=</span> <span class="bound">m</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">fi</span> <span class="bound">mi</span> <span class="bound">f</span> <span class="bound">m</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">fi</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">frel</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">mi</span><span class="main">,</span><span class="bound">m</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">erel</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">consts</span></span> 
  i_fas_state_ext <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface <span class="main">⇒</span> interface"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">fas_state_erel</span> <span class="quoted">i_fas_state_ext</span><span class="main">]</span>


<span class="keyword1"><span class="command">term</span></span> <span class="quoted">fas_update</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">fas_state_impl'.fas_impl_update</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ns_rel</span> <span class="free">vis_rel</span> <span class="free">frel</span> <span class="free">erel</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">ns_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="main">⟨</span><span class="free">frel</span><span class="main">,</span><span class="free">erel</span><span class="main">⟩</span>fas_state_erel<span class="main">⟩</span>ss_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>fas_state_impl'_ext<span class="main">,</span> fas_state_impl_ext<span class="main">)</span> <span class="main">∈</span> <span class="free">frel</span> <span class="main">→</span> <span class="free">erel</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">frel</span><span class="main">,</span><span class="free">erel</span><span class="main">⟩</span>fas_state_erel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>fas_impl<span class="main">,</span> fas_state_impl.fas<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="free">frel</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>fas_state_impl'.fas_impl_update<span class="main">,</span> fas_update<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">frel</span> <span class="main">→</span> <span class="free">frel</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fas_state_erel_def ss_impl_rel_def R_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">parametricity</span><span class="main">)</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> find_fas_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">eq</span><span class="main">,</span><span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="free">bhc</span>"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="main">(</span>prod_bhc <span class="free">bhc</span> <span class="free">bhc</span><span class="main">)</span>"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>find_fas_impl <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">,</span> <span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_fas_code</span> <span class="keyword2"><span class="keyword">for</span></span> eq bhc sz Gi <span class="keyword2"><span class="keyword">uses</span></span> find_fas_impl
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_fas_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">thm</span></span> find_fas_code.refine

<span class="keyword1" id="Feedback_Arcs-find_fas_code_refine"><span class="command">lemma</span></span> find_fas_code_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">eq</span><span class="main">,</span><span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>find_fas_code <span class="free">eq</span> <span class="free">bhc</span> <span class="free">sz</span> <span class="free">Gi</span><span class="main">)</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free">V</span><span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="main">(</span>prod_bhc <span class="free">bhc</span> <span class="free">bhc</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>find_fas <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> find_fas_code.refine<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_fas_impl_refine
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Declare this algorithm to Autoref:›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> find_fas_code_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bhc</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">RR</span> <span class="main">≡</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">V</span><span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span><span class="free">V</span><span class="main">⟩</span>ahs_rel <span class="main">(</span>prod_bhc <span class="free">bhc</span> <span class="free">bhc</span><span class="main">)</span><span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BHC<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">eq</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VDS<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>RETURN <span class="main">(</span>find_fas_code <span class="free">eq</span> <span class="free">bhc</span> <span class="free">sz</span> <span class="free">Gi</span><span class="main">)</span><span class="main">,</span>
    <span class="main">(</span><span class="keyword1">OP</span> find_fas 
      <span class="main">:::</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="free">RR</span><span class="main">)</span><span class="main">$</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="free">RR</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> RR_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_fas_code_refine<span class="main">)</span>  

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Feedback Arc Set with Initialization›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This algorithm extends a given set to a feedback arc set. It works in two steps:
  <span class="antiquoted"><span class="antiquoted">▸</span></span> Determine set of reachable nodes
  <span class="antiquoted"><span class="antiquoted">▸</span></span> Construct feedback arc set for graph without initial set
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_fas_init</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">find_fas_init</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">FI</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
    ASSERT <span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">nodes</span> <span class="main">=</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
    <span class="bound">fas</span> <span class="main">←</span> find_fas <span class="main">⦇</span> g_V <span class="main">=</span> g_V <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">,</span> g_E <span class="main">=</span> g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">FI</span></span></span><span class="main">,</span> g_V0 <span class="main">=</span> <span class="bound">nodes</span> <span class="main">⦈</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="free"><span class="bound"><span class="entity">FI</span></span></span> <span class="main">∪</span> <span class="bound">fas</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The abstract idea:
  To find a feedback arc set that contains some set F2,
  we can find a feedback arc set for the graph with F2 removed,
  and then join with F2.
›</span></span>
<span class="keyword1" id="Feedback_Arcs-is_fas_join"><span class="command">lemma</span></span> is_fas_join<span class="main">:</span> <span class="quoted"><span class="quoted">"is_fas <span class="free">G</span> <span class="main">(</span><span class="free">F1</span> <span class="main">∪</span> <span class="free">F2</span><span class="main">)</span> <span class="main">⟷</span>
  is_fas <span class="main">⦇</span> g_V <span class="main">=</span> g_V <span class="free">G</span><span class="main">,</span> g_E <span class="main">=</span> g_E <span class="free">G</span> <span class="main">-</span> <span class="free">F2</span><span class="main">,</span> g_V0 <span class="main">=</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span> <span class="main">⦈</span> <span class="free">F1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_fas_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_diff_diff_left Un_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ImageI rtrancl_trans subsetCE rtrancl_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"g_E <span class="free">G</span> <span class="main">-</span> <span class="free">F2</span>"</span></span> <span class="quoted"><span class="quoted">"g_E <span class="free">G</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> Diff_subset<span class="main"><span class="main">]</span></span><span class="main">)</span> 

<span class="keyword1" id="Feedback_Arcs-graphI_init"><span class="command">lemma</span></span> graphI_init<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">⦇</span> g_V <span class="main">=</span> g_V <span class="free">G</span><span class="main">,</span> g_E <span class="main">=</span> g_E <span class="free">G</span> <span class="main">-</span> <span class="free">FI</span><span class="main">,</span> g_V0 <span class="main">=</span> <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span> <span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> reachable_V <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">using</span></span> E_ss <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Feedback_Arcs-find_fas_init_correct"><span class="command">lemma</span></span> find_fas_init_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_fas_init <span class="free">G</span> <span class="free">FI</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">fas</span><span class="main">.</span> is_fas <span class="free">G</span> <span class="bound">fas</span> <span class="main">∧</span> <span class="free">FI</span> <span class="main">⊆</span> <span class="bound">fas</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_fas_init_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_fas_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> graphI_init<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset Image_closed_trancl reachable_mono 
    rtrancl_image_unfold_right rtrancl_reflcl rtrancl_trancl_reflcl 
    trancl_rtrancl_absorb<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_fas_join<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?F2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">FI</span></span><span class="main"><span class="main">]</span></span> Un_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1" id="Feedback_Arcs-gen_cast_set"><span class="command">lemma</span></span> gen_cast_set<span class="main">[</span><span class="operator">autoref_rules_raw</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">PRIO_TAG_GEN_ALGO</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INS<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">ins</span> Set.insert <span class="main">(</span><span class="free">Rk</span><span class="main">→</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs2</span><span class="main">→</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EM<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">emp</span> <span class="main">{}</span> <span class="main">(</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IT<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_set_to_list <span class="free">Rk</span> <span class="free">Rs1</span> <span class="free">tsl</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> gen_union <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> foldli <span class="main">(</span><span class="free">tsl</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">ins</span> <span class="bound">s</span> <span class="free">emp</span><span class="main">,</span>CAST<span class="main">)</span> 
    <span class="main">∈</span> <span class="main">(</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs1</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> GEN_OP_D<span class="main">[</span><span class="operator">OF</span> INS<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> GEN_OP_D<span class="main">[</span><span class="operator">OF</span> EM<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span> <span class="main">=</span> SIDE_GEN_ALGO_D<span class="main">[</span><span class="operator">OF</span> IT<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"CAST <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">∪</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> 1
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">autoref</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Feedback_Arcs-gen_cast_fun_set_rel"><span class="command">lemma</span></span> gen_cast_fun_set_rel<span class="main">[</span><span class="operator">autoref_rules_raw</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INS<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">mem</span> <span class="main">(∈)</span> <span class="main">(</span><span class="free">Rk</span><span class="main">→</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">→</span>bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="bound">x</span><span class="main">.</span> <span class="free">mem</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">,</span>CAST<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="main">⟨</span><span class="free">Rk</span><span class="main">⟩</span>fun_set_rel<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="bound">s</span><span class="main">,</span>CAST <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> br Collect <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> br_def<span class="main">)</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_set_rel_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> A<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> INS<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>  


<span class="keyword1" id="Feedback_Arcs-find_fas_init_impl_aux_unfolds"><span class="command">lemma</span></span> find_fas_init_impl_aux_unfolds<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Let <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">V0</span><span class="main">)</span> <span class="main">=</span> Let <span class="main">(</span>CAST <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">V0</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> RETURN <span class="main">(</span><span class="free">FI</span> <span class="main">∪</span> <span class="bound">S</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> RETURN <span class="main">(</span><span class="free">FI</span> <span class="main">∪</span> CAST <span class="bound">S</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">schematic_goal</span></span> find_fas_init_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bhc</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">eq</span><span class="main">,</span><span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">FIi</span><span class="main">,</span><span class="free">FI</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">V</span><span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span><span class="free">V</span><span class="main">⟩</span>fun_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">)</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>find_fas_init <span class="free">G</span> <span class="free">FI</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_fas_init_def
  <span class="keyword1"><span class="command">unfolding</span></span> find_fas_init_impl_aux_unfolds
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_fas_init_code</span> <span class="keyword2"><span class="keyword">for</span></span> eq bhc sz Gi FIi
  <span class="keyword2"><span class="keyword">uses</span></span> find_fas_init_impl
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_fas_init_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following theorem declares our implementation to Autoref:›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> find_fas_init_code_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bhc</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">RR</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">V</span><span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span><span class="free">V</span><span class="main">⟩</span>fun_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_bounded_hashcode <span class="free">V</span> <span class="free">eq</span> <span class="free">bhc</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">eq</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> <span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span> <span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">sz</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">Gi</span> <span class="bound">FIi</span><span class="main">.</span> RETURN <span class="main">(</span>find_fas_init_code <span class="free">eq</span> <span class="free">bhc</span> <span class="free">sz</span> <span class="bound">Gi</span> <span class="bound">FIi</span><span class="main">)</span><span class="main">,</span>find_fas_init<span class="main">)</span> 
    <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="free">RR</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">RR</span><span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> RR_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_fas_init_code.refine<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Conclusion›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We have defined an algorithm to find a feedback arc set, and one to 
  extend a given set to a feedback arc set. We have registered them to Autoref
  as implementations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> find_fas<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> find_fas_init<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  For preliminary refinement steps, you need the theorems  
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] find_fas_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] find_fas_init_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">thm</span></span> find_fas_code_autoref find_fas_init_code_autoref
<span class="keyword1"><span class="command">thm</span></span> find_fas_correct <span class="keyword1"><span class="command">thm</span></span> find_fas_init_correct


<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Nested_DFS">
<div class="head">
<h1>Theory Nested_DFS</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Nested DFS›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Nested_DFS
<span class="keyword2"><span class="keyword">imports</span></span> <a href="DFS_Find_Path.html">DFS_Find_Path</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Nested DFS is a standard method for Buchi-Automaton emptiness check.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas›</span></span>

<span class="keyword1" id="Nested_DFS-closed_restrict_aux"><span class="command">lemma</span></span> closed_restrict_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main">``</span><span class="free">F</span> <span class="main">⊆</span> <span class="free">F</span> <span class="main">∪</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> NR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U</span> <span class="main">∩</span> <span class="free">S</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">U</span> <span class="main">⊆</span> <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U</span> <span class="main">⊆</span> <span class="free">F</span>"</span></span>
  <span class="comment1">― ‹Auxiliary lemma to show that nodes reachable from a finished node must  
      be finished if, additionally, no stack node is reachable›</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarify</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">U</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">∩</span> <span class="free">S</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">F</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> NR SS <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span> M <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">F</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> CL <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtrancl_Image_advance_ss<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of the Framework›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> blue_dfs_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> state"</span></span> <span class="main">+</span>
  lasso <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span> list<span class="main">)</span> option"</span></span> <span class="comment1">(* pr × pl *)</span>
  red  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> blue_dfs_param <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> blue_dfs_state_ext<span class="main">)</span> parameterization"</span></span>

<span class="keyword1" id="Nested_DFS-lasso_more_cong"><span class="command">lemma</span></span> lasso_more_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> lasso <span class="free">s</span> <span class="main">=</span> lasso <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1" id="Nested_DFS-red_more_cong"><span class="command">lemma</span></span> red_more_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> red <span class="free">s</span> <span class="main">=</span> red <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⦇</span> state.more <span class="main">:=</span> <span class="main">⦇</span> lasso <span class="main">=</span> <span class="free">foo</span><span class="main">,</span> red <span class="main">=</span> <span class="free">bar</span> <span class="main">⦈</span> <span class="main">⦈</span> <span class="main">=</span> <span class="free">s</span> <span class="main">⦇</span> lasso <span class="main">:=</span> <span class="free">foo</span><span class="main">,</span> red <span class="main">:=</span> <span class="free">bar</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">dropWhileNot</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">takeWhileNot</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> BlueDFS_defs <span class="main">=</span> graph_defs <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">accpt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">blue</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">-</span> red <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyan</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> set <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">white</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">-</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">red_dfs</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> find_path1_restr_spec <span class="main">(</span><span class="free">G</span> <span class="main">⦇</span> g_V0 <span class="main">:=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mk_blue_witness</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> blue_dfs_state <span class="main">⇒</span> <span class="tfree">'v</span> fpr_result <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> blue_dfs_state_ext"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mk_blue_witness</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">redS</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">redS</span></span></span> <span class="keyword1">of</span>
                 Inl <span class="bound">R'</span> <span class="main">⇒</span> <span class="main">⦇</span> lasso <span class="main">=</span> None<span class="main">,</span> red <span class="main">=</span> <span class="main">(</span><span class="bound">R'</span> <span class="comment1">⌦‹∪ red s›</span><span class="main">)</span> <span class="main">⦈</span>
               <span class="main">|</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">rs</span> <span class="main">=</span> rev <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">in</span> 
                             <span class="main">⦇</span> lasso <span class="main">=</span> Some <span class="main">(</span><span class="bound">rs</span><span class="main">,</span> <span class="bound">vs</span><span class="main">@</span>dropWhileNot <span class="bound">v</span> <span class="bound">rs</span><span class="main">)</span><span class="main">,</span> red <span class="main">=</span> red <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">run_red_dfs</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> blue_dfs_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> blue_dfs_state_ext nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">run_red_dfs</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> lasso <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
             <span class="bound">redS</span> <span class="main">←</span> red_dfs <span class="main">(</span>red <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> cyan <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
             RETURN <span class="main">(</span>mk_blue_witness <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">redS</span><span class="main">)</span>
           <span class="main">}</span>
          <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> NOOP <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Schwoon-Esparza extension ›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">se_back_edge</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> lasso <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> 
      <span class="comment1">― ‹it's a back edge, so <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>u›</span></span> and <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>v›</span></span> are both on stack›</span>
      <span class="comment1">― ‹we differentiate whether <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>u›</span></span> or <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>v›</span></span> is the 'culprit'›</span>
      <span class="comment1">― ‹to generate a better counter example›</span>
      <span class="keyword1">if</span> <span class="free">accpt</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">then</span>
         <span class="keyword1">let</span> <span class="bound">rs</span> <span class="main">=</span> rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
             <span class="bound">ur</span> <span class="main">=</span> <span class="bound">rs</span><span class="main">;</span>
             <span class="bound">ul</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">#</span>dropWhileNot <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">rs</span>
         <span class="keyword1">in</span> RETURN <span class="main">⦇</span>lasso <span class="main">=</span> Some <span class="main">(</span><span class="bound">ur</span><span class="main">,</span><span class="bound">ul</span><span class="main">)</span><span class="main">,</span> red <span class="main">=</span> red <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>
      <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">accpt</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span>
         <span class="keyword1">let</span> <span class="bound">rs</span> <span class="main">=</span> rev <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">;</span>
             <span class="bound">vr</span> <span class="main">=</span> takeWhileNot <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">rs</span><span class="main">;</span>
             <span class="bound">vl</span> <span class="main">=</span> dropWhileNot <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">rs</span>
         <span class="keyword1">in</span> RETURN <span class="main">⦇</span>lasso <span class="main">=</span> Some <span class="main">(</span><span class="bound">vr</span><span class="main">,</span><span class="bound">vl</span><span class="main">)</span><span class="main">,</span> red <span class="main">=</span> red <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>
      <span class="keyword1">else</span> NOOP <span class="free"><span class="bound"><span class="entity">s</span></span></span>
  <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> NOOP <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">blue_dfs_params</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> blue_dfs_param"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">blue_dfs_params</span> <span class="main">=</span> <span class="main">⦇</span>
    on_init <span class="main">=</span> RETURN <span class="main">⦇</span> lasso <span class="main">=</span> None<span class="main">,</span> red <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">,</span>
    on_new_root <span class="main">=</span> <span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> NOOP <span class="bound">s</span><span class="main">,</span>
    on_discover <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> NOOP <span class="bound">s</span><span class="main">,</span>
    on_finish <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">accpt</span> <span class="bound">u</span> <span class="keyword1">then</span> run_red_dfs <span class="bound">u</span> <span class="bound">s</span> <span class="keyword1">else</span> NOOP <span class="bound">s</span><span class="main">,</span>
    on_back_edge <span class="main">=</span> se_back_edge<span class="main">,</span>
    on_cross_edge <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> NOOP <span class="bound">s</span><span class="main">,</span>
    is_break <span class="main">=</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> lasso <span class="bound">s</span> <span class="main">≠</span> None <span class="main">⦈</span>"</span></span>
  
  <span class="keyword1"><span class="command">schematic_goal</span></span> blue_dfs_params_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"on_init blue_dfs_params <span class="main">=</span> <span class="var">?OI</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_new_root blue_dfs_params <span class="main">=</span> <span class="var">?ONR</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_discover blue_dfs_params <span class="main">=</span> <span class="var">?OD</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_finish blue_dfs_params <span class="main">=</span> <span class="var">?OF</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_back_edge blue_dfs_params <span class="main">=</span> <span class="var">?OBE</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_cross_edge blue_dfs_params <span class="main">=</span> <span class="var">?OCE</span>"</span></span>
    <span class="quoted"><span class="quoted">"is_break blue_dfs_params <span class="main">=</span> <span class="var">?IB</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> blue_dfs_params_def gen_parameterization.simps
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>


  <span class="keyword1"><span class="command">sublocale</span></span> param_DFS_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">blue_dfs_params</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> BlueDFS <span class="main">=</span> BlueDFS_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">accpt</span></span> <span class="main">+</span> param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">blue_dfs_params</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">accpt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> bool"</span></span>

<span class="keyword1" id="Nested_DFS-BlueDFSI"><span class="command">lemma</span></span> BlueDFSI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BlueDFS <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">locale</span></span> BlueDFS_invar <span class="main">=</span> BlueDFS <span class="main">+</span>
  DFS_invar <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted">blue_dfs_params</span>

<span class="keyword1"><span class="command">context</span></span> BlueDFS_defs <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Nested_DFS-BlueDFS_invar_eq"><span class="command">lemma</span></span> BlueDFS_invar_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="free">s</span> <span class="main">⟷</span> BlueDFS_invar <span class="free">G</span> <span class="free">accpt</span> <span class="free">s</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted">blue_dfs_params</span> <span class="quoted"><span class="free">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"BlueDFS_invar <span class="free">G</span> <span class="free">accpt</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"BlueDFS_invar <span class="free">G</span> <span class="free">accpt</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> BlueDFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">accpt</span></span> <span class="quoted"><span class="free">s</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>
<span class="keyword1"><span class="command">context</span></span> BlueDFS <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">blue_basic_invar</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">case</span> lasso <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> restr_invar E <span class="main">(</span>red <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span> 
        <span class="main">∧</span> red <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
    <span class="main">|</span> Some <span class="bound">l</span> <span class="main">⇒</span> True"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> BlueDFS_invar<span class="main">)</span> red_DFS_precond_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BI<span class="main">:</span> <span class="quoted"><span class="quoted">"blue_basic_invar <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lasso <span class="free">s</span> <span class="main">=</span> None"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> SNE<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span>
      <span class="quoted"><span class="quoted">"fb_graph <span class="main">(</span><span class="free">G</span> <span class="main">⦇</span> g_V0 <span class="main">:=</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="main">(</span><span class="free">G</span> <span class="main">⦇</span> g_E <span class="main">:=</span> E <span class="main">∩</span> UNIV <span class="main">×</span> <span class="main">-</span> red <span class="free">s</span><span class="main">,</span> g_V0 <span class="main">:=</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"restr_invar E <span class="main">(</span>red <span class="free">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_reachable <span class="quoted"><span class="quoted">‹stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> fb_graph_subset<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_reachable <span class="quoted"><span class="quoted">‹stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> fb_graph_subset<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command">using</span></span> BI <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> blue_basic_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> BlueDFS_invar<span class="main">)</span> red_dfs_pres_bbi<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BI<span class="main">:</span> <span class="quoted"><span class="quoted">"blue_basic_invar <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lasso <span class="free">s</span> <span class="main">=</span> None"</span></span> <span class="keyword2"><span class="keyword">and</span></span> SNE<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"run_red_dfs <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>finish <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span>
      SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">e</span><span class="main">.</span> 
        DFS_invar <span class="free">G</span> blue_dfs_params <span class="main">(</span>finish <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span> 
        <span class="main">⟶</span> blue_basic_invar <span class="main">(</span>finish <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> cyan <span class="main">(</span>finish <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> finish_def cyan_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> run_red_dfs_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">fp1</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">=</span> finish <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> FP_spec<span class="main">:</span> 
        <span class="quoted"><span class="quoted">"find_path1_restr_pred <span class="main">(</span><span class="free">G</span> <span class="main">⦇</span> g_V0 <span class="main">:=</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>red <span class="free">s</span><span class="main">)</span> <span class="skolem">fp1</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"BlueDFS_invar <span class="free">G</span> <span class="free">accpt</span> <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> mk_blue_witness <span class="skolem">s'</span> <span class="skolem">fp1</span><span class="main">⦈</span><span class="main">)</span>"</span></span>      
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> i<span class="main">:</span> BlueDFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">accpt</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> mk_blue_witness <span class="skolem">s'</span> <span class="skolem">fp1</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
        <span class="quoted"><span class="quoted">"red <span class="skolem">s'</span> <span class="main">=</span> red <span class="free">s</span>"</span></span> 
        <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> discovered <span class="free">s</span>"</span></span> 
        <span class="quoted"><span class="quoted">"dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> s'_def finish_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R'</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fp1</span> <span class="main">=</span> Inl <span class="skolem">R'</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> FP_spec<span class="main">[</span><span class="operator">unfolded</span> find_path1_restr_pred_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> 
        <span class="keyword1"><span class="command">have</span></span> 
          R'FMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">R'</span> <span class="main">=</span> red <span class="free">s</span> <span class="main">∪</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> RI<span class="main">:</span> <span class="quoted"><span class="quoted">"restr_invar E <span class="skolem">R'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword1"><span class="command">from</span></span> BI <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"red <span class="free">s</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> blue_basic_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> ImageE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>

          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trancl_unfold_left<span class="main">)</span>

          <span class="keyword1"><span class="command">from</span></span> RI <span class="keyword1"><span class="command">have</span></span> NR<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">}</span> <span class="main">∩</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> restr_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R'FMT<span class="main">)</span>

          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> i.finished_closed<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E›</span></span> 
          <span class="keyword1"><span class="command">have</span></span> UID<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stack_set_def<span class="main">)</span>

          <span class="keyword1"><span class="command">from</span></span> NR <span class="quoted"><span class="quoted">‹<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="keyword1"><span class="command">have</span></span> NR'<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">∩</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trancl_unfold_left<span class="main">)</span>

          <span class="keyword1"><span class="command">have</span></span> CL<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">``</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> finished_closed discovered_eq_finished_un_stack
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

          <span class="keyword1"><span class="command">from</span></span> closed_restrict_aux<span class="main">[</span><span class="operator">OF</span> CL NR'<span class="main">]</span> UID 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span>  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>sup_least<span class="main">)</span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R'</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> red <span class="free">s</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R'FMT<span class="main">)</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux1 <span class="main">=</span> this

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"blue_basic_invar <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> mk_blue_witness <span class="skolem">s'</span> <span class="skolem">fp1</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> blue_basic_invar_def mk_blue_witness_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits sum.splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>

        <span class="keyword1"><span class="command">using</span></span> FP_spec SNE
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s'_def blue_basic_invar_def find_path1_restr_pred_def
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_invar_def
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> aux1<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Nested_DFS-blue_basic_invar"><span class="command">lemma</span></span> blue_basic_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar blue_basic_invar"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> BlueDFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> cyan <span class="main">(</span>finish <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> finish_def cyan_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> red_dfs_pres_bbi<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_invar_def blue_basic_invar_def neq_Nil_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> blue_basic_invar_def cond_def se_back_edge_def
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restr_invar_def empty_state_def pred_defs
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> DFS_invar.discovered_eq_finished_un_stack
            <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> BlueDFS_invar_eq
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> BlueDFS_invar<span class="main">)</span> s_blue_basic_invar 
    <span class="main">=</span> blue_basic_invar<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> BlueDFS_invar<span class="main">)</span> red_DFS_precond 
    <span class="main">=</span> red_DFS_precond_aux<span class="main">[</span><span class="operator">OF</span> s_blue_basic_invar<span class="main">]</span>

  <span class="keyword1"><span class="command">sublocale</span></span> DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">blue_dfs_params</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>  se_back_edge_def run_red_dfs_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pre_on_defs
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
    
    <span class="keyword1"><span class="command">unfolding</span></span> nofail_SPEC_iff
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> BlueDFS_invar.red_DFS_precond<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cyan_def finish_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> BlueDFS_invar.red_DFS_precond<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TrueI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> BlueDFS_invar
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lasso <span class="free">s</span> <span class="main">=</span> None"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1" id="Nested_DFS-red_closed"><span class="command">lemma</span></span> red_closed<span class="main">:</span>
      <span class="quoted"><span class="quoted">"E <span class="main">``</span> red <span class="free">s</span> <span class="main">⊆</span> red <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> s_blue_basic_invar
      <span class="keyword1"><span class="command">unfolding</span></span> blue_basic_invar_def restr_invar_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
    <span class="keyword1" id="Nested_DFS-red_stack_disjoint"><span class="command">lemma</span></span> red_stack_disjoint<span class="main">:</span>
      <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∩</span> red <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> s_blue_basic_invar
      <span class="keyword1"><span class="command">unfolding</span></span> blue_basic_invar_def restr_invar_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword1" id="Nested_DFS-red_finished"><span class="command">lemma</span></span> red_finished<span class="main">:</span> <span class="quoted"><span class="quoted">"red <span class="free">s</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> s_blue_basic_invar
      <span class="keyword1"><span class="command">unfolding</span></span> blue_basic_invar_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="comment1">(* Play of Colors *)</span>
    <span class="keyword1" id="Nested_DFS-all_nodes_colored"><span class="command">lemma</span></span> all_nodes_colored<span class="main">:</span> <span class="quoted"><span class="quoted">"white <span class="free">s</span> <span class="main">∪</span> blue <span class="free">s</span> <span class="main">∪</span> cyan <span class="free">s</span> <span class="main">∪</span> red <span class="free">s</span> <span class="main">=</span> UNIV "</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> white_def blue_def cyan_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stack_set_def<span class="main">)</span>

    <span class="keyword1" id="Nested_DFS-colors_disjoint"><span class="command">lemma</span></span> colors_disjoint<span class="main">:</span>
      <span class="quoted"><span class="quoted">"white <span class="free">s</span> <span class="main">∩</span> <span class="main">(</span>blue <span class="free">s</span> <span class="main">∪</span> cyan <span class="free">s</span> <span class="main">∪</span> red <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="quoted"><span class="quoted">"blue <span class="free">s</span> <span class="main">∩</span> <span class="main">(</span>white <span class="free">s</span> <span class="main">∪</span> cyan <span class="free">s</span> <span class="main">∪</span> red <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="quoted"><span class="quoted">"cyan <span class="free">s</span> <span class="main">∩</span> <span class="main">(</span>white <span class="free">s</span> <span class="main">∪</span> blue <span class="free">s</span> <span class="main">∪</span> red <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="quoted"><span class="quoted">"red <span class="free">s</span> <span class="main">∩</span> <span class="main">(</span>white <span class="free">s</span> <span class="main">∪</span> blue <span class="free">s</span> <span class="main">∪</span> cyan <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> white_def blue_def cyan_def
      <span class="keyword1"><span class="command">using</span></span> finished_discovered red_finished
      <span class="keyword1"><span class="command">unfolding</span></span> stack_set_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> BlueDFS<span class="main">)</span> i_no_accpt_cyle_in_finish<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> lasso <span class="bound">s</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">accpt</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> BlueDFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?onstack</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rE</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rel_restrict E <span class="main">(</span>red <span class="skolem">s</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sh</span></span> <span class="skolem"><span class="skolem">st</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">=</span> <span class="skolem">sh</span><span class="main">#</span><span class="skolem">st</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"g_E <span class="main">(</span><span class="free">G</span> <span class="main">⦇</span> g_V0 <span class="main">:=</span> <span class="main">{</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">{</span></span> <span class="comment1">(* TODO/FIXME: Ughly proof structure! *)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R'</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">R'</span> <span class="comment1">⌦‹∪ red s›</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span> lasso <span class="main">:=</span> None<span class="main">,</span> red <span class="main">:=</span> <span class="var">?R'</span><span class="main">⦈</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rE</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⟹</span> <span class="main">¬</span> <span class="var">?onstack</span> <span class="bound">v</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> accpt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> NL<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lasso <span class="skolem">s</span> <span class="main">=</span> None"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> no_hd_cycle<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∉</span> <span class="var">?rE</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∉</span> red <span class="skolem">s</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> red_stack_disjoint
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∉</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> no_hd_cycle rel_restrict_tranclI red_closed<span class="main">[</span><span class="operator">OF</span> NL<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span> 
      <span class="keyword1"><span class="command">with</span></span> accpt finish <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">accpt</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">with</span></span> finish <span class="keyword1"><span class="command">have</span></span>
      <span class="quoted"><span class="quoted">"red_dfs <span class="main">(</span>red <span class="skolem">s</span><span class="main">)</span> <span class="var">?onstack</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>
         <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">R</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> Inl <span class="bound">R</span> <span class="main">⟶</span>
             DFS_invar <span class="free">G</span> blue_dfs_params <span class="main">(</span>lasso_update Map.empty <span class="skolem">s'</span><span class="main">⦇</span>red <span class="main">:=</span> <span class="bound">R</span> <span class="comment1">⌦‹∪ red s›</span><span class="main">⦈</span><span class="main">)</span> <span class="main">⟶</span>
             <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">accpt</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">∈</span>dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> find_path1_restr_spec_rule<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> red_DFS_precond<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> 1
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> red_DFS_precond<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> find_path1_restr_pred_def restr_invar_def<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">note</span></span> aux <span class="main">=</span> leof_trans<span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">,</span></span><span class="operator">THEN</span> leof_lift<span class="main"><span class="main">]</span></span><span class="main">]</span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine_vcg</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">=</span> find_path1_restr_spec_rule

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main">)</span>
        <span class="keyword1"><span class="command">unfolding</span></span> run_red_dfs_def mk_blue_witness_def cyan_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> aux<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> back_edge <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> se_back_edge_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

  <span class="keyword1" id="Nested_DFS-no_accpt_cycle_in_finish"><span class="command">lemma</span></span> no_accpt_cycle_in_finish<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>lasso <span class="free">s</span> <span class="main">=</span> None<span class="main">;</span> <span class="free">accpt</span> <span class="free">v</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∉</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i_no_accpt_cyle_in_finish<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> BlueDFS
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">lasso_inv</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">lasso_inv</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">pr</span> <span class="bound">pl</span><span class="main">.</span> lasso <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span> <span class="main">⟶</span> 
                                      <span class="bound">pl</span> <span class="main">≠</span> <span class="main">[]</span>
                                    <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="bound">pr</span> <span class="main">(</span>hd <span class="bound">pl</span><span class="main">)</span><span class="main">)</span> 
                                    <span class="main">∧</span> <span class="free">accpt</span> <span class="main">(</span>hd <span class="bound">pl</span><span class="main">)</span> 
                                    <span class="main">∧</span> path E <span class="main">(</span>hd <span class="bound">pl</span><span class="main">)</span> <span class="bound">pl</span> <span class="main">(</span>hd <span class="bound">pl</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> BlueDFS_invar<span class="main">)</span> se_back_edge_lasso_inv<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> b_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"lasso_inv <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"lasso <span class="free">s</span> <span class="main">=</span> None"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> p<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> pending <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> s'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span> <span class="main">=</span> back_edge <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span> <span class="main">(</span><span class="free">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"se_back_edge <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span> <span class="free">s'</span>
                <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">e</span><span class="main">.</span> DFS_invar <span class="free">G</span> blue_dfs_params <span class="main">(</span><span class="free">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span> <span class="main">⟶</span>
                            lasso_inv <span class="main">(</span><span class="free">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="bound">e</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

    <span class="keyword1"><span class="command">from</span></span> v stack_set_def <span class="keyword1"><span class="command">have</span></span> v_in<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> uv_edg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pendingD<span class="main">)</span>
  
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> accpt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ur</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ul</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">#</span>dropWhileNot <span class="free">v</span> <span class="main">(</span>rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">⦇</span>lasso <span class="main">:=</span> Some <span class="main">(</span><span class="var">?ur</span><span class="main">,</span> <span class="var">?ul</span><span class="main">)</span><span class="main">,</span> red <span class="main">:=</span> red <span class="free">s</span><span class="main">⦈</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="var">?s</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span> <span class="main">=</span> stack <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s'<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> hd_ul<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="var">?ul</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ul</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> P<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="var">?ur</span> <span class="main">(</span>hd <span class="var">?ul</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> stack_is_path<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> accpt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="var">?ul</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="var">?ul</span><span class="main">)</span> <span class="var">?ul</span> <span class="main">(</span>hd <span class="var">?ul</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True 
        <span class="keyword1"><span class="command">with</span></span> distinct_hd_tl stack_distinct <span class="keyword1"><span class="command">have</span></span> ul<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?ul</span> <span class="main">=</span> <span class="main">[</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">]</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">from</span></span> True uv_edg <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> ul<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path1<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> v_in ne <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="var">?ur</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> P <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_prepend 
                           dropWhileNot_path<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?ur</span>"</span></span><span class="main"><span class="main">]</span></span>
                           uv_edg<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lasso_inv <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> accpt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?vr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"takeWhileNot <span class="free">v</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?vl</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"dropWhileNot <span class="free">v</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">⦇</span>lasso <span class="main">:=</span> Some<span class="main">(</span><span class="var">?vr</span><span class="main">,</span> <span class="var">?vl</span><span class="main">)</span><span class="main">,</span> red <span class="main">:=</span> red <span class="free">s</span><span class="main">⦈</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="var">?s</span>"</span></span>
      
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span> <span class="main">=</span> stack <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s'<span class="main">)</span>
      
      <span class="keyword1"><span class="command">from</span></span> ne v_in <span class="keyword1"><span class="command">have</span></span> hd_vl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="var">?vl</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="main"><span class="main">(</span></span><span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_nonempty_induct<span class="main">)</span> <span class="operator">auto</span>
      
      <span class="keyword1"><span class="command">from</span></span> v_in <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?vl</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> hd_succ_stack_is_path<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> uv_edg <span class="keyword1"><span class="command">have</span></span> 
        P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> ne v_in <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="var">?vr</span> <span class="main">(</span>hd <span class="var">?vl</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> takeWhileNot_path<span class="main">)</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> accpt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="var">?vl</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> P ne v_in <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="var">?vl</span><span class="main">)</span> <span class="var">?vl</span> <span class="main">(</span>hd <span class="var">?vl</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> dropWhileNot_path<span class="main">)</span>

      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lasso_inv <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">accpt</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">accpt</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> state.more <span class="free">s'</span><span class="main">⦈</span>"</span></span>
      
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="var">?s</span>"</span></span>
      
      <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lasso_inv <span class="var">?s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="comment1">(* TODO: Clean up this proof, separate logical arguments from framework 
      boilerplate! *)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> R s'
      <span class="keyword1"><span class="command">unfolding</span></span> se_back_edge_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1" id="Nested_DFS-lasso_inv"><span class="command">lemma</span></span> lasso_inv<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar lasso_inv"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> BlueDFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="comment1">(* TODO/FIXME: Ughly proof structure *)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?onstack</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rE</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rel_restrict E <span class="main">(</span>red <span class="skolem">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?revs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rev <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    
    <span class="keyword1"><span class="command">note</span></span> ne <span class="main">=</span> <span class="quoted"><span class="quoted">‹stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">=</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>›</span></span>

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s'</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"red <span class="skolem">s'</span> <span class="main">=</span> red <span class="skolem">s</span>"</span></span>
      <span class="quoted"><span class="quoted">"lasso <span class="skolem">s'</span> <span class="main">=</span> lasso <span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>


    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">vs</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cyc</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">vs</span> <span class="main">@</span> dropWhileNot <span class="skolem">v</span> <span class="var">?revs</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>lasso <span class="main">:=</span> Some <span class="main">(</span><span class="var">?revs</span><span class="main">,</span> <span class="var">?cyc</span><span class="main">)</span><span class="main">,</span> red <span class="main">:=</span> red <span class="skolem">s</span><span class="main">⦈</span>"</span></span>
      
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> blue_dfs_params <span class="var">?s</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> vs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?rE</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?onstack</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> accpt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> vs <span class="keyword1"><span class="command">have</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> path_mono rel_restrict_sub<span class="main">)</span>
      
      <span class="keyword1"><span class="command">have</span></span> hds<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="skolem">vs</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"hd <span class="var">?cyc</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> vs path_hd
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      
      <span class="keyword1"><span class="command">from</span></span> vs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cyc</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> P0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="var">?revs</span> <span class="main">(</span>hd <span class="var">?cyc</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> stack_is_path<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> accpt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="var">?cyc</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="var">?cyc</span><span class="main">)</span> <span class="var">?cyc</span> <span class="main">(</span>hd <span class="var">?cyc</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> ne last_stack_in_V0 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">v0</span><span class="main">]</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> v True finish <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">v0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        
        <span class="keyword1"><span class="command">from</span></span> True P <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> tl_ne <span class="main">=</span> this

        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="var">?revs</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> ne stack_distinct <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cyc</span> <span class="main">=</span> <span class="skolem">vs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
          <span class="keyword1"><span class="command">with</span></span> P True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> dropWhile_eq_Nil_conv<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> finish v <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="var">?revs</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> tl_ne False P0  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_conc<span class="main"><span class="main">[</span></span><span class="operator">OF</span> P<span class="main"><span class="main">]</span></span> 
                dropWhileNot_path<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?revs</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lasso_inv <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> lasso <span class="skolem">s</span> <span class="main">=</span> None <span class="main">⟶</span>
            red_dfs <span class="main">(</span>red <span class="skolem">s</span><span class="main">)</span> <span class="var">?onstack</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">rs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">vs</span> <span class="bound">v</span><span class="main">.</span> 
                <span class="bound">rs</span> <span class="main">=</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⟶</span>
                  DFS_invar <span class="free">G</span> blue_dfs_params <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>lasso <span class="main">:=</span> Some <span class="main">(</span><span class="var">?revs</span><span class="main">,</span> <span class="bound">vs</span> <span class="main">@</span> dropWhileNot <span class="bound">v</span> <span class="var">?revs</span><span class="main">)</span><span class="main">,</span> red<span class="main">:=</span> red <span class="skolem">s</span><span class="main">⦈</span><span class="main">)</span> <span class="main">⟶</span>
                   lasso_inv <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>lasso <span class="main">:=</span> Some <span class="main">(</span><span class="var">?revs</span><span class="main">,</span> <span class="bound">vs</span> <span class="main">@</span> dropWhileNot <span class="bound">v</span> <span class="var">?revs</span><span class="main">)</span><span class="main">,</span> red<span class="main">:=</span>red <span class="skolem">s</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> find_path1_restr_spec_rule<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> red_DFS_precond<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ne<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> red_DFS_precond<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ne<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> red_stack_disjoint ne

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rprems</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_path1_restr_pred_def restr_invar_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_restrict_tl rel_restrictI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">note</span></span> aux1 <span class="main">=</span> this<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">THEN</span> leof_lift<span class="main">]</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> run_red_dfs_def mk_blue_witness_def cyan_def

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_red_dfs_def mk_blue_witness_def cyan_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> leof_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> aux1<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> finish
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> BlueDFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">from</span></span> back_edge se_back_edge_lasso_inv<span class="main">[</span><span class="operator">THEN</span> leof_lift<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def empty_state_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> BlueDFS_invar
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> s_lasso_inv <span class="main">=</span> lasso_inv<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lasso <span class="free">s</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">pr</span><span class="main">,</span><span class="free">pl</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> loop_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pl</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> accpt_loop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="main">(</span>hd <span class="free">pl</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> loop_is_path<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="main">(</span>hd <span class="free">pl</span><span class="main">)</span> <span class="free">pl</span> <span class="main">(</span>hd <span class="free">pl</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> loop_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="free">pr</span> <span class="main">(</span>hd <span class="free">pl</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms s_lasso_inv
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_inv_def<span class="main">)</span>

  <span class="keyword1" id="Nested_DFS-blue_dfs_correct"><span class="command">lemma</span></span> blue_dfs_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> lasso <span class="free">s</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free">accpt</span> <span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> 
        path E <span class="bound">v0</span> <span class="bound">pr</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">accpt</span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">pl</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> path E <span class="bound">v</span> <span class="bound">pl</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lasso <span class="free">s</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">v0</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">accpt</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> reachable"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> nc_finished_eq_reachable NC None <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> no_accpt_cycle_in_finish None
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">prpl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> s_lasso_inv <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">prpl</span></span><span class="main">)</span> 
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_is_rtrancl path_is_trancl <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lasso_inv_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Interface›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> BlueDFS_defs <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="free">accpt</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">nested_dfs_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span>
  None <span class="main">⇒</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v0</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>
<span class="main">|</span> Some <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>g_V0 <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> 
    path <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">v0</span> <span class="bound">pr</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">pl</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> path <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">v</span> <span class="bound">pl</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">nested_dfs</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>lasso <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> nested_dfs_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nested_dfs <span class="free">G</span> <span class="free">accpt</span> <span class="main">≤</span> SPEC <span class="main">(</span>nested_dfs_spec <span class="free">G</span> <span class="free">accpt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> BlueDFS <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">accpt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> nested_dfs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> weaken_SPEC<span class="main"><span class="main">[</span></span><span class="operator">OF</span> it_dfs_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"BlueDFS_invar <span class="free">G</span> <span class="free">accpt</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> BlueDFS_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">accpt</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">.</span></span>
    
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>cond <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="free">accpt</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> blue_dfs_correct<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"nested_dfs_spec <span class="free">G</span> <span class="free">accpt</span> <span class="main">(</span>lasso <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> nested_dfs_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> bdfs_state_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> simple_state"</span></span> <span class="main">+</span>
  lasso_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span> list<span class="main">)</span> option"</span></span>
  red_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bdfs_erel</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="main">⦇</span>lasso_impl<span class="main">=</span><span class="bound">li</span><span class="main">,</span>red_impl<span class="main">=</span><span class="bound">ri</span><span class="main">⦈</span><span class="main">,</span><span class="main">⦇</span>lasso<span class="main">=</span><span class="bound">l</span><span class="main">,</span> red<span class="main">=</span><span class="bound">r</span><span class="main">⦈</span><span class="main">)</span> 
  <span class="main">|</span> <span class="bound">li</span> <span class="bound">ri</span> <span class="bound">l</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">li</span><span class="main">=</span><span class="bound">l</span> <span class="main">∧</span> <span class="bound">ri</span><span class="main">=</span><span class="bound">r</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">bdfs_rel</span> <span class="main">≡</span> <span class="main">⟨</span>bdfs_erel<span class="main">⟩</span>simple_state_rel"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mk_blue_witness_impl</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> bdfs_state_impl <span class="main">⇒</span> <span class="tfree">'v</span> fpr_result <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> bdfs_state_impl_ext"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mk_blue_witness_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">redS</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">redS</span></span></span> <span class="keyword1">of</span>
      Inl <span class="bound">R'</span> <span class="main">⇒</span> <span class="main">⦇</span> lasso_impl <span class="main">=</span> None<span class="main">,</span> red_impl <span class="main">=</span> <span class="main">(</span><span class="bound">R'</span> <span class="comment1">⌦‹∪ red_impl s›</span><span class="main">)</span> <span class="main">⦈</span>
    <span class="main">|</span> Inr <span class="main">(</span><span class="bound">vs</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">let</span> 
        <span class="bound">rs</span> <span class="main">=</span> rev <span class="main">(</span>map fst <span class="main">(</span>CAST <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
      <span class="keyword1">in</span> <span class="main">⦇</span> 
        lasso_impl <span class="main">=</span> Some <span class="main">(</span><span class="bound">rs</span><span class="main">,</span> <span class="bound">vs</span><span class="main">@</span>dropWhileNot <span class="bound">v</span> <span class="bound">rs</span><span class="main">)</span><span class="main">,</span> 
        red_impl <span class="main">=</span> red_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Nested_DFS-mk_blue_witness_impl"><span class="command">lemma</span></span> mk_blue_witness_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>bdfs_rel<span class="main">;</span> <span class="main">(</span><span class="free">ri</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">,</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">⟩</span>sum_rel <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">(</span>mk_blue_witness_impl <span class="free">si</span> <span class="free">ri</span><span class="main">,</span> mk_blue_witness <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">∈</span>bdfs_erel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mk_blue_witness_impl_def mk_blue_witness_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> introR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>Id<span class="main">⟩</span>list_rel"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def comp_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cyan_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> on_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
<span class="keyword1" id="Nested_DFS-cyan_impl"><span class="command">lemma</span></span> cyan_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>bdfs_rel<span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>cyan_impl <span class="free">si</span><span class="main">,</span> cyan <span class="free">s</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cyan_impl_def cyan_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">run_red_dfs_impl</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> bdfs_state_impl <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> bdfs_state_impl_ext nres"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">run_red_dfs_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> lasso_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
           <span class="bound">redS</span> <span class="main">←</span> red_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'more</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">(</span>red_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> cyan_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
           RETURN <span class="main">(</span>mk_blue_witness_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">redS</span><span class="main">)</span>
         <span class="main">}</span>
        <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RETURN <span class="main">(</span>simple_state.more <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Nested_DFS-run_red_dfs_impl"><span class="command">lemma</span></span> run_red_dfs_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">Gi</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>bdfs_rel<span class="main">⟧</span> 
    <span class="main">⟹</span> run_red_dfs_impl <span class="free">Gi</span> <span class="free">ui</span> <span class="free">si</span> <span class="main">≤</span><span class="main">⇓</span>bdfs_erel <span class="main">(</span>run_red_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free">G</span> <span class="free">u</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> run_red_dfs_impl_def run_red_dfs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> 
      <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def cyan_impl_def cyan_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">se_back_edge_impl</span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> lasso_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> 
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">then</span>
         <span class="keyword1">let</span> <span class="bound">rs</span> <span class="main">=</span> rev <span class="main">(</span>map fst <span class="main">(</span>tl <span class="main">(</span>CAST <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
             <span class="bound">ur</span> <span class="main">=</span> <span class="bound">rs</span><span class="main">;</span>
             <span class="bound">ul</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">#</span>dropWhileNot <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">rs</span>
         <span class="keyword1">in</span> RETURN <span class="main">⦇</span>lasso_impl <span class="main">=</span> Some <span class="main">(</span><span class="bound">ur</span><span class="main">,</span><span class="bound">ul</span><span class="main">)</span><span class="main">,</span> red_impl <span class="main">=</span> red_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>
      <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span>
         <span class="keyword1">let</span> <span class="bound">rs</span> <span class="main">=</span> rev <span class="main">(</span>map fst <span class="main">(</span>CAST <span class="main">(</span>ss_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
             <span class="bound">vr</span> <span class="main">=</span> takeWhileNot <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">rs</span><span class="main">;</span>
             <span class="bound">vl</span> <span class="main">=</span> dropWhileNot <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">rs</span>
         <span class="keyword1">in</span> RETURN <span class="main">⦇</span>lasso_impl <span class="main">=</span> Some <span class="main">(</span><span class="bound">vr</span><span class="main">,</span><span class="bound">vl</span><span class="main">)</span><span class="main">,</span> red_impl <span class="main">=</span> red_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>
      <span class="keyword1">else</span> RETURN <span class="main">(</span>simple_state.more <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
  <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RETURN <span class="main">(</span>simple_state.more <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Nested_DFS-se_back_edge_impl"><span class="command">lemma</span></span> se_back_edge_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">accpti</span><span class="main">,</span><span class="free">accpt</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">vi</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>bdfs_rel <span class="main">⟧</span> 
    <span class="main">⟹</span> se_back_edge_impl <span class="free">accpt</span> <span class="free">ui</span> <span class="free">vi</span> <span class="free">si</span> <span class="main">≤</span><span class="main">⇓</span>bdfs_erel <span class="main">(</span>se_back_edge <span class="free">accpt</span> <span class="free">u</span> <span class="free">v</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> se_back_edge_impl_def se_back_edge_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_tl comp_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1" id="Nested_DFS-NOOP_impl"><span class="command">lemma</span></span> NOOP_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> bdfs_rel 
    <span class="main">⟹</span> RETURN <span class="main">(</span>simple_state.more <span class="free">si</span><span class="main">)</span> <span class="main">≤</span> <span class="main">⇓</span> bdfs_erel <span class="main">(</span>NOOP <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_state_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">bdfs_params_impl</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'v</span> bdfs_state_impl<span class="main">,</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span>bdfs_state_impl_ext<span class="main">)</span> gen_parameterization"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bdfs_params_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    on_init <span class="main">=</span> RETURN <span class="main">⦇</span>lasso_impl <span class="main">=</span> None<span class="main">,</span> red_impl <span class="main">=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
    on_new_root <span class="main">=</span> <span class="main">λ</span><span class="bound">v0</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
    on_discover <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
    on_finish <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">s</span><span class="main">.</span> 
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="bound">u</span> <span class="keyword1">then</span> run_red_dfs_impl <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">u</span> <span class="bound">s</span> <span class="keyword1">else</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
    on_back_edge <span class="main">=</span> se_back_edge_impl <span class="free"><span class="bound"><span class="entity">accpt</span></span></span><span class="main">,</span>
    on_cross_edge <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>simple_state.more <span class="bound">s</span><span class="main">)</span><span class="main">,</span>
    is_break <span class="main">=</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> lasso_impl <span class="bound">s</span> <span class="main">≠</span> None <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> bdfs_params_impl_simps<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">DFS_code_unfold</span><span class="main">]</span> <span class="main">=</span> 
    gen_parameterization.simps<span class="main">[</span><span class="operator">mk_record_simp</span><span class="main">,</span> <span class="operator">OF</span> bdfs_params_impl_def<span class="main">]</span>  


  <span class="keyword1"><span class="command">interpretation</span></span> impl<span class="main">:</span> simple_impl_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="quoted">"bdfs_params_impl <span class="free">G</span> <span class="free">accpt</span>"</span></span> <span class="quoted"><span class="quoted">"blue_dfs_params <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free">G</span> <span class="free">accpt</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="free">accpt</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">context</span></span> BlueDFS <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> impl<span class="main">:</span> simple_impl <span class="quoted"><span class="free">G</span></span> <span class="quoted">blue_dfs_params</span> <span class="quoted"><span class="quoted">"bdfs_params_impl <span class="free">G</span> <span class="free">accpt</span>"</span></span> <span class="quoted">bdfs_erel</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bdfs_params_impl_def run_red_dfs_impl se_back_edge_impl NOOP_impl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> si s x y<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">s</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> impl <span class="main">=</span> impl.simple_tailrec_refine
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">nested_dfs_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">accpt</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>lasso_impl <span class="bound">s</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="Nested_DFS-nested_dfs_impl"><span class="command">lemma</span></span> nested_dfs_impl<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">accpti</span><span class="main">,</span><span class="free">accpt</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nested_dfs_impl <span class="free">Gi</span> <span class="free">accpti</span> <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel<span class="main">)</span> 
    <span class="main">(</span>nested_dfs <span class="free">G</span> <span class="free">accpt</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> nested_dfs_impl_def nested_dfs_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> intro_prgR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">bdfs_rel</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> si s<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">si</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">s</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bdfs_erel_def simple_state_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> BlueDFS <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">from</span></span> impl <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"impl.tailrec_impl <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="free">accpt</span> <span class="main">≤</span><span class="main">⇓</span>bdfs_rel <span class="main">(</span>it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="free">accpt</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Synthesis of Executable Code›</span></span>
<span class="comment1">(* Straightforward autoref implementation *)</span>
<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>bdfs_state_impl' <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'si</span><span class="main">,</span><span class="tfree">'nsi</span><span class="main">)</span>simple_state_impl"</span></span> <span class="main">+</span>
  lasso_impl' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span> list<span class="main">)</span> option"</span></span>
  red_impl' <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'nsi</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">to_relAPP</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bdfs_state_erel'</span> <span class="free"><span class="bound"><span class="entity">Vi</span></span></span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="main">⦇</span>lasso_impl' <span class="main">=</span> <span class="bound">li</span><span class="main">,</span> red_impl'<span class="main">=</span><span class="bound">ri</span><span class="main">⦈</span><span class="main">,</span><span class="main">⦇</span>lasso_impl <span class="main">=</span> <span class="bound">l</span><span class="main">,</span> red_impl <span class="main">=</span> <span class="bound">r</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span> <span class="bound">li</span> <span class="bound">ri</span> <span class="bound">l</span> <span class="bound">r</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">li</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Vi</span></span></span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Vi</span></span></span><span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel <span class="main">∧</span> <span class="main">(</span><span class="bound">ri</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Vi</span></span></span><span class="main">⟩</span>dflt_ahs_rel<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">consts</span></span> 
  i_bdfs_state_ext <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">bdfs_state_erel'</span> <span class="quoted">i_bdfs_state_ext</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ns_rel</span> <span class="free">vis_rel</span> <span class="free">Vi</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">ns_rel</span><span class="main">,</span><span class="free">vis_rel</span><span class="main">,</span><span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>bdfs_state_erel'<span class="main">⟩</span>ss_impl_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>bdfs_state_impl'_ext<span class="main">,</span> bdfs_state_impl_ext<span class="main">)</span> 
      <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>dflt_ahs_rel <span class="main">→</span> unit_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>bdfs_state_erel'"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>lasso_impl'<span class="main">,</span> lasso_impl<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>red_impl'<span class="main">,</span> red_impl<span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">Vi</span><span class="main">⟩</span>dflt_ahs_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bdfs_state_erel'_def ss_impl_rel_def R_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> nested_dfs_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Vid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">=</span> <span class="main">(</span>Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>hashable <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">unfolded</span> Vid<span class="main">,</span> <span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span> <span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">accpti</span><span class="main">,</span><span class="free">accpt</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">unfolded</span> Vid<span class="main">,</span> <span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>dflt_ahs_rel"</span></span><span class="main">]</span>
    TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>ras_rel"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nres_of <span class="var">?c</span><span class="main">,</span> nested_dfs_impl <span class="free">G</span> <span class="free">accpt</span><span class="main">)</span> 
    <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nested_dfs_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> Vid 
    se_back_edge_impl_def run_red_dfs_impl_def mk_blue_witness_impl_def
    cyan_impl_def
    <span class="dynamic"><span class="dynamic">DFS_code_unfold</span></span>
  <span class="comment1">(*apply (subst aux1)*)</span>
  <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">nested_dfs_code</span> <span class="keyword2"><span class="keyword">uses</span></span> nested_dfs_code

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">nested_dfs_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Conclusion›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We have implemented an efficiently executable nested DFS algorithm.
  The following theorem declares this implementation to the Autoref tool,
  such that it uses it to synthesize efficient code for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> nested_dfs<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Note that you will need the lemma <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] nested_dfs_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span> to link
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> nested_dfs<span class="antiquote"><span class="antiquote">}</span></span></span></span> to an abstract specification, which is usually done in 
  a previous refinement step.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> nested_dfs_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"PREFER_id <span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">G</span> <span class="bound">accpt</span><span class="main">.</span> nres_of <span class="main">(</span>nested_dfs_code <span class="bound">G</span> <span class="bound">accpt</span><span class="main">)</span><span class="main">,</span>nested_dfs<span class="main">)</span> <span class="main">∈</span>
    <span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span> <span class="free">V</span><span class="main">⟩</span>g_impl_rel_ext <span class="main">→</span> <span class="main">(</span><span class="free">V</span> <span class="main">→</span> bool_rel<span class="main">)</span> <span class="main">→</span>
    <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">V</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> Vid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">V</span><span class="main">=</span>Id"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> nested_dfs_code.refine<span class="main">[</span><span class="operator">OF</span> Vid<span class="main">,</span><span class="operator">param_fo</span><span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> nested_dfs_impl
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Tarjan_LowLink">
<div class="head">
<h1>Theory Tarjan_LowLink</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Invariants for Tarjan's Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Tarjan_LowLink
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="DFS_Framework.html">../DFS_Framework</a>"</span>
  <span class="quoted">"<a href="DFS_Invars_SCC.html">../Invars/DFS_Invars_SCC</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> param_DFS_defs <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">lowlink_path</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> path E <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≠</span> <span class="main">[]</span>
                          <span class="main">∧</span> <span class="main">(</span>last <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∪</span> back_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span>
                          <span class="main">∧</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&gt;</span> <span class="main">1</span> <span class="main">⟶</span>
                                <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">!</span><span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>
                              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">k</span></span> <span class="main">&lt;</span> length <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">!</span><span class="bound">k</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">!</span>Suc <span class="bound">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">lowlink_set</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound"><span class="bound">w</span></span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">.</span>
                         <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="bound">w</span> 
                        <span class="main">∨</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span> 
                          <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">p</span> <span class="bound">w</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">LowLink</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">LowLink</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> Min <span class="main">(</span><span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">`</span> lowlink_set <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> DFS_invar <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_setI"><span class="command">lemma</span></span> lowlink_setI<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">w</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def assms<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_eq_or_trancl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_set_discovered"><span class="command">lemma</span></span> lowlink_set_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"lowlink_set <span class="free">s</span> <span class="free">v</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_set_finite"><span class="command">lemma</span></span> lowlink_set_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lowlink_set <span class="free">s</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lowlink_set_discovered discovered_finite
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_subset<span class="main">)</span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_set_not_empty"><span class="command">lemma</span></span> lowlink_set_not_empty<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="free">s</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_path_single"><span class="command">lemma</span></span> lowlink_path_single<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lowlink_path_def
    <span class="keyword1"><span class="command">using</span></span> assms cross_edges_ssE back_edges_ssE
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_path_Cons"><span class="command">lemma</span></span> lowlink_path_Cons<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">u</span><span class="main">.</span> lowlink_path <span class="free">s</span> <span class="bound">u</span> <span class="free">xs</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> path<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="free">v</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="free">w</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> cb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="free">xs</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">!</span><span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">k</span></span> <span class="main">&lt;</span> length <span class="free">xs</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">!</span><span class="bound">k</span><span class="main">,</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="bound">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lowlink_path_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> path <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">u</span> <span class="free">xs</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> cb <span class="quoted"><span class="quoted">‹<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">=</span> Suc <span class="skolem">k</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> k'_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">!</span><span class="skolem">k'</span><span class="main">,</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="skolem">k'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="skolem">k</span><span class="main">,</span><span class="free">xs</span><span class="main">!</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> k'_def nth_Cons'<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> t' <span class="main">=</span> this
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> f <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">!</span><span class="main">0</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> t'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="main">0</span><span class="main">,</span><span class="free">xs</span><span class="main">!</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">!</span><span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> tree_edge_impl_parenthesis <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="skolem">u</span> <span class="free">xs</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_path_in_tree"><span class="command">lemma</span></span> lowlink_path_in_tree<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">&lt;</span> <span class="free">j</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">!</span><span class="free">k</span><span class="main">,</span> <span class="free">p</span><span class="main">!</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> p j k
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_nonempty_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> single <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">j'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">=</span> <span class="skolem">j</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> cons <span class="keyword1"><span class="command">have</span></span> j'_le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">&lt;</span> length <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">≤</span> <span class="skolem">j'</span>"</span></span>  <span class="keyword2"><span class="keyword">and</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">=</span> Suc <span class="skolem">j'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> cons lowlink_path_Cons <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="skolem">u</span> <span class="skolem">xs</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span><span class="main">0</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">from</span></span> cons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span><span class="bound">k</span><span class="main">,</span><span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="bound">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> lowlink_path_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> True cons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span><span class="skolem">k</span><span class="main">,</span><span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> * j <span class="quoted"><span class="quoted">‹<span class="skolem">k</span><span class="main">=</span><span class="main">0</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">&gt;</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> cons.IH<span class="main">[</span><span class="operator">OF</span> p j'_le<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">!</span><span class="skolem">k</span><span class="main">,</span> <span class="skolem">xs</span><span class="main">!</span><span class="skolem">j'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">with</span></span> j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="skolem">k</span><span class="main">,</span> <span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span><span class="skolem">j</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> trancl_into_trancl2<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False 
        <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">=</span> <span class="skolem">k</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> False <span class="quoted"><span class="quoted">‹<span class="skolem">k</span> <span class="main">≤</span> <span class="skolem">j'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">&lt;</span> <span class="skolem">j'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> Suc <span class="skolem">k'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command">with</span></span> cons.IH<span class="main">[</span><span class="operator">OF</span> p j'_le<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xs</span><span class="main">!</span><span class="skolem">k'</span><span class="main">,</span> <span class="skolem">xs</span><span class="main">!</span><span class="skolem">j'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="skolem">k'</span><span class="main">,</span> <span class="main">(</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">xs</span><span class="main">)</span><span class="main">!</span>Suc <span class="skolem">j'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> k j <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_path_finished"><span class="command">lemma</span></span> lowlink_path_finished<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">j</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">=</span><span class="main">1</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> assms lowlink_path_in_tree<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> k<span class="main"><span class="main">=</span></span><span class="quoted"><span class="main">1</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">!</span><span class="main">1</span><span class="main">,</span><span class="free">p</span><span class="main">!</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> f tree_path_impl_parenthesis <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-lowlink_path_tree_prepend"><span class="command">lemma</span></span> lowlink_path_tree_prepend<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> tree_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="free">s</span> <span class="free">u</span> <span class="bound">p</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> lowlink_path_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

    <span class="keyword1"><span class="command">from</span></span> tree_edges trancl_is_path <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">tp</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      tp<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span> <span class="free">u</span> <span class="skolem">tp</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">tp</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

    <span class="keyword1"><span class="command">from</span></span> tree_path_impl_parenthesis assms hd_stack_tree_path_finished <span class="keyword1"><span class="command">have</span></span> 
      v_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="main">0</span> <span class="main">=</span> hd <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> p_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="main">0</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_hd<span class="main">)</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">tp</span> <span class="main">@</span> <span class="free">p</span>"</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">from</span></span> tp path_mono<span class="main">[</span><span class="operator">OF</span> tree_edges_ssE<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="free">u</span> <span class="skolem">tp</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path E <span class="free">u</span> <span class="var">?p</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="var">?p</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"length <span class="var">?p</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> <span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">tp</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> tp1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> <span class="main">1</span> <span class="main">=</span> <span class="skolem">tp</span> <span class="main">!</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> tp True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">tp</span> <span class="main">!</span> <span class="main">0</span><span class="main">,</span> <span class="skolem">tp</span> <span class="main">!</span> <span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_nth_conv nth_append <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> allE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">tp</span> <span class="main">!</span> <span class="main">0</span> <span class="main">=</span> hd <span class="skolem">tp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> tp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">tp</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_hd<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">tp</span> <span class="main">!</span> <span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> tree_path_impl_parenthesis fin hd_stack_tree_path_finished <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> tp1<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> tp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">tp</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">tp</span></span><span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> p_0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> <span class="main">1</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> v_fin<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">k</span></span> <span class="main">&lt;</span> length <span class="var">?p</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="main">(</span><span class="var">?p</span><span class="main">!</span><span class="bound">k</span><span class="main">,</span> <span class="var">?p</span><span class="main">!</span>Suc <span class="bound">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
        <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="var">?p</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?p</span><span class="main">!</span><span class="skolem">k</span><span class="main">,</span> <span class="var">?p</span><span class="main">!</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="skolem">tp</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">=</span> <span class="skolem">tp</span> <span class="main">!</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">k</span> <span class="main">&lt;</span> length <span class="skolem">tp</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> Suc <span class="skolem">k</span> <span class="main">=</span> <span class="skolem">tp</span> <span class="main">!</span> Suc <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> True tp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">tp</span> <span class="main">!</span> <span class="skolem">k</span><span class="main">,</span> <span class="skolem">tp</span> <span class="main">!</span> Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_nth_conv nth_append 
                       <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> allE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> k <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">k</span> <span class="main">=</span> length <span class="skolem">tp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> tp True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">tp</span> <span class="main">!</span> <span class="skolem">k</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_nth_conv nth_append 
                       <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> allE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> * p_0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="var">?p</span> <span class="main">!</span> Suc <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> k<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">k</span> <span class="main">-</span> length <span class="skolem">tp</span> <span class="main">=</span> Suc <span class="main">(</span><span class="skolem">k</span> <span class="main">-</span> length <span class="skolem">tp</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">=</span> <span class="skolem">k</span> <span class="main">-</span> length <span class="skolem">tp</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> False * <span class="keyword1"><span class="command">have</span></span> k'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">=</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">k'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">!</span> Suc <span class="skolem">k</span> <span class="main">=</span> <span class="free">p</span> <span class="main">!</span> Suc <span class="skolem">k'</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> k'_def False A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">&lt;</span> length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
          <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">!</span><span class="skolem">k'</span><span class="main">,</span> <span class="free">p</span><span class="main">!</span>Suc <span class="skolem">k'</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="comment1">(* p is lowlink_path *)</span>
          <span class="keyword1"><span class="command">with</span></span> k' <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword1"><span class="command">also</span></span> <span class="main">(</span>conjI<span class="main">)</span> <span class="keyword1"><span class="command">note</span></span> calculation
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">u</span> <span class="var">?p</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
    

  <span class="keyword1" id="Tarjan_LowLink-lowlink_path_complex"><span class="command">lemma</span></span> lowlink_path_complex<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="free">s</span> <span class="free">u</span> <span class="bound">p</span> <span class="free">w</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms lowlink_path_single <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> assms lowlink_path_tree_prepend <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-no_path_imp_no_lowlink_path"><span class="command">lemma</span></span> no_path_imp_no_lowlink_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
    
    <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">p</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def path_hd<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> hd_conv_nth<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="main">0</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">!</span><span class="main">0</span><span class="main">,</span><span class="free">p</span><span class="main">!</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> v assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_conv_nth v<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="Tarjan_LowLink-LowLink_le_disc"><span class="command">lemma</span></span> LowLink_le_disc<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
  
  <span class="keyword1" id="Tarjan_LowLink-LowLink_lessE"><span class="command">lemma</span></span> LowLink_lessE<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">w</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span>

    <span class="keyword1"><span class="command">note</span></span> assms
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> lowlink_set_finite <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> lowlink_set_not_empty assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Min_less_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-LowLink_lessI"><span class="command">lemma</span></span> LowLink_lessI<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">y</span> <span class="main">∈</span> <span class="var">?L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> lowlink_set_finite <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Min_less_iff assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan_LowLink-LowLink_eqI"><span class="command">lemma</span></span> LowLink_eqI<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="free">param</span> <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> sub_m<span class="main">:</span> <span class="quoted"><span class="quoted">"discovered <span class="free">s</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> discovered <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> sub<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="free">s</span> <span class="free">w</span> <span class="main">⊆</span> lowlink_set <span class="free">s'</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> rev_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="free">s'</span> <span class="free">w</span> <span class="main">⊆</span> lowlink_set <span class="free">s</span> <span class="free">w</span> <span class="main">∪</span> <span class="free">X</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> w_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> lowlink_set <span class="free">s'</span> <span class="free">w</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="bound">x</span> <span class="main">≥</span> LowLink <span class="free">s</span> <span class="free">w</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">w</span> <span class="main">=</span> LowLink <span class="free">s'</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="free">s'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">w</span> <span class="main">≠</span> LowLink <span class="free">s'</span> <span class="free">w</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> lowlink_set_discovered sub sub_m w_disc <span class="keyword1"><span class="command">have</span></span> 
           sub'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">`</span> lowlink_set <span class="free">s</span> <span class="free">w</span> <span class="main">⊆</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="main">`</span> lowlink_set <span class="free">s'</span> <span class="free">w</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span>  w_disc'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span>  eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ll</span><span class="main">.</span> <span class="bound">ll</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">w</span> <span class="main">⟹</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="bound">ll</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="bound">ll</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_le_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword1"><span class="command">from</span></span> lowlink_set_not_empty<span class="main">[</span><span class="operator">OF</span> w_disc<span class="main">]</span> A Min_antimono<span class="main">[</span><span class="operator">OF</span> sub'<span class="main">]</span> s'.lowlink_set_finite <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"LowLink <span class="free">s'</span> <span class="free">w</span> <span class="main">&lt;</span> LowLink <span class="free">s</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ll</span></span> <span class="keyword2"><span class="keyword">where</span></span> ll<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="free">s'</span> <span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ll_le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s'</span> <span class="skolem">ll</span> <span class="main">&lt;</span> LowLink <span class="free">s</span> <span class="free">w</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> s'.LowLink_lessE w_disc'<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> rev_sub <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">w</span> <span class="main">∨</span> <span class="skolem">ll</span> <span class="main">∈</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s'</span> <span class="skolem">ll</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> lowlink_set_finite eq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> X<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> ll_le <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1" id="Tarjan_LowLink-LowLink_eq_disc_iff_scc_root"><span class="command">lemma</span></span> LowLink_eq_disc_iff_scc_root<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">v</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">⟷</span> scc_root <span class="free">s</span> <span class="free">v</span> <span class="main">(</span>scc_of E <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?scc</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"scc_of E <span class="free">v</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> scc<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="var">?scc</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">≠</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
      
      <span class="keyword1"><span class="command">from</span></span> assms finished_discovered stack_discovered hd_in_set <span class="keyword1"><span class="command">have</span></span> disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> assms LowLink_le_disc A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">with</span></span> disc <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">w</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> LowLink_lessE<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> lowlink_set_discovered <span class="keyword1"><span class="command">have</span></span> wdisc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> w <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="var">?scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="var">?scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="var">?scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> is_scc_closed<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> wdisc scc_root_disc_le<span class="main">[</span><span class="operator">OF</span> scc<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> w <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> LL<span class="main">:</span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span>
    
    <span class="keyword1"><span class="command">from</span></span> assms finished_discovered stack_discovered hd_in_set <span class="keyword1"><span class="command">have</span></span> 
      v_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">from</span></span> assms finished_no_pending <span class="keyword1"><span class="command">have</span></span>
      v_no_p<span class="main">:</span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?scc</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"scc_of E <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> is_scc<span class="main">:</span> <span class="quoted"><span class="quoted">"is_scc E <span class="var">?scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="var">?scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="var">?scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span> <span class="main">∈</span> <span class="var">?scc</span>›</span></span> is_scc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">r</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>Restr E <span class="var">?scc</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_scc_connected'<span class="main">)</span>
      
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">r</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span><span class="main">≠</span><span class="free">v</span>›</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtrancl_induct<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>Restr E <span class="var">?scc</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_into_rtrancl<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Restr_rtrancl_mono<span class="main">)</span>

        <span class="keyword1"><span class="command">from</span></span> step <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_scc_connected<span class="main"><span class="main">[</span></span><span class="operator">OF</span> is_scc<span class="main"><span class="main">]</span></span><span class="main">)</span>

        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> z_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="bound">p</span> <span class="skolem">z</span>"</span></span> 
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">z</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> <span class="keyword1"><span class="command">have</span></span> ll<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> lowlink_set <span class="free">s</span> <span class="free">v</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lowlink_setI<span class="main">)</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
            <span class="keyword3"><span class="command">presume</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">≥</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span><span class="main">≠</span><span class="free">v</span>›</span></span> v_disc z_disc disc_unequal <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> LowLink_lessI<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> LL <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> δz <span class="main">=</span> this

        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">=</span><span class="free">v</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this
          <span class="keyword1"><span class="command">with</span></span> step v_no_p v_disc no_pending_imp_succ_discovered <span class="keyword1"><span class="command">have</span></span>
            z_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          
          <span class="keyword1"><span class="command">from</span></span> step edges_covered v_no_p v_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> edgesE_CB<span class="main">)</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> CB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span> <span class="skolem">z</span>"</span></span> 
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_single<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> δz<span class="main">[</span><span class="operator">OF</span> z_disc<span class="main">]</span> no_pending_succ_impl_path_in_tree v_disc v_no_p step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> step.IH <span class="keyword1"><span class="command">have</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">with</span></span> tree_path_impl_parenthesis assms hd_stack_tree_path_finished tree_path_disc <span class="keyword1"><span class="command">have</span></span> 
            y_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> y_δ <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
          <span class="keyword1"><span class="command">with</span></span> step <span class="keyword1"><span class="command">have</span></span> z_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> finished_imp_succ_discovered
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">from</span></span> step edges_covered finished_no_pending<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> y_fin finished_discovered <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">s</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> edgesE_CB<span class="main">)</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> T <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> CB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span> <span class="main">∪</span> back_edges <span class="free">s</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> lowlink_path_complex<span class="main">[</span><span class="operator">OF</span> T<span class="main">]</span> assms <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="free">s</span> <span class="free">v</span> <span class="bound">p</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">with</span></span> δz z_disc <span class="keyword1"><span class="command">have</span></span> δz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> tree_path_impl_parenthesis T <span class="keyword1"><span class="command">have</span></span> y_f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                
              <span class="keyword1"><span class="command">from</span></span> CB <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">proof</span></span>
                <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="free">s</span>"</span></span>
                <span class="keyword1"><span class="command">with</span></span> cross_edges_finished_decr y_fin y_f <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> 
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> δz
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> C cross_edges_target_finished <span class="keyword1"><span class="command">have</span></span> 
                  <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
                  <span class="keyword1"><span class="command">using</span></span> parenthesis_impl_tree_path<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> back_edges <span class="free">s</span>"</span></span>
                <span class="keyword1"><span class="command">with</span></span> back_edge_disc_lt_fin y_fin y_f <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> 
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> δz z_disc
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">φ</span> <span class="free">s</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">φ</span> <span class="free">s</span> <span class="free">v</span>"</span></span> 
                  <span class="keyword1"><span class="command">using</span></span> parenthesis_contained<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
                <span class="keyword1"><span class="command">with</span></span> δz <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
                  <span class="keyword1"><span class="command">using</span></span> parenthesis_impl_tree_path<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> False <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>v ∉ dom (finished s)›</span></span>›</span>
              <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> st<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
              
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">with</span></span> z_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stack_set_def<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span><span class="main">≠</span><span class="free">v</span>›</span></span> st <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">with</span></span> st tl_lt_stack_hd_discover δz <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
              <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword1"><span class="command">with</span></span> δz parenthesis_impl_tree_path_not_finished v_disc False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>     
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?scc</span> <span class="main">∩</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">v</span> <span class="var">?scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> scc_rootI v_disc<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Tarjan">
<div class="head">
<h1>Theory Tarjan</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tarjan's Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Tarjan
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Tarjan_LowLink.html">Tarjan_LowLink</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We use the DFS Framework to implement Tarjan's algorithm.
  Note that, currently, we only provide an abstract version, and no refinement to 
  efficient code.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>
<span class="comment1">(* Though this is a general lemma about dropWhile/takeWhile, it is probably only of use for this algorithm. *)</span>
<span class="keyword1" id="Tarjan-tjs_union"><span class="command">lemma</span></span> tjs_union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tjs</span> <span class="free">u</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">dw</span> <span class="main">≡</span> dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free">u</span><span class="main">)</span> <span class="free">tjs</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">tw</span> <span class="main">≡</span> takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free">u</span><span class="main">)</span> <span class="free">tjs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> set <span class="free">tjs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">tjs</span> <span class="main">=</span> set <span class="main">(</span>tl <span class="free">dw</span><span class="main">)</span> <span class="main">∪</span> insert <span class="free">u</span> <span class="main">(</span>set <span class="free">tw</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> takeWhile_dropWhile_id <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="free">tjs</span> <span class="main">=</span> set <span class="main">(</span><span class="free">tw</span><span class="main">@</span><span class="free">dw</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dw_def tw_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="free">tjs</span> <span class="main">=</span> set <span class="free">tw</span> <span class="main">∪</span> set <span class="free">dw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> set_append<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span> <span class="main">∈</span> set <span class="free">tjs</span>›</span></span> dropWhile_eq_Nil_conv <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">dw</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dw_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> hd_dropWhile<span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> dw_def<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="free">dw</span> <span class="main">=</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dw_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">dw</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="free">dw</span> <span class="main">=</span> insert <span class="free">u</span> <span class="main">(</span>set <span class="main">(</span>tl <span class="free">dw</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">dw</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of the DFS-Framework›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'v</span> tarjan_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> state"</span></span> <span class="main">+</span>
  sccs <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set set"</span></span>
  lowlink <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇀</span> nat"</span></span>
  tj_stack <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> list"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> tarjan_param <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> tarjan_state_ext<span class="main">)</span> parameterization"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_lowlink</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> the <span class="main">(</span>lowlink <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> timing_syntax
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">notation</span></span> the_lowlink <span class="main">(</span><span class="quoted">"<span class="keyword1">ζ</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> Tarjan_def <span class="main">=</span> graph_defs <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tarjan_disc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> tarjan_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> tarjan_state_ext nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">tarjan_disc</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> RETURN <span class="main">⦇</span> sccs <span class="main">=</span> sccs <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">,</span> 
                                 lowlink <span class="main">=</span> <span class="main">(</span>lowlink <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↦</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">,</span>
                                 tj_stack <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">#</span>tj_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tj_stack_pop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> list <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span> set<span class="main">)</span> nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">tj_stack_pop</span> <span class="free"><span class="bound"><span class="entity">tjs</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> RETURN <span class="main">(</span>tl <span class="main">(</span>dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">tjs</span></span></span><span class="main">)</span><span class="main">,</span> insert <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>set <span class="main">(</span>takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">tjs</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Tarjan-tj_stack_pop_set"><span class="command">lemma</span></span> tj_stack_pop_set<span class="main">:</span>
    <span class="quoted"><span class="quoted">"tj_stack_pop <span class="free">tjs</span> <span class="free">u</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">tjs'</span><span class="main">,</span><span class="bound">scc</span><span class="main">)</span><span class="main">.</span> <span class="free">u</span> <span class="main">∈</span> set <span class="free">tjs</span> <span class="main">⟶</span> set <span class="free">tjs</span> <span class="main">=</span> set <span class="bound">tjs'</span> <span class="main">∪</span> <span class="bound">scc</span> <span class="main">∧</span> <span class="free">u</span> <span class="main">∈</span> <span class="bound">scc</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> tjs_union<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">tjs</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> tj_stack_pop_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> tj_stack_pop_set_leof_rule <span class="main">=</span> weaken_SPEC<span class="main">[</span><span class="operator">OF</span> tj_stack_pop_set<span class="main">,</span> <span class="operator">THEN</span> leof_lift<span class="main">]</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tarjan_fin</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> tarjan_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> tarjan_state_ext nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">tarjan_fin</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
           <span class="keyword1">let</span> <span class="bound">ll</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> stack <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> lowlink <span class="free"><span class="bound"><span class="entity">s</span></span></span> 
                     <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
                          <span class="main">(</span>lowlink <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">(</span><span class="bound">u</span> <span class="main">↦</span> min <span class="main">(</span><span class="keyword1">ζ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">ζ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
           <span class="keyword1">let</span> <span class="bound">s'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> lowlink <span class="main">:=</span> <span class="bound">ll</span> <span class="main">⦈</span><span class="main">;</span>

           ASSERT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
           ASSERT <span class="main">(</span>distinct <span class="main">(</span>tj_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
           <span class="keyword1">if</span> <span class="keyword1">ζ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                ASSERT <span class="main">(</span>scc_root' E <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>scc_of E <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                <span class="main">(</span><span class="bound">tjs</span><span class="main">,</span><span class="bound">scc</span><span class="main">)</span> <span class="main">←</span> tj_stack_pop <span class="main">(</span>tj_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
                RETURN <span class="main">(</span>state.more <span class="main">(</span><span class="bound">s'</span><span class="main">⦇</span> tj_stack <span class="main">:=</span> <span class="bound">tjs</span><span class="main">,</span> sccs <span class="main">:=</span> insert <span class="bound">scc</span> <span class="main">(</span>sccs <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
           <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                ASSERT <span class="main">(</span><span class="main">¬</span> scc_root' E <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>scc_of E <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                RETURN <span class="main">(</span>state.more <span class="bound">s'</span><span class="main">)</span>
           <span class="main">}</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tarjan_back</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> tarjan_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span>unit<span class="main">)</span> tarjan_state_ext nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">tarjan_back</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span>
       <span class="keyword1">if</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">then</span>
         <span class="keyword1">let</span> <span class="bound">ul'</span> <span class="main">=</span> min <span class="main">(</span><span class="keyword1">ζ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">(</span><span class="keyword1">δ</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>
         <span class="keyword1">in</span> RETURN <span class="main">(</span>state.more <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⦇</span> lowlink <span class="main">:=</span> <span class="main">(</span>lowlink <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">↦</span><span class="bound">ul'</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
       <span class="keyword1">else</span> NOOP <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* end timing syntax *)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">tarjan_params</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> tarjan_param"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">tarjan_params</span> <span class="main">=</span> <span class="main">⦇</span>
      on_init <span class="main">=</span> RETURN <span class="main">⦇</span> sccs <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> lowlink <span class="main">=</span> Map.empty<span class="main">,</span> tj_stack <span class="main">=</span> <span class="main">[]</span> <span class="main">⦈</span><span class="main">,</span>
      on_new_root <span class="main">=</span> tarjan_disc<span class="main">,</span>
      on_discover <span class="main">=</span> <span class="main">λ</span><span class="bound">u</span><span class="main">.</span> tarjan_disc<span class="main">,</span>
      on_finish <span class="main">=</span> tarjan_fin<span class="main">,</span>
      on_back_edge <span class="main">=</span> tarjan_back<span class="main">,</span>
      on_cross_edge <span class="main">=</span> tarjan_back<span class="main">,</span>
      is_break <span class="main">=</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> False <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> tarjan_params_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"on_init tarjan_params <span class="main">=</span> <span class="var">?OI</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_new_root tarjan_params <span class="main">=</span> <span class="var">?ONR</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_discover tarjan_params <span class="main">=</span> <span class="var">?OD</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_finish tarjan_params <span class="main">=</span> <span class="var">?OF</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_back_edge tarjan_params <span class="main">=</span> <span class="var">?OBE</span>"</span></span>
    <span class="quoted"><span class="quoted">"on_cross_edge tarjan_params <span class="main">=</span> <span class="var">?OCE</span>"</span></span>
    <span class="quoted"><span class="quoted">"is_break tarjan_params <span class="main">=</span> <span class="var">?IB</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> tarjan_params_def gen_parameterization.simps
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> param_DFS_defs <span class="quoted"><span class="free">G</span></span> <span class="quoted">tarjan_params</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> Tarjan <span class="main">=</span> Tarjan_def <span class="quoted"><span class="free">G</span></span> <span class="main">+</span>
                param_DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">tarjan_params</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"sccs <span class="main">(</span>empty_state <span class="main">⦇</span>sccs <span class="main">=</span> <span class="free">s</span><span class="main">,</span> lowlink <span class="main">=</span> <span class="free">l</span><span class="main">,</span> tj_stack <span class="main">=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"lowlink <span class="main">(</span>empty_state <span class="main">⦇</span>sccs <span class="main">=</span> <span class="free">s</span><span class="main">,</span> lowlink <span class="main">=</span> <span class="free">l</span><span class="main">,</span> tj_stack <span class="main">=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">l</span>"</span></span>
    <span class="quoted"><span class="quoted">"tj_stack <span class="main">(</span>empty_state <span class="main">⦇</span>sccs <span class="main">=</span> <span class="free">s</span><span class="main">,</span> lowlink <span class="main">=</span> <span class="free">l</span><span class="main">,</span> tj_stack <span class="main">=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_state_def<span class="main">)</span>

  <span class="keyword1" id="Tarjan-sccs_more_cong"><span class="command">lemma</span></span> sccs_more_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> sccs <span class="free">s</span> <span class="main">=</span> sccs <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1" id="Tarjan-lowlink_more_cong"><span class="command">lemma</span></span> lowlink_more_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> lowlink <span class="free">s</span> <span class="main">=</span> lowlink <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1" id="Tarjan-tj_stack_more_cong"><span class="command">lemma</span></span> tj_stack_more_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"state.more <span class="free">s</span> <span class="main">=</span> state.more <span class="free">s'</span> <span class="main">⟹</span> tj_stack <span class="free">s</span> <span class="main">=</span> tj_stack <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span> <span class="operator">simp</span>

   <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
     <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⦇</span> state.more <span class="main">:=</span> <span class="main">⦇</span>sccs <span class="main">=</span> <span class="free">sc</span><span class="main">,</span> lowlink <span class="main">=</span> <span class="free">l</span><span class="main">,</span> tj_stack <span class="main">=</span> <span class="free">t</span><span class="main">⦈</span><span class="main">⦈</span>
      <span class="main">=</span> <span class="free">s</span><span class="main">⦇</span> sccs <span class="main">:=</span> <span class="free">sc</span><span class="main">,</span> lowlink <span class="main">:=</span> <span class="free">l</span><span class="main">,</span> tj_stack <span class="main">:=</span> <span class="free">t</span><span class="main">⦈</span>"</span></span>                  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> Tarjan_invar <span class="main">=</span> Tarjan <span class="main">+</span>
  DFS_invar <span class="keyword2"><span class="keyword">where</span></span> param <span class="main">=</span> <span class="quoted">tarjan_params</span>

<span class="keyword1"><span class="command">context</span></span> Tarjan_def <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Tarjan-Tarjan_invar_eq"><span class="command">lemma</span></span> Tarjan_invar_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="free">s</span> <span class="main">⟷</span> Tarjan_invar <span class="free">G</span> <span class="free">s</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?D</span> <span class="main">⟷</span> <span class="var">?T</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?D</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> DFS_invar <span class="keyword2"><span class="keyword">where</span></span> param<span class="main">=</span><span class="quoted">tarjan_params</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?T</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?D</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>
<span class="keyword1"><span class="command">context</span></span> Tarjan <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Tarjan-i_tj_stack_discovered"><span class="command">lemma</span></span> i_tj_stack_discovered<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> set <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> tj_stack_pop_set_leof_rule<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def tarjan_back_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Tarjan_invar<span class="main">)</span> tj_stack_discovered <span class="main">=</span>
    i_tj_stack_discovered<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="Tarjan-i_tj_stack_distinct"><span class="command">lemma</span></span> i_tj_stack_distinct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> distinct <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI_ND<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> new_discover tj_stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> new_discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> distinct_tl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Tarjan_invar<span class="main">)</span> tj_stack_distinct <span class="main">=</span>
    i_tj_stack_distinct<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="Tarjan-i_tj_stack_incr_disc"><span class="command">lemma</span></span> i_tj_stack_incr_disc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">k</span></span><span class="main">&lt;</span>length <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound"><span class="bound">j</span></span><span class="main">&lt;</span><span class="bound">k</span><span class="main">.</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="main">(</span>tj_stack <span class="bound">s</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="bound">s</span> <span class="main">(</span>tj_stack <span class="bound">s</span> <span class="main">!</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI_ND<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> new_discover tj_stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> Suc <span class="main">(</span>length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">-</span> Suc <span class="main">0</span> <span class="main">&lt;</span> length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">k</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nth_mem <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">with</span></span> tj_stack_discovered timing_less_counter <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">k</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> counter <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">=</span> <span class="skolem">k</span> <span class="main">-</span> Suc <span class="main">0</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">j'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">=</span> <span class="skolem">j</span> <span class="main">-</span> Suc <span class="main">0</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> Suc <span class="main">(</span>length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">#</span>tj_stack <span class="skolem">s</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> gt_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">k</span><span class="main">&gt;</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">=</span><span class="main">0</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">k</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">&lt;</span> <span class="skolem">k'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> j'_def k'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">&lt;</span> length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> k'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">j'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">k'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> new_discover <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> gt_0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span><span class="main">(</span><span class="skolem">v</span><span class="main">#</span>tj_stack <span class="skolem">s</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">k'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> j'_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_Cons'<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> new_discover
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>

      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">k</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> tl <span class="var">?dw</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">k</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">j'</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">=</span> Suc <span class="skolem">j</span> <span class="main">+</span> length <span class="var">?tw</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">=</span> Suc <span class="skolem">k</span> <span class="main">+</span> length <span class="var">?tw</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">k</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span> <span class="main">&lt;</span> <span class="skolem">k'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> length <span class="var">?tw</span> <span class="main">+</span> length <span class="var">?dw</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_append<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">k</span> <span class="main">&lt;</span> length <span class="var">?dw</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="var">?dw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">&lt;</span> length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> k'_def<span class="main">)</span>

      <span class="keyword1"><span class="command">with</span></span> finish <span class="quoted"><span class="quoted">‹<span class="skolem">j'</span><span class="main">&lt;</span><span class="skolem">k'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">k'</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">j'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> dropWhile_nth<span class="main">[</span><span class="operator">OF</span> *<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">k'</span> <span class="main">=</span> <span class="var">?dw</span> <span class="main">!</span> Suc <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> k'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> dropWhile_nth<span class="main">[</span><span class="operator">OF</span> **<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="skolem">j'</span> <span class="main">=</span> <span class="var">?dw</span> <span class="main">!</span> Suc <span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> j'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> nth_tl<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?dw</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">!</span> Suc <span class="skolem">k</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">!</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> nth_tl<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="var">?dw</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">!</span> Suc <span class="skolem">j</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">!</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">!</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux <span class="main">=</span> this

    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> aux<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="Tarjan-tj_stack_incr_disc"><span class="command">lemma</span></span> tj_stack_incr_disc<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">&lt;</span> length <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> <span class="free">k</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>tj_stack <span class="free">s</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>tj_stack <span class="free">s</span> <span class="main">!</span> <span class="free">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms i_tj_stack_incr_disc<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Tarjan-tjs_disc_dw_tw"><span class="command">lemma</span></span> tjs_disc_dw_tw<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">u</span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">dw</span> <span class="main">≡</span> dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">tw</span> <span class="main">≡</span> takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="free">dw</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> set <span class="free">tw</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">dw</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="free">dw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tw</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">tw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span> <span class="main">=</span> length <span class="free">tw</span> <span class="main">+</span> length <span class="free">dw</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_append<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> tw_def dw_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> k j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>tj_stack <span class="free">s</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">k</span> <span class="main">+</span> length <span class="free">tw</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="main">(</span>tj_stack <span class="free">s</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tj_stack_incr_disc<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> j takeWhile_nth <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="free">s</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tw_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> dropWhile_nth k <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="free">s</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">k</span> <span class="main">+</span> length <span class="free">tw</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tw_def dw_def<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="Tarjan-i_sccs_finished_stack_ss_tj_stack"><span class="command">lemma</span></span> i_sccs_finished_stack_ss_tj_stack<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="bound">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span> <span class="main">⊆</span> set <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="var">?tw</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> x_tj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_takeWhileD<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> x_tj tj_stack_discovered discovered_eq_finished_un_stack <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">u</span>›</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> tl_lt_stack_hd_discover finish <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> hd_dropWhile<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> hd_in_set <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="var">?dw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
        <span class="keyword1"><span class="command">with</span></span> tjs_disc_dw_tw <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> set <span class="var">?tw</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> finished <span class="skolem">s</span> <span class="skolem">x</span> <span class="main">=</span> Some <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux_scc <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span>  <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> finish stack_distinct <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_tlD<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> stack_not_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> A aux_scc<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">u</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set <span class="var">?tw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword1"><span class="command">moreover</span></span> 
      <span class="keyword1"><span class="command">from</span></span> finish <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> tjs_union<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>›</span></span><span class="main">]</span>

      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="var">?dw</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux_tj <span class="main">=</span> this
      
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> aux_scc aux_tj <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_set_tlD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def tarjan_back_def<span class="main">)</span>

  <span class="keyword1" id="Tarjan-i_tj_stack_ss_stack_finished"><span class="command">lemma</span></span> i_tj_stack_ss_stack_finished<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> set <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span> <span class="main">⊆</span> set <span class="main">(</span>stack <span class="bound">s</span><span class="main">)</span> <span class="main">∪</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> tj_stack_pop_set_leof_rule<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def tarjan_back_def<span class="main">)</span>

  <span class="keyword1" id="Tarjan-i_finished_ss_sccs_tj_stack"><span class="command">lemma</span></span> i_finished_ss_sccs_tj_stack<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="bound">s</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI_ND<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> new_discover finished_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> new_discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> tj_stack_pop_set_leof_rule<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> finished_ss_sccs_tj_stack <span class="main">=</span>
    i_finished_ss_sccs_tj_stack<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
  
  <span class="keyword1"><span class="command">lemmas</span></span> tj_stack_ss_stack_finished <span class="main">=</span>
    i_tj_stack_ss_stack_finished<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

  <span class="keyword1" id="Tarjan-sccs_finished"><span class="command">lemma</span></span> sccs_finished<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>sccs <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i_sccs_finished_stack_ss_tj_stack<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Tarjan-stack_ss_tj_stack"><span class="command">lemma</span></span> stack_ss_tj_stack<span class="main">:</span>
    <span class="quoted"><span class="quoted">"set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i_sccs_finished_stack_ss_tj_stack<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
  <span class="keyword1" id="Tarjan-hd_stack_in_tj_stack"><span class="command">lemma</span></span> hd_stack_in_tj_stack<span class="main">:</span>
    <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> stack_ss_tj_stack hd_in_set
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="Tarjan-i_no_finished_root"><span class="command">lemma</span></span> i_no_finished_root<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> scc_root <span class="bound">s</span> <span class="free">r</span> <span class="free">scc</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="bound">s</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">scc</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI_ND_CB<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_disc <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> inv'<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="var">?s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> inv' <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="var">?s</span> <span class="main">=</span> <span class="skolem">v</span><span class="main">#</span>tj_stack <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_discover tarjan_disc_def<span class="main">)</span>
      
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> r s'.scc_root_finished_impl_scc_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">scc</span> <span class="main">⊆</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> new_discover finished_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> r finished_discovered new_discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> r inv' new_discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="skolem">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> scc_root_transfer<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD2<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">with</span></span> new_discover r <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">scc</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">scc</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> new_discover<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> new_discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">{</span></span> 
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_back <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="var">?s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> cross_back_edge <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="skolem">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> scc_root_transfer'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="var">?s</span> <span class="main">=</span> tj_stack <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cross_back_edge tarjan_back_def<span class="main">)</span>

      <span class="keyword1"><span class="command">ultimately</span></span>  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">scc</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> cross_back_edge r <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> cross_back_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_fin <span class="skolem">u</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> inv'<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="var">?s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s'</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> inv' <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">scc</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> finish r <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">scc</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> scc_root_transfer'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span> <span class="main">⊆</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> tj_stack_pop_set_leof_rule<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> r s'.scc_root_unique_is_scc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="var">?s</span> <span class="skolem">u</span> <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> s'.scc_root_transfer'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">s'</span></span><span class="main">]</span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="skolem">s'</span> <span class="skolem">u</span> <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">moreover</span></span>
        <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tj_stack <span class="var">?s</span> <span class="main">=</span> tl <span class="main">(</span>dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">j</span></span><span class="main">::</span><span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
          
          <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="var">?s</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>

          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> length <span class="var">?tw</span> <span class="main">+</span> length <span class="var">?dw</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_append<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="main">+</span> length <span class="var">?tw</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">(</span>tj_stack <span class="skolem">s</span> <span class="main">!</span> length <span class="var">?tw</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tj_stack_incr_disc<span class="main">)</span>

          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> hd_stack_in_tj_stack finish <span class="keyword1"><span class="command">have</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"length <span class="var">?dw</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">from</span></span> hd_dropWhile<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> hd_conv_nth<span class="main">[</span><span class="operator">OF</span> ne<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">!</span> <span class="main">0</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> dropWhile_nth<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹length <span class="var">?dw</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s</span> <span class="main">!</span> length <span class="var">?tw</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">!</span> Suc <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="var">?dw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_tl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ne<span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> dropWhile_nth<span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s</span> <span class="main">!</span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="main">+</span> length <span class="var">?tw</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish<span class="main">)</span>

          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> x s'.tj_stack_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="free">scc</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s'.scc_root_disc_le r True <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Tarjan-no_finished_root"><span class="command">lemma</span></span> no_finished_root<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="free">r</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">scc</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">using</span></span> i_no_finished_root<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="Tarjan-tj_stack_reach_stack"><span class="command">lemma</span></span> tj_stack_reach_stack<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="bound">v</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> u_scc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> scc_of E <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> assms tj_stack_discovered <span class="keyword1"><span class="command">have</span></span> u_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> scc_root_of_node_exists <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="free">s</span> <span class="skolem">r</span> <span class="main">(</span>scc_of E <span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∉</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> r<span class="main">[</span><span class="operator">unfolded</span> scc_root_def<span class="main">]</span> stack_set_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> u_scc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> no_finished_root r <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> r scc_reach_scc_root u_scc u_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">r</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> r scc_root_disc_le u_scc u_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="free">s</span> <span class="skolem">r</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan-tj_stack_reach_hd_stack"><span class="command">lemma</span></span> tj_stack_reach_hd_stack<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> tj_stack_reach_stack assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">r</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">r</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> r <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> ne <span class="main">:</span><span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> tl_stack_hd_tree_path ne <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="free">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> trancl_mono_mp tree_edges_ssE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span>hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_eq_or_trancl<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">r</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1" id="Tarjan-empty_stack_imp_empty_tj_stack"><span class="command">lemma</span></span> empty_stack_imp_empty_tj_stack<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"tj_stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> tj_stack_reach_stack <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1" id="Tarjan-stacks_eq_iff"><span class="command">lemma</span></span> stacks_eq_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> tj_stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> empty_stack_imp_empty_tj_stack stack_ss_tj_stack
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1" id="Tarjan-i_sccs_are_sccs"><span class="command">lemma</span></span> i_sccs_are_sccs<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">scc</span> <span class="main">∈</span> sccs <span class="bound">s</span><span class="main">.</span> is_scc E <span class="bound">scc</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">u</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> discovered <span class="skolem">s</span>"</span></span>
      <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span>"</span></span>
      <span class="quoted"><span class="quoted">"sccs <span class="skolem">s'</span> <span class="main">=</span> sccs <span class="skolem">s</span>"</span></span>
      <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s'</span> <span class="main">=</span> tj_stack <span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>

      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_fin <span class="skolem">u</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> inv'<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="main">(</span><span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">from</span></span> finish hd_in_set stack_set_def <span class="keyword1"><span class="command">have</span></span> 
        u_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> u_n_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">scc</span> <span class="main">∈</span> sccs <span class="var">?s</span><span class="main">.</span> is_scc E <span class="bound">scc</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"scc_root <span class="skolem">s'</span> <span class="skolem">u</span> <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sccs <span class="var">?s</span> <span class="main">=</span> sccs <span class="skolem">s</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> False<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finish<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"dropWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"takeWhile <span class="main">(</span><span class="main">(≠)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tw'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">u</span> <span class="main">(</span>set <span class="var">?tw</span><span class="main">)</span>"</span></span>

        <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sccs <span class="var">?s</span> <span class="main">=</span> insert <span class="var">?tw'</span> <span class="main">(</span>sccs <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True<span class="main">)</span>

        <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tj_stack <span class="var">?s</span> <span class="main">=</span> tl <span class="var">?dw</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True<span class="main">)</span>

        <span class="keyword1"><span class="command">from</span></span> True scc_root_transfer'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">s'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_root <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> inv' scc_root_transfer<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span><span class="main">]</span> u_disc <span class="keyword1"><span class="command">have</span></span> u_root<span class="main">:</span> <span class="quoted"><span class="quoted">"scc_root <span class="var">?s</span> <span class="skolem">u</span> <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?tw'</span> <span class="main">⊆</span> scc_of E <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="var">?tw'</span>"</span></span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> scc_of E <span class="skolem">u</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> v <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="var">?tw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> v_tj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_takeWhileD<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> tj_stack_discovered <span class="keyword1"><span class="command">have</span></span> v_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

            <span class="keyword1"><span class="command">from</span></span> hd_stack_in_tj_stack finish  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dw</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> hd_dropWhile<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> hd_in_set <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="var">?dw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
            <span class="keyword1"><span class="command">with</span></span> v <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> tjs_disc_dw_tw <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
           
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> 
              <span class="keyword1"><span class="command">with</span></span> v_disc stack_set_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">≠</span><span class="skolem">u</span>›</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">with</span></span> tl_lt_stack_hd_discover finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&gt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
            <span class="keyword1"><span class="command">qed</span></span>

            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
              <span class="keyword1"><span class="command">using</span></span> parenthesis_impl_tree_path_not_finished<span class="main">[</span><span class="operator">OF</span> u_disc<span class="main">]</span> u_n_fin
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
            <span class="keyword1"><span class="command">with</span></span> trancl_mono_mp tree_edges_ssE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_eq_or_trancl<span class="main">)</span>

            <span class="keyword1"><span class="command">moreover</span></span>
            <span class="keyword1"><span class="command">from</span></span> tj_stack_reach_hd_stack v_tj finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 

            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> scc_of E <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> is_scc_closed <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"scc_of E <span class="skolem">u</span> <span class="main">⊆</span> <span class="var">?tw'</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> scc_of E <span class="skolem">u</span>"</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> u_root
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> s'.scc_root_finished_impl_scc_finished s'.no_finished_root
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> s'.finished_ss_sccs_tj_stack <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="skolem">s</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">v</span> <span class="main">∈</span> <span class="var">?tw'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="var">?tw'</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="skolem">s</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">scc</span></span> <span class="keyword2"><span class="keyword">where</span></span> scc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">scc</span> <span class="main">∈</span> sccs <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="skolem">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="main">(</span>scc_of E <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> v
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">scc</span> <span class="main">=</span> scc_of E <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> is_scc_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="skolem">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> scc sccs_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> u_n_fin <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?tw'</span> <span class="main">=</span> scc_of E <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="var">?tw'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>   
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff finish<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def tarjan_disc_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Tarjan_invar<span class="main">)</span> sccs_are_sccs <span class="main">=</span>
    i_sccs_are_sccs<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1" id="Tarjan-i_lowlink_eq_LowLink"><span class="command">lemma</span></span> i_lowlink_eq_LowLink<span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_invar <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">ζ</span> <span class="bound">s</span> <span class="bound">x</span> <span class="main">=</span> LowLink <span class="bound">s</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> tarjan_state"</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">w</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>

      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> pre_ll_sub_rev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span><span class="main">.</span> <span class="main">⟦</span>Tarjan_invar <span class="free">G</span> <span class="var">?s</span><span class="main">;</span> <span class="bound">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="var">?s</span><span class="main">)</span><span class="main">;</span> <span class="bound">w</span> <span class="main">≠</span> <span class="skolem">v</span><span class="main">⟧</span> <span class="main">⟹</span> lowlink_set <span class="var">?s</span> <span class="bound">w</span> <span class="main">⊆</span> lowlink_set <span class="skolem">s</span> <span class="bound">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> tree_sub <span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≠</span> <span class="skolem">v</span> <span class="main">∧</span> tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Tarjan_invar <span class="free">G</span> <span class="skolem">s</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
                     <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> finished <span class="skolem">s</span>"</span></span>
                     <span class="quoted"><span class="quoted">"lowlink <span class="skolem">s'</span> <span class="main">=</span> lowlink <span class="skolem">s</span>"</span></span>
                     <span class="quoted"><span class="quoted">"cross_edges <span class="skolem">s'</span> <span class="main">=</span> cross_edges <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"back_edges <span class="skolem">s'</span> <span class="main">=</span> back_edges <span class="skolem">s</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> v_n_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span><span class="main">.</span> <span class="bound">w</span><span class="main">∈</span>dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="bound">w</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="bound">w</span>"</span></span>

      <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_disc <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="var">?s</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> w_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="var">?s</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span>Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink <span class="var">?s</span> <span class="main">=</span> <span class="main">(</span>lowlink <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> tarjan_disc_def<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> v_n_disc edge_imp_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">s</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> tree_sub tree_edge_imp_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="var">?s</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> s'.no_path_imp_no_lowlink_path <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span><span class="main">.</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">v</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">hence</span></span> ll_v<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">=</span><span class="skolem">v</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> ll_v <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> w_disc False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> LowLink_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> v_n_disc <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"discovered <span class="skolem">s</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> discovered <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_le_def<span class="main">)</span>
          
          <span class="keyword1"><span class="command">from</span></span> tree_sub <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def lowlink_path_def
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> ll_v <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">using</span></span> pre_ll_sub_rev w_disc INV
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
          
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> w_disc False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ll</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> timing_less_counter lowlink_set_discovered <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="keyword1">δ</span> <span class="skolem">s</span><span class="main">`</span>lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">force</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> Min_in lowlink_set_finite lowlink_set_not_empty w_disc False <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∈</span> <span class="keyword1">δ</span> <span class="skolem">s</span><span class="main">`</span>lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> "</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> tarjan_disc_aux <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> establish_invarI_CB<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_root <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v0</span><span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="skolem">x</span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"new_root <span class="skolem">v0</span> <span class="skolem">s</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v0</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def lowlink_path_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> * <span class="main">=</span> this

      <span class="keyword1"><span class="command">from</span></span> new_root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> tarjan_disc_aux<span class="main">[</span><span class="operator">OF</span> *<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>discover <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"discover <span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">v</span> <span class="main">(</span><span class="skolem">s</span><span class="main">⦇</span>pending <span class="main">:=</span> pending <span class="skolem">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="skolem">x</span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"Tarjan_invar <span class="free">G</span> <span class="var">?s</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="var">?s'</span><span class="main">)</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">≠</span><span class="skolem">v</span>"</span></span>

        <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ll</span>
          <span class="keyword3"><span class="command">assume</span></span> ll<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">=</span> <span class="skolem">w</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="bound">p</span> <span class="skolem">ll</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> <span class="var">?L</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> d <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="bound">p</span> <span class="skolem">ll</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> p <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> p <span class="main">=</span> this

            <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
    
            <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def path_hd<span class="main">)</span>
            
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> tri_caseE<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">≠</span><span class="skolem">ll</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="skolem">s</span> <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">ll</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">ll</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> set <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="skolem">ll</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> <span class="quoted">"0"</span> <span class="keyword1"><span class="command">with</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">≠</span> <span class="skolem">v</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> i s'.lowlink_path_finished<span class="main">[</span><span class="operator">OF</span> p<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> j<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
                  <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> finished_discovered discover <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> * <span class="main">=</span> this
      
      <span class="keyword1"><span class="command">from</span></span> discover hd_in_set stack_set_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> discover <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_edges <span class="var">?s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≠</span> <span class="skolem">v</span> <span class="main">∧</span> tree_edges <span class="var">?s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> discover <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> tarjan_disc_aux<span class="main">[</span><span class="operator">OF</span> * **<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>cross_back_edge <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> cross_back_edge <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
        <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> discovered <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> finished <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"lowlink <span class="skolem">s'</span> <span class="main">=</span> lowlink <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span>"</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>

        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">`</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?L'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="var">?s</span> <span class="main">`</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>

        <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_back <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> inv'<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="var">?s</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> w_disc'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="var">?s</span><span class="main">)</span>"</span></span>
        
        <span class="keyword1"><span class="command">from</span></span> inv' <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span>Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
   
        <span class="keyword1"><span class="command">have</span></span> ll_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def lowlink_path_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
      
        <span class="keyword1"><span class="command">have</span></span> ll_sub_rev<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def lowlink_path_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>

        <span class="keyword1"><span class="command">from</span></span> w_disc' <span class="keyword1"><span class="command">have</span></span> w_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> LowLink_le_disc <span class="keyword1"><span class="command">have</span></span> LLw<span class="main">:</span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">from</span></span> cross_back_edge hd_in_set <span class="keyword1"><span class="command">have</span></span> u_n_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> stack_not_finished <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">⟹</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">v</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> LowLink_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inv' _ ll_sub ll_sub_rev w_disc<span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"discovered <span class="skolem">s</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> discovered <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ll</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> LL_eqI <span class="main">=</span> this

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">=</span><span class="skolem">u</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∧</span> <span class="skolem">v</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> all_False <span class="main">=</span> this
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">=</span> <span class="skolem">u</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> TRANS<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def cross_back_edge<span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> cross_back_edge w_disc <span class="keyword1"><span class="command">have</span></span> ζw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> LL_eqI<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">v</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∧</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span>›</span></span> ζw <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> all_False <span class="keyword1"><span class="command">have</span></span> v_n_tj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="main">(</span>tj_stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">from</span></span> v <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
                  <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">=</span><span class="skolem">u</span>›</span></span><span class="main">)</span>
                
                <span class="keyword1"><span class="command">from</span></span> v_n_tj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> set <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> stack_ss_tj_stack <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">with</span></span> cross_back_edge <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stack_set_def<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> finished_ss_sccs_tj_stack v_n_tj sccs_are_sccs <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">scc</span></span> 
                  <span class="keyword2"><span class="keyword">where</span></span> scc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">scc</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">scc</span> <span class="main">∈</span> sccs <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"is_scc E <span class="skolem">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">with</span></span> is_scc_closed e <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="skolem">scc</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
                <span class="keyword1"><span class="command">with</span></span> scc sccs_finished u_n_fin <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> all_True <span class="main">=</span> this
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">=</span><span class="skolem">u</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> TRANS<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def cross_back_edge<span class="main">)</span>

            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True cross_back_edge w_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">&lt;</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> lowlink_set_finite lowlink_set_not_empty w_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span> <span class="main">=</span> Min <span class="main">(</span><span class="var">?L</span> <span class="main">∪</span> <span class="main">{</span><span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command">have</span></span> cb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> cross_edges <span class="var">?s</span> <span class="main">∪</span> back_edges <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> s'.lowlink_path_single <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="var">?s</span> <span class="skolem">u</span> <span class="main">[</span><span class="skolem">u</span><span class="main">]</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> cb s'.cross_edges_ssE s'.back_edges_ssE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> all_True tj_stack_reach_hd_stack <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>›</span></span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> s'.lowlink_setI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">=</span><span class="skolem">u</span>›</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">with</span></span> ll_sub ll_sub_rev <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="var">?L</span> <span class="main">∪</span> <span class="main">{</span><span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">v</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>w ≠ u›</span></span>›</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> TRANS<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_back_def cross_back_edge<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> w_disc False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cross_back_edge<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> LL_eqI<span class="main">)</span>
            <span class="keyword3"><span class="command">assume</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> LLw
            <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span>
              <span class="keyword1"><span class="command">with</span></span> v <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def lowlink_path_def<span class="main">)</span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def path_hd<span class="main">)</span>

              <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="skolem">p</span>"</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> last_in_set p cross_back_edge <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="skolem">p</span> <span class="main">≠</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="skolem">s</span> <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cross_back_edge lowlink_path_def<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> v <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> 
                  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lowlink_setI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lowlink_set_def cross_back_edge<span class="main">)</span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> <span class="quoted">"0"</span> <span class="keyword1"><span class="command">with</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
                  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">≠</span> <span class="skolem">u</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> i s'.lowlink_path_finished<span class="main">[</span><span class="operator">OF</span> p<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> j<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
                    <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">with</span></span> u_n_fin <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">qed</span></span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux <span class="main">=</span> this
      
      <span class="keyword1"><span class="command">with</span></span> cross_back_edge <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>finish <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
        <span class="quoted"><span class="quoted">"discovered <span class="skolem">s'</span> <span class="main">=</span> discovered <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"finished <span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span><span class="main">(</span><span class="skolem">u</span><span class="main">↦</span>counter <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"tree_edges <span class="skolem">s'</span> <span class="main">=</span> tree_edges <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"back_edges <span class="skolem">s'</span> <span class="main">=</span> back_edges <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"cross_edges <span class="skolem">s'</span> <span class="main">=</span> cross_edges <span class="skolem">s</span>"</span></span>
        <span class="quoted"><span class="quoted">"lowlink <span class="skolem">s'</span> <span class="main">=</span> lowlink <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="skolem">s'</span> <span class="main">=</span> tj_stack <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

      <span class="keyword1"><span class="command">from</span></span> finish hd_in_set stack_discovered <span class="keyword1"><span class="command">have</span></span> u_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span>"</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>

        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">⦇</span>state.more <span class="main">:=</span> <span class="skolem">x</span><span class="main">⦈</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">`</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Lu</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">`</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?L'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="main">`</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>

        <span class="keyword3"><span class="command">assume</span></span> TRANS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Ψ</span><span class="main">.</span> tarjan_fin <span class="skolem">u</span> <span class="skolem">s'</span> <span class="keyword1">≤<span class="hidden">⇩</span><sub>n</sub></span> SPEC <span class="bound">Ψ</span> <span class="main">⟹</span> <span class="bound">Ψ</span> <span class="skolem">x</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> inv'<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="var">?s</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> w_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="var">?s</span><span class="main">)</span>"</span></span>

        <span class="keyword1"><span class="command">from</span></span> inv' <span class="keyword1"><span class="command">interpret</span></span> s'<span class="main">:</span>Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="quoted">"<span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
     
        <span class="keyword1"><span class="command">have</span></span> ll_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def lowlink_path_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
        <span class="keyword1"><span class="command">have</span></span> ll_sub_rev<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">⊆</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ll</span>
          <span class="keyword3"><span class="command">assume</span></span> ll<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">=</span> <span class="skolem">w</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="bound">p</span> <span class="skolem">ll</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">∪</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> 
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjE1<span class="main">)</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> w_disc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="bound">p</span> <span class="skolem">ll</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> p <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> p <span class="main">=</span> this

            <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
    
            <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def path_hd<span class="main">)</span>
            
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="skolem">p</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="skolem">s</span> <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">ll</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> True
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span>
              <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"drop <span class="skolem">i</span> <span class="skolem">p</span>"</span></span>

              <span class="keyword1"><span class="command">from</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dp</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

              <span class="keyword1"><span class="command">from</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="var">?dp</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_drop_conv_nth<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="var">?dp</span> <span class="main">=</span> last <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="var">?dp</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="var">?dp</span> <span class="main">-</span> <span class="main">1</span>"</span></span>

                <span class="keyword1"><span class="command">hence</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">+</span><span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span><span class="main">!</span><span class="main">(</span><span class="skolem">k</span><span class="main">+</span><span class="skolem">i</span><span class="main">)</span><span class="main">,</span> <span class="skolem">p</span><span class="main">!</span>Suc <span class="main">(</span><span class="skolem">k</span><span class="main">+</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> l <span class="keyword1"><span class="command">have</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">+</span><span class="skolem">k</span> <span class="main">≤</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">+</span>Suc <span class="skolem">k</span> <span class="main">≤</span> length <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?dp</span><span class="main">!</span><span class="skolem">k</span><span class="main">,</span><span class="var">?dp</span><span class="main">!</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
              <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux <span class="main">=</span> this
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> length <span class="var">?dp</span>"</span></span>
                <span class="keyword1"><span class="command">hence</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">+</span> <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> s'.lowlink_path_finished<span class="main">[</span><span class="operator">OF</span> p<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">!</span> <span class="main">(</span><span class="main">1</span><span class="main">+</span><span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">≤</span>length <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dp</span><span class="main">!</span><span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?dp</span><span class="main">!</span><span class="main">0</span><span class="main">,</span><span class="var">?dp</span><span class="main">!</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹hd <span class="var">?dp</span> <span class="main">=</span> <span class="skolem">u</span>›</span></span> hd_conv_nth<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?dp</span>"</span></span><span class="main">]</span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="var">?dp</span><span class="main">!</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> no_self_loop_in_tree <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dp</span><span class="main">!</span><span class="main">1</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dp</span><span class="main">!</span><span class="main">1</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">}</span></span>
              <span class="keyword1"><span class="command">moreover</span></span> 
                <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>

                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span>take <span class="skolem">i</span> <span class="skolem">p</span><span class="main">)</span><span class="main">@</span><span class="var">?dp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> P path_conc_conv <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> p'<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">x</span> <span class="var">?dp</span> <span class="skolem">ll</span>"</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">w</span> <span class="main">(</span>take <span class="skolem">i</span> <span class="skolem">p</span><span class="main">)</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?dp</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> path_hd <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="var">?dp</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹hd <span class="var">?dp</span> <span class="main">=</span> <span class="skolem">u</span>›</span></span> p' <span class="keyword1"><span class="command">have</span></span> u_path<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">u</span> <span class="var">?dp</span> <span class="skolem">ll</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> path_u<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">w</span> <span class="main">(</span>take <span class="skolem">i</span> <span class="skolem">p</span><span class="main">)</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span><span class="main"><span class="keyword3">+</span></span>

              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="skolem">s</span> <span class="skolem">u</span> <span class="var">?dp</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> u_path path_is_trancl <span class="quoted"><span class="quoted">‹<span class="var">?dp</span> <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">ll</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">from</span></span> ll <span class="quoted"><span class="quoted">‹<span class="skolem">ll</span> <span class="main">≠</span> <span class="skolem">w</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ll</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
                <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> path_u path_is_rtrancl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
                <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ll</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
              <span class="keyword1"><span class="command">}</span></span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> ll u_disc
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lowlink_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">hence</span></span> ll_sub_rev'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?L'</span> <span class="main">⊆</span> <span class="var">?L</span> <span class="main">∪</span> <span class="var">?Lu</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword1"><span class="command">have</span></span> ref_ne<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> 
             lowlink <span class="var">?s</span> <span class="main">=</span> <span class="main">(</span>lowlink <span class="skolem">s</span><span class="main">)</span><span class="main">(</span>hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span> <span class="main">↦</span> min <span class="main">(</span><span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="main">(</span>hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_vcg</span> <span class="operator">simp_all</span>
        
        <span class="keyword1"><span class="command">have</span></span> ref_e<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> lowlink <span class="var">?s</span> <span class="main">=</span> lowlink <span class="skolem">s</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_vcg</span> <span class="operator">simp_all</span>

        <span class="keyword1"><span class="command">have</span></span> ref_tj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">⟹</span> tj_stack <span class="var">?s</span> <span class="main">=</span> tj_stack <span class="skolem">s</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> TRANS<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_vcg</span> <span class="operator">simp_all</span>

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span> <span class="main">∧</span> stack <span class="var">?s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> all_True <span class="main">=</span> this
          <span class="keyword1"><span class="command">with</span></span> ref_ne <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> min <span class="main">(</span><span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">&lt;</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> * finish w_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> LowLink_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inv' _ ll_sub ll_sub_rev<span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command">from</span></span> w_disc <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ll</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> 
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> False finish w_disc u_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> LowLink <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="var">?s</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> ζrel <span class="main">=</span> this
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">∈</span> <span class="var">?L'</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command">from</span></span> all_True finish <span class="keyword1"><span class="command">have</span></span> w_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">∈</span>set <span class="main">(</span>tl <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

              <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ll</span></span> <span class="keyword2"><span class="keyword">where</span></span> ll<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">ll</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">u</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> Min_in<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?Lu</span></span></span><span class="main">]</span> lowlink_set_finite lowlink_set_not_empty u_disc
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">=</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> True
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> w_tl finish tl_lt_stack_hd_discover <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">&lt;</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> w_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LowLink_le_disc<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> w_disc finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> ζrel
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> u_disc finish ll <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword1"><span class="command">have</span></span>
                  e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ll</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">ll</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
                  p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="skolem">s</span> <span class="skolem">u</span> <span class="bound">p</span> <span class="skolem">ll</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
                  ll_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ll</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>

                <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> p'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">u</span> <span class="bound">p</span> <span class="skolem">ll</span>"</span></span>
                  <span class="keyword1"><span class="command">unfolding</span></span> lowlink_path_def
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">from</span></span> w_tl tl_stack_hd_tree_path finish <span class="keyword1"><span class="command">have</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="var">?s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> s'.lowlink_path_tree_prepend all_True p' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="bound">p</span> <span class="skolem">ll</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> T trancl_mono_mp<span class="main">[</span><span class="operator">OF</span> s'.tree_edges_ssE<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">with</span></span> e <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">ll</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                  <span class="keyword1"><span class="command">note</span></span> e<span class="main">(</span>1<span class="main">)</span>
                  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> finish False ref_tj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="var">?s</span> <span class="main">=</span> tj_stack <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">with</span></span> hd_in_set finish stack_ss_tj_stack <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">with</span></span> s'.tj_stack_reach_stack <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  <span class="keyword1"><span class="command">note</span></span> this<span class="main">(</span>2<span class="main">)</span>
                  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
                  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_eq_or_trancl<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD2<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
                    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> all_True x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>tl <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
                    <span class="keyword1"><span class="command">with</span></span> s'.tl_stack_hd_tree_path all_True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword1"><span class="command">with</span></span> trancl_mono_mp<span class="main">[</span><span class="operator">OF</span> tree_edges_ssE<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">qed</span></span>
                  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ll</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
                <span class="keyword1"><span class="command">}</span></span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> ll_disc
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
              <span class="keyword1"><span class="command">qed</span></span>               
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">δ</span> <span class="skolem">s</span> <span class="skolem">ll</span> <span class="main">∈</span> <span class="var">?L'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="var">?s</span> <span class="skolem">w</span> <span class="main">≤</span> LowLink <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> 
              <span class="keyword1"><span class="command">using</span></span> Min_le_iff<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?L'</span></span></span><span class="main">]</span> s'.lowlink_set_not_empty w_disc s'.lowlink_set_finite
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True u_disc w_disc finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">&lt;</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="var">?L</span> <span class="main">∪</span> <span class="var">?Lu</span><span class="main">)</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">u</span>"</span></span> 
              <span class="keyword1"><span class="command">using</span></span> Min_Un<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span> <span class="var"><span class="quoted"><span class="var">?Lu</span></span></span><span class="main">]</span> lowlink_set_finite lowlink_set_not_empty u_disc w_disc
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">≤</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span> 
              <span class="keyword1"><span class="command">using</span></span> Min_antimono<span class="main">[</span><span class="operator">OF</span> ll_sub_rev'<span class="main">]</span> lowlink_set_finite s'.lowlink_set_not_empty w_disc
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True u_disc finish * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">u</span> <span class="main">=</span> <span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> all_False <span class="main">=</span> this
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> <span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> ref_e <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> all_False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≠</span> hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> False ref_ne <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> finish <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> w_disc <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">u</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">≠</span> <span class="skolem">w</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">≠</span><span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∉</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="var">?s</span> <span class="skolem">w</span>"</span></span>
              <span class="keyword1"><span class="command">hence</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> v_disc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
              
              <span class="keyword1"><span class="command">from</span></span> v <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">≠</span><span class="skolem">w</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"lowlink_path <span class="var">?s</span> <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_set_def<span class="main">)</span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
              
              <span class="keyword1"><span class="command">from</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def path_hd<span class="main">)</span>
              
              <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> set <span class="skolem">p</span>"</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lowlink_path <span class="skolem">s</span> <span class="skolem">w</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lowlink_path_def<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> e v_disc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lowlink_setI<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> True
                <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_set_conv_nth<span class="main">)</span>
                <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> <span class="quoted">"0"</span> <span class="keyword1"><span class="command">with</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
                  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span> <span class="main">≠</span> <span class="skolem">u</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> i p <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span>
                    <span class="keyword1"><span class="command">unfolding</span></span> lowlink_path_def
                    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">with</span></span> tree_edge_imp_discovered <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> finish hd_in_set stack_not_finished <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword1"><span class="command">have</span></span> pn_n_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span> <span class="main">∉</span> dom <span class="main">(</span>finished <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tree_edge_impl_parenthesis<span class="main">)</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> * no_self_loop_in_tree <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span> <span class="main">∈</span> set <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> stack_set_def finish <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">hence</span></span> s_ne<span class="main">:</span> <span class="quoted"><span class="quoted">"stack <span class="var">?s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">with</span></span> all_False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≠</span> hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">from</span></span> stack_is_tree_path finish <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="keyword2"><span class="keyword">where</span></span>
                    <span class="quoted"><span class="quoted">"path <span class="main">(</span>tree_edges <span class="skolem">s</span><span class="main">)</span> <span class="skolem">v0</span> <span class="main">(</span>rev <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span><span class="main">)</span> <span class="skolem">u</span>"</span></span>
                    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">with</span></span> s_ne <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> tree_edges <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv path_simps<span class="main">)</span>
                  <span class="keyword1"><span class="command">with</span></span> * tree_eq_rule <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
                    <span class="keyword3"><span class="command">case</span></span> <span class="quoted">"0"</span> <span class="keyword1"><span class="command">with</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">p</span><span class="main">!</span><span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_conv_nth<span class="main">)</span>
                    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹hd <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">w</span>›</span></span> ** <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">≠</span>hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
                  <span class="keyword1"><span class="command">next</span></span>
                    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> * ** s'.lowlink_path_finished<span class="main">[</span><span class="operator">OF</span> p<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> j<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
                      <span class="quoted"><span class="quoted">"hd <span class="main">(</span>stack <span class="var">?s</span><span class="main">)</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="var">?s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">with</span></span> hd_in_set<span class="main">[</span><span class="operator">OF</span> s_ne<span class="main">]</span> s'.stack_not_finished <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  <span class="keyword1"><span class="command">qed</span></span>
                <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">with</span></span> ll_sub ll_sub_rev <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lowlink_set <span class="var">?s</span> <span class="skolem">w</span> <span class="main">=</span> lowlink_set <span class="skolem">s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"LowLink <span class="skolem">s</span> <span class="skolem">w</span> <span class="main">=</span> LowLink <span class="var">?s</span> <span class="skolem">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span>

      <span class="keyword1"><span class="command">with</span></span> finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> timing_syntax <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> lowlink_eq_LowLink <span class="main">=</span>
    i_lowlink_eq_LowLink<span class="main">[</span><span class="operator">THEN</span> make_invar_thm<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

  <span class="keyword1" id="Tarjan-lowlink_eq_disc_iff_scc_root"><span class="command">lemma</span></span> lowlink_eq_disc_iff_scc_root<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span>stack <span class="free">s</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">v</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> pending <span class="free">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> <span class="keyword1">δ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">⟷</span> scc_root <span class="free">s</span> <span class="free">v</span> <span class="main">(</span>scc_of E <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> dom <span class="main">(</span>discovered <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finished_discovered hd_in_set stack_discovered <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">ζ</span> <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> LowLink <span class="free">s</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lowlink_eq_LowLink <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> LowLink_eq_disc_iff_scc_root<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Tarjan-nc_sccs_eq_reachable"><span class="command">lemma</span></span> nc_sccs_eq_reachable<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> cond <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reachable <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">from</span></span> nc_finished_eq_reachable NC <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"reachable <span class="main">=</span> dom <span class="main">(</span>finished <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> sccs_finished <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>sccs <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> reachable"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> NC <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cond_alt<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> stacks_eq_iff <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tj_stack <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> finished_ss_sccs_tj_stack <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"reachable <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>sccs <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Tarjan <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Tarjan-tarjan_fin_nofail"><span class="command">lemma</span></span> tarjan_fin_nofail<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"pre_on_finish <span class="free">u</span> <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>tarjan_fin <span class="free">u</span> <span class="free">s'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> tarjan_params <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"stack <span class="skolem">s</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>  <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">=</span> hd <span class="main">(</span>stack <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s'</span> <span class="main">=</span> finish <span class="free">u</span> <span class="skolem">s</span>"</span></span>  <span class="quoted"><span class="quoted">"cond <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"pending <span class="skolem">s</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_on_finish_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">=</span><span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> s hd_stack_in_tj_stack <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> set <span class="main">(</span>tj_stack <span class="free">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> s tj_stack_distinct <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>tj_stack <span class="free">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>lowlink <span class="free">s'</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span>discovered <span class="free">s'</span> <span class="free">u</span><span class="main">)</span> <span class="main">⟷</span> scc_root <span class="free">s'</span> <span class="free">u</span> <span class="main">(</span>scc_of E <span class="free">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span>lowlink <span class="free">s'</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span>discovered <span class="free">s'</span> <span class="free">u</span><span class="main">)</span> <span class="main">⟷</span> the <span class="main">(</span>lowlink <span class="skolem">s</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span>discovered <span class="skolem">s</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> s lowlink_eq_disc_iff_scc_root <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">⟷</span> scc_root <span class="skolem">s</span> <span class="free">u</span> <span class="main">(</span>scc_of E <span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> s scc_root_transfer'<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">s'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">⟷</span> scc_root <span class="free">s'</span> <span class="free">u</span> <span class="main">(</span>scc_of E <span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> tarjan_fin_def tj_stack_pop_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">sublocale</span></span> DFS <span class="quoted"><span class="free">G</span></span> <span class="quoted">tarjan_params</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tarjan_disc_def tarjan_back_def tarjan_fin_nofail<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> tarjan<span class="main">:</span> Tarjan_def <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Interface›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">tarjan</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">s</span> <span class="main">←</span> tarjan.it_dfs <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">;</span>
  RETURN <span class="main">(</span>sccs <span class="bound">s</span><span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">tarjan_spec</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  ASSERT <span class="main">(</span>fb_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">;</span> 
  SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">sccs</span><span class="main">.</span>  <span class="main">(</span><span class="main">∀</span><span class="bound">scc</span> <span class="main">∈</span> <span class="bound">sccs</span><span class="main">.</span> is_scc <span class="main">(</span>g_E <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">scc</span><span class="main">)</span>
              <span class="main">∧</span> <span class="main">⋃</span><span class="bound">sccs</span> <span class="main">=</span> tarjan.reachable <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Tarjan-tarjan_correct"><span class="command">lemma</span></span> tarjan_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tarjan <span class="free">G</span> <span class="main">≤</span> tarjan_spec <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> tarjan_def tarjan_spec_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">refine_vcg</span> le_ASSERTI order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> DFS.it_dfs_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fb_graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> Tarjan <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"DFS <span class="free">G</span> <span class="main">(</span>tarjan.tarjan_params <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"DFS_invar <span class="free">G</span> <span class="main">(</span>tarjan.tarjan_params <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span><span class="main">)</span> <span class="skolem">s</span> <span class="main">∧</span> <span class="main">¬</span> tarjan.cond <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Tarjan_invar <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="skolem">s</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">from</span></span> sccs_are_sccs <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">scc</span><span class="main">∈</span>sccs <span class="skolem">s</span><span class="main">.</span> is_scc <span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span> <span class="bound">scc</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> nc_sccs_eq_reachable C <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>sccs <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> tarjan.reachable <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DFS_All_Examples">
<div class="head">
<h1>Theory DFS_All_Examples</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> DFS_All_Examples
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Cyc_Check.html">Cyc_Check</a>
  <a href="DFS_Find_Path.html">DFS_Find_Path</a>
  <a href="Feedback_Arcs.html">Feedback_Arcs</a>
  <a href="Nested_DFS.html">Nested_DFS</a>
  <a href="Reachable_Nodes.html">Reachable_Nodes</a>
  <a href="Tarjan_LowLink.html">Tarjan_LowLink</a>
  <a href="Tarjan.html">Tarjan</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>