<div id="Generic_Push_Relabel">
<div class="head">
<h1>Theory Generic_Push_Relabel</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generic Push Relabel Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Generic_Push_Relabel
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../flow_networks/theories/#Fofu_Abs_Base">Flow_Networks.Fofu_Abs_Base</a>
  <a href="../../flow_networks/theories/#Ford_Fulkerson">Flow_Networks.Ford_Fulkerson</a>
<span class="keyword2"><span class="keyword">begin</span></span>

  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Labeling›</span></span>
 
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The central idea of the push-relabel algorithm is to add natural number
  labels <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l : node ⇒ nat›</span></span></span></span> to each node, and maintain the invariant that for 
  all edges <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(u,v)›</span></span></span></span> in the residual graph, we have <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l u ≤ l v + 1›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> labeling <span class="main">=</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> nat"</span></span>
  
<span class="keyword1"><span class="command">locale</span></span> Labeling <span class="main">=</span> NPreflow <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="main">::</span> <span class="quoted">labeling</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> valid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> cf.E <span class="main">⟹</span> <span class="free">l</span><span class="main">(</span><span class="free">u</span><span class="main">)</span> <span class="main">≤</span> <span class="free">l</span><span class="main">(</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lab_src<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">s</span> <span class="main">=</span> card V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lab_sink<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">t</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Generalizing validity to paths›</span></span>
<span class="keyword1" id="Generic_Push_Relabel-gen_valid"><span class="command">lemma</span></span> gen_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">(</span><span class="free">u</span><span class="main">)</span> <span class="main">≤</span> <span class="free">l</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">+</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">u</span> <span class="free">p</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In a valid labeling, there cannot be an augmenting path~\cormen{26.17}.

  The proof works by contradiction, using the validity constraint 
  to show that any augmenting path would be too long for a simple path.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> no_augmenting_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>isAugmentingPath <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>  
  <span class="keyword1"><span class="command">hence</span></span> SP<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> isAugmentingPath_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.isSimplePath_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> gen_valid<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">≥</span> card V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> cf.simplePath_length_less_V<span class="main">[</span><span class="operator">OF</span> _ SP<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The idea of push relabel algorithms is to maintain a valid labeling,
  and, ultimately, arrive at a valid flow, i.e., no nodes have excess flow. 
  We then immediately get that the flow is maximal:
›</span></span>  
<span class="keyword1"><span class="command">corollary</span></span> no_excess_imp_maxflow<span class="main">:</span>    
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">interpret</span></span> NFlow 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> 
    <span class="keyword1"><span class="command">using</span></span> no_deficient_nodes <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> noAugPath_iff_maxFlow no_augmenting_path <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Labeling›</span>
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Operations›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The operations of the push relabel algorithm are local operations on 
  single nodes and edges.  
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Augmentation of Edges›</span></span>
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a function to augment a single edge in the residual graph.›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">augment_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">augment_edge</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">Δ</span><span class="main">.</span> 
    <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">(</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">+</span> <span class="bound">Δ</span> <span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span>E <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">(</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">-</span> <span class="bound">Δ</span> <span class="main">)</span>
    <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-augment_edge_zero"><span class="command">lemma</span></span> augment_edge_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"augment_edge <span class="free">f</span> <span class="free">e</span> <span class="main">0</span> <span class="main">=</span> <span class="free">f</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> 
    
<span class="keyword1" id="Generic_Push_Relabel-augment_edge_same"><span class="command">lemma</span></span> augment_edge_same<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∈</span>E <span class="main">⟹</span> augment_edge <span class="free">f</span> <span class="free">e</span> <span class="free">Δ</span> <span class="free">e</span> <span class="main">=</span> <span class="free">f</span> <span class="free">e</span> <span class="main">+</span> <span class="free">Δ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    
<span class="keyword1" id="Generic_Push_Relabel-augment_edge_other"><span class="command">lemma</span></span> augment_edge_other<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">e</span><span class="main">∈</span>E<span class="main">;</span> <span class="free">e'</span><span class="main">≠</span><span class="free">e</span> <span class="main">⟧</span> <span class="main">⟹</span> augment_edge <span class="free">f</span> <span class="free">e</span> <span class="free">Δ</span> <span class="free">e'</span> <span class="main">=</span> <span class="free">f</span> <span class="free">e'</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="Generic_Push_Relabel-augment_edge_rev_same"><span class="command">lemma</span></span> augment_edge_rev_same<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E <span class="main">⟹</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">-</span> <span class="free">Δ</span>"</span></span>    
  <span class="keyword1"><span class="command">using</span></span> no_parallel_edge
  <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="Generic_Push_Relabel-augment_edge_rev_other"><span class="command">lemma</span></span> augment_edge_rev_other<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>E<span class="main">;</span> <span class="free">e'</span><span class="main">≠</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="free">e'</span> <span class="main">=</span> <span class="free">f</span> <span class="free">e'</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="Generic_Push_Relabel-augment_edge_cf"><span class="command">lemma</span></span> augment_edge_cf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span> <span class="main">⟹</span> 
    cf_of <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> 
  <span class="main">=</span> <span class="main">(</span>cf_of <span class="free">f</span><span class="main">)</span><span class="main">(</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">:=</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">Δ</span><span class="main">,</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">:=</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="free">Δ</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> e' 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span><span class="main">=</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_self_loop residualGraph_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span><span class="main">=</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_parallel_edge residualGraph_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> 
                  <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits prod.splits 
                  <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> residualGraph_def augment_edge_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> e'
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span><span class="main">=</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_self_loop residualGraph_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span><span class="main">=</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_self_loop residualGraph_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> 
                  <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits prod.splits 
                  <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> residualGraph_def augment_edge_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword1" id="Generic_Push_Relabel-augment_edge_cf'"><span class="command">lemma</span></span> augment_edge_cf'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span> <span class="main">⟹</span> 
    cf_of <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> 
  <span class="main">=</span> <span class="main">(</span>cf_of <span class="free">f</span><span class="main">)</span><span class="main">(</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">:=</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">Δ</span><span class="main">,</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">:=</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="free">Δ</span><span class="main">)</span>"</span></span>    
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> cfE_of_ss_invE <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The effect of augmenting an edge on the residual graph›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">augment_edge_cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> flow <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">augment_edge_cf</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> 
    <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">Δ</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span><span class="main">(</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="bound">Δ</span><span class="main">,</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">+</span> <span class="bound">Δ</span><span class="main">)</span>"</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-cf_of_augment_edge"><span class="command">lemma</span></span> cf_of_augment_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cf_of <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">=</span> augment_edge_cf <span class="main">(</span>cf_of <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cf_of <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">=</span> augment_edge_cf <span class="main">(</span>cf_of <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_edge_cf_def A augment_edge_cf'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>      
  
  
  
<span class="keyword1" id="Generic_Push_Relabel-cfE_augment_ss"><span class="command">lemma</span></span> cfE_augment_ss<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EDGE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cfE_of <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">⊆</span> insert <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">(</span>cfE_of <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> EDGE  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_edge_cf'<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>  
  
<span class="keyword1"><span class="command">context</span></span> NPreflow <span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Augmenting an edge <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(u,v)›</span></span></span></span> with a flow <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Δ›</span></span></span></span> that does not exceed the 
  available edge capacity, nor the available excess flow on the source node,
  preserves the preflow property.
›</span></span>  
<span class="keyword1" id="Generic_Push_Relabel-augment_edge_preflow_preserve"><span class="command">lemma</span></span> augment_edge_preflow_preserve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">0</span><span class="main">≤</span><span class="free">Δ</span><span class="main">;</span> <span class="free">Δ</span> <span class="main">≤</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">;</span> <span class="free">Δ</span> <span class="main">≤</span> excess <span class="free">f</span> <span class="free">u</span><span class="main">⟧</span> 
  <span class="main">⟹</span> Preflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def augment_edge_def  
    <span class="keyword1"><span class="command">using</span></span> capacity_const
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ballI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">≤</span><span class="free">Δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Δ</span> <span class="main">≤</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Δ</span> <span class="main">≤</span> excess <span class="free">f</span> <span class="free">u</span>"</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span>
    <span class="keyword3"><span class="command">assume</span></span> V'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">t</span>"</span></span>  
      
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>outgoing <span class="skolem">v'</span><span class="main">)</span>
            <span class="main">≤</span> sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>incoming <span class="skolem">v'</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">Δ</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> no_deficient_nodes <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> V' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">Δ</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">0</span><span class="main">≤</span><span class="free">Δ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">&lt;</span><span class="free">Δ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">Δ</span> <span class="main">≤</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>    
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> AE<span class="main">:</span> <span class="quoted"><span class="quoted">"augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">:=</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">Δ</span> <span class="main">)</span>"</span></span>  
          <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="skolem">v'</span><span class="main">.</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="bound">e</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">u</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> outgoing_def AE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="skolem">v'</span><span class="main">.</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="bound">e</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">v</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> incoming_def AE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E›</span></span> no_self_loop <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">≠</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> 1 2 V' no_deficient_nodes <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>outgoing <span class="skolem">v'</span><span class="main">)</span> 
              <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span>"</span></span>  
            <span class="keyword1"><span class="command">using</span></span> 1 <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≠</span><span class="free">v</span>›</span></span> V' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> V' no_deficient_nodes <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum_mono<span class="main">)</span>
            <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">0</span><span class="main">≤</span><span class="free">Δ</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def augment_edge_def <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="free">u</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> A1<span class="main">:</span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>incoming <span class="skolem">v'</span><span class="main">)</span> 
                  <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span>"</span></span>  
            <span class="keyword1"><span class="command">using</span></span> 2 <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≠</span><span class="free">v</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> outgoing <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E›</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def<span class="main">)</span>
          <span class="keyword1"><span class="command">note</span></span> AUX <span class="main">=</span> sum.remove<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
          <span class="keyword1"><span class="command">have</span></span> A2<span class="main">:</span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> 
                  <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="free">Δ</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> AUX<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span>"</span></span><span class="main">]</span> AUX<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">f</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> A1 A2 <span class="quoted"><span class="quoted">‹<span class="free">Δ</span> <span class="main">≤</span> excess <span class="free">f</span> <span class="free">u</span>›</span></span> no_deficient_nodes V' <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>E›</span></span> 
        <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cf.E›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>E›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        
        <span class="keyword1"><span class="command">have</span></span> AE<span class="main">:</span> <span class="quoted"><span class="quoted">"augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">:=</span> <span class="free">f</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">-</span> <span class="free">Δ</span> <span class="main">)</span>"</span></span>  
          <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="skolem">v'</span><span class="main">.</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="bound">e</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">v</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> outgoing_def AE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="skolem">v'</span><span class="main">.</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span> <span class="bound">e</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">u</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> incoming_def AE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">≠</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> 1 2 V' no_deficient_nodes <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="free">u</span>"</span></span> 
          <span class="keyword1"><span class="command">have</span></span> A1<span class="main">:</span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>outgoing <span class="skolem">v'</span><span class="main">)</span> 
                  <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span>"</span></span>  
            <span class="keyword1"><span class="command">using</span></span> 1 <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≠</span><span class="free">v</span>›</span></span> V' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> incoming <span class="free">u</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def<span class="main">)</span>
          <span class="keyword1"><span class="command">note</span></span> AUX <span class="main">=</span> sum.remove<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>    
          <span class="keyword1"><span class="command">have</span></span> A2<span class="main">:</span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> 
                  <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> <span class="main">-</span> <span class="free">Δ</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> AUX<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span>"</span></span><span class="main">]</span> AUX<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">f</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              
          <span class="keyword1"><span class="command">from</span></span> A1 A2 <span class="quoted"><span class="quoted">‹<span class="free">Δ</span> <span class="main">≤</span> excess <span class="free">f</span> <span class="free">u</span>›</span></span> no_deficient_nodes V' <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="free">v</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>outgoing <span class="skolem">v'</span><span class="main">)</span> 
              <span class="main">≤</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="skolem">v'</span><span class="main">)</span>"</span></span>  
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum_mono<span class="main">)</span>
            <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">0</span><span class="main">&lt;</span><span class="free">Δ</span>›</span></span>  
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_edge_def<span class="main">)</span>  
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> no_deficient_nodes V' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> sum <span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">Δ</span><span class="main">)</span> <span class="main">(</span>incoming <span class="skolem">v'</span><span class="main">)</span>"</span></span>    
            <span class="keyword1"><span class="command">using</span></span> 2 <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≠</span><span class="free">v</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>      
    <span class="keyword1"><span class="command">qed</span></span>              
  <span class="keyword1"><span class="command">qed</span></span>          
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>            
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with Preflow›</span> 

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Push Operation›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The push operation pushes as much flow as possible flow from an active 
  node over an admissible edge.

  A node is called \emph{active} if it has positive excess, and an edge <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(u,v)›</span></span></span></span>
  of the residual graph is called admissible, if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">l</span></span> <span class="free"><span class="free">u</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">l</span></span> <span class="free"><span class="free">v</span></span> <span class="main"><span class="main">+</span></span> <span class="main"><span class="main">1</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span> 
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">push_precond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> labeling <span class="main">⇒</span> edge <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">push_precond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
    <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">u</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">u</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The maximum possible flow is determined by the available excess flow at 
  the source node and the available capacity of the edge.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">push_effect</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> edge <span class="main">⇒</span> <span class="tfree">'capacity</span> flow"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">push_effect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> 
    <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> augment_edge <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">(</span>min <span class="main">(</span>excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">(</span>cf_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Generic_Push_Relabel-push_precondI"><span class="command">lemma</span></span> push_precondI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span><span class="main">;</span> <span class="free">l</span> <span class="free">u</span> <span class="main">=</span> <span class="free">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">⟧</span> <span class="main">⟹</span> push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Relabel Operation›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  An active node (not the sink) without any outgoing admissible edges 
  can be relabeled. 
›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">relabel_precond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> labeling <span class="main">⇒</span> node <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel_precond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> 
    <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">≠</span><span class="free">t</span> <span class="main">∧</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The new label is computed from the neighbour's labels, to be the minimum
  value that will create an outgoing admissible edge.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">relabel_effect</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> labeling <span class="main">⇒</span> node <span class="main">⇒</span> labeling"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel_effect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> 
    <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">(</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> Min <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">}</span> <span class="main">+</span> <span class="main">1</span> <span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Initialization›</span></span>
<span class="comment1">(* TODO: The algorithm can be initialized with other labelings ... 
  reflect this in abstract complexity/correctness theorem.*)</span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The initial preflow exhausts all outgoing edges of the source node.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_f</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">=</span><span class="free">s</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The initial labeling labels the source with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>|V|›</span></span></span></span>, and all other nodes
  with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>0›</span></span></span></span>.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_l</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">(</span><span class="free">s</span> <span class="main">:=</span> card V<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Correctness›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We formalize the abstract correctness argument of the algorithm. 
  It consists of two parts:
    <span class="antiquoted"><span class="antiquoted">▸</span></span> Execution of push and relabel operations maintain a valid labeling
    <span class="antiquoted"><span class="antiquoted">▸</span></span> If no push or relabel operations can be executed, the preflow is actually 
      a flow.

  This section corresponds to the proof of \cormen{26.18}.
›</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Maintenance of Invariants›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>  
  
<span class="keyword1" id="Generic_Push_Relabel-pp_init_invar"><span class="command">lemma</span></span> pp_init_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> pp_init_f pp_init_l"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span>
      <span class="main">(</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pp_init_f_def pp_init_l_def cap_non_negative<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span> 
        <span class="main"><span class="keyword3">|</span></span> <span class="main">(</span><span class="operator">intro</span> ballI<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main">)</span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="skolem">v</span><span class="main">.</span> pp_init_f <span class="bound">e</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def pp_init_f_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sum pp_init_f <span class="main">(</span>outgoing <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> pp_init_f <span class="skolem">e</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">e</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pp_init_f_def cap_non_negative <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> sum_bounded_below<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"incoming <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="main">0</span></span> <span class="quoted">pp_init_f</span><span class="main">,</span> <span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> sum pp_init_f <span class="main">(</span>incoming <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"sum pp_init_f <span class="main">(</span>outgoing <span class="skolem">v</span><span class="main">)</span> <span class="main">≤</span> sum pp_init_f <span class="main">(</span>incoming <span class="skolem">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> Graph.E <span class="main">(</span>residualGraph <span class="free">c</span> pp_init_f<span class="main">)</span>"</span></span>  
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"pp_init_l <span class="skolem">u</span> <span class="main">≤</span> pp_init_l <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pp_init_l_def Graph.E_def pp_init_f_def residualGraph_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
      
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1" id="Generic_Push_Relabel-pp_init_f_preflow"><span class="command">lemma</span></span> pp_init_f_preflow<span class="main">:</span> <span class="quoted"><span class="quoted">"NPreflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> pp_init_f"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> pp_init_invar <span class="keyword1"><span class="command">interpret</span></span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">pp_init_f</span> <span class="quoted">pp_init_l</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>    
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>  

<span class="keyword1"><span class="command">context</span></span> Labeling
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Push operations preserve a valid labeling~\cormen{26.16}.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> push_pres_Labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> push_effect_def  
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>    
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">=</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>min <span class="main">(</span>excess <span class="free">f</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">(</span>cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span>   
    ACTIVE<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="skolem">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> EDGE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> ADM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="skolem">u</span> <span class="main">=</span> <span class="free">l</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">interpret</span></span> cf'<span class="main">:</span> Preflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> augment_edge_preflow_preserve<span class="main">)</span>
   <span class="keyword1"><span class="command">using</span></span> ACTIVE resE_nonNegative  
   <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="var">?f'</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">using</span></span> valid
    <span class="keyword1"><span class="command">using</span></span> cfE_augment_ss<span class="main">[</span><span class="operator">OF</span> EDGE<span class="main">]</span> ADM
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1" id="Generic_Push_Relabel-finite_min_cf_outgoing"><span class="command">lemma</span></span> finite_min_cf_outgoing<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="free">l</span> <span class="bound">v</span> <span class="main">|</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main">}</span>"</span></span>    
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">l</span> <span class="bound">v</span> <span class="main">|</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main">}</span> <span class="main">=</span> <span class="free">l</span><span class="main">`</span>snd<span class="main">`</span>cf.outgoing <span class="free">u</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.outgoing_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">l</span><span class="main">`</span>snd<span class="main">`</span>cf.outgoing <span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relabel operations preserve a valid labeling~\cormen{26.16}. 
  Moreover, they increase the label of the relabeled node~\cormen{26.15}.
›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> relabel_increase_u<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="free">l</span> <span class="free">u</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> relabel_pres_Labeling<span class="main">:</span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span>  
        NOT_SINK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">t</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ACTIVE<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> NO_ADM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">⟹</span> <span class="free">l</span> <span class="free">u</span> <span class="main">≠</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">from</span></span> ACTIVE <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≠</span><span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> excess_s_non_pos <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">from</span></span> active_has_cf_outgoing<span class="main">[</span><span class="operator">OF</span> ACTIVE<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.outgoing_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> NO_ADM valid <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="free">l</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_less_le that<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> LU_INCR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> Min <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_Suc_eq_le<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> valid <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u'</span><span class="main">.</span> <span class="main">(</span><span class="bound">u'</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">⟶</span> <span class="free">l</span> <span class="bound">u'</span> <span class="main">≤</span> Min <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">}</span> <span class="main">+</span> <span class="main">1</span>"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> ab_semigroup_add_class.add.commute add_le_cancel_left le_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">⟶</span> Min <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">}</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Min_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relabel_effect_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> PRE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> LU_INCR <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_Suc_eq_le<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u' v' <span class="keyword1"><span class="command">using</span></span> valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> NOT_SINK <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>      
 
<span class="keyword1" id="Generic_Push_Relabel-relabel_preserve_other"><span class="command">lemma</span></span> relabel_preserve_other<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span> <span class="main">⟹</span> relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span> <span class="free">v</span> <span class="main">=</span> <span class="free">l</span> <span class="free">v</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_effect_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Maxflow on Termination›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If no push or relabel operations can be performed any more,
  we have arrived at a maximal flow.
›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> push_relabel_term_imp_maxflow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_push<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E<span class="main">.</span> <span class="main">¬</span>push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_relabel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="main">¬</span>relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="bound">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def relabel_precond_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span> 
  <span class="keyword1"><span class="command">with</span></span> excess_non_negative <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">with</span></span> no_excess_imp_maxflow <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span> 
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Labeling›</span>  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Convenience Lemmas›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a locale to reflect the effect of a push operation›</span></span>  
<span class="keyword1"><span class="command">locale</span></span> push_effect_locale <span class="main">=</span> Labeling <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">u</span> <span class="free">v</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>    
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">≡</span> push_effect <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> l'<span class="main">:</span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f'</span> <span class="quoted"><span class="free">l</span></span>  
    <span class="keyword1"><span class="command">using</span></span> push_pres_Labeling<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1" id="Generic_Push_Relabel-uv_cf_edge"><span class="command">lemma</span></span> uv_cf_edge<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> PRE <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1" id="Generic_Push_Relabel-excess_u_pos"><span class="command">lemma</span></span> excess_u_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> PRE <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>   
  <span class="keyword1" id="Generic_Push_Relabel-l_u_eq"><span class="command">lemma</span></span> l_u_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">u</span> <span class="main">=</span> <span class="free">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> PRE <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>   

  <span class="keyword1" id="Generic_Push_Relabel-uv_edge_cases"><span class="command">lemma</span></span> uv_edge_cases<span class="main">:</span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>par<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>E"</span></span> 
          <span class="main">|</span> <span class="main">(</span>rev<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>E"</span></span>
    <span class="keyword1"><span class="command">using</span></span> uv_cf_edge cfE_ss_invE no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  

  <span class="keyword1" id="Generic_Push_Relabel-uv_nodes"><span class="command">lemma</span></span> uv_nodes<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>V"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> E_ss_VxV cfE_ss_invE no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1" id="Generic_Push_Relabel-uv_not_eq"><span class="command">lemma</span></span> uv_not_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">≠</span><span class="free">u</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> E_ss_VxV cfE_ss_invE<span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">OF</span> uv_cf_edge<span class="main">]</span> no_parallel_edge 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Δ</span> <span class="main">=</span> min <span class="main">(</span>excess <span class="free">f</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span>"</span></span>    
    
  <span class="keyword1" id="Generic_Push_Relabel-Δ_positive"><span class="command">lemma</span></span> Δ_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"Δ <span class="main">&gt;</span> <span class="main">0</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> Δ_def 
    <span class="keyword1"><span class="command">using</span></span> excess_u_pos uv_cf_edge<span class="main">[</span><span class="operator">unfolded</span> cf.E_def<span class="main">]</span> resE_positive 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1" id="Generic_Push_Relabel-f'_alt"><span class="command">lemma</span></span> f'_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"f' <span class="main">=</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> Δ"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> push_effect_def Δ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1" id="Generic_Push_Relabel-cf'_alt"><span class="command">lemma</span></span> cf'_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"l'.cf <span class="main">=</span> augment_edge_cf cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> Δ"</span></span>    
    <span class="keyword1"><span class="command">unfolding</span></span> push_effect_def Δ_def augment_edge_cf_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_edge_cf'<span class="main">)</span>
      
  <span class="keyword1" id="Generic_Push_Relabel-excess'_u"><span class="command">lemma</span></span> excess'_u<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"excess f' <span class="free">u</span> <span class="main">=</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">-</span> Δ"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> excess_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">f'</span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> <span class="main">-</span> sum f' <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> <span class="main">=</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">-</span> Δ"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> uv_edge_cases<span class="main">)</span>  
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> par 
      <span class="keyword1"><span class="command">hence</span></span> UV_ONI<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>outgoing <span class="free">u</span> <span class="main">-</span> incoming <span class="free">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def no_self_loop<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span>"</span></span>    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> UV_ONI <span class="keyword1"><span class="command">unfolding</span></span> f'_alt
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> augment_edge_other<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
          
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> 
        <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>outgoing <span class="free">u</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="keyword1">then</span> Δ <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> f'_alt augment_edge_def sum.distrib<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> <span class="main">+</span> Δ"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> UV_ONI <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.delta<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">next</span></span>  
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> rev 
      <span class="keyword1"><span class="command">have</span></span> UV_INO<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>incoming <span class="free">u</span> <span class="main">-</span> outgoing <span class="free">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def no_self_loop<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span>"</span></span>    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">unfolding</span></span> f'_alt
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> augment_edge_rev_other<span class="main">)</span>  
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> 
        <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>incoming <span class="free">u</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">-</span> Δ <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> f'_alt augment_edge_def sum.distrib<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> <span class="main">-</span> Δ"</span></span>  
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.delta<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>      
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1" id="Generic_Push_Relabel-excess'_v"><span class="command">lemma</span></span> excess'_v<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"excess f' <span class="free">v</span> <span class="main">=</span> excess <span class="free">f</span> <span class="free">v</span> <span class="main">+</span> Δ"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> excess_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">f'</span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span> <span class="main">-</span> sum f' <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span> <span class="main">=</span> excess <span class="free">f</span> <span class="free">v</span> <span class="main">+</span> Δ"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> uv_edge_cases<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> par 
      <span class="keyword1"><span class="command">have</span></span> UV_INO<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>incoming <span class="free">v</span> <span class="main">-</span> outgoing <span class="free">v</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> incoming_def outgoing_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_self_loop<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span>"</span></span>    
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">unfolding</span></span> f'_alt
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_edge_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum.cong<span class="main">)</span>
          
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span> 
        <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>incoming <span class="free">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="keyword1">then</span> Δ <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>    
        <span class="keyword1"><span class="command">unfolding</span></span> f'_alt augment_edge_def sum.distrib<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">unfolding</span></span> f'_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Δ"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.delta<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> rev
      <span class="keyword1"><span class="command">have</span></span> UV_INO<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>outgoing <span class="free">v</span> <span class="main">-</span> incoming <span class="free">v</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def no_self_loop<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">v</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">unfolding</span></span> f'_alt
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_edge_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum.cong<span class="main">)</span>
          
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span> 
        <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>outgoing <span class="free">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">-</span> Δ <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>    
        <span class="keyword1"><span class="command">unfolding</span></span> f'_alt augment_edge_def sum.distrib<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">unfolding</span></span> f'_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">v</span><span class="main">)</span> <span class="main">-</span> Δ"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> UV_INO <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.delta<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>  
    
  <span class="keyword1" id="Generic_Push_Relabel-excess'_other"><span class="command">lemma</span></span> excess'_other<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>  
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"excess f' <span class="free">x</span> <span class="main">=</span> excess <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>incoming <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>outgoing <span class="free">x</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>incoming <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>outgoing <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> incoming_def outgoing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>outgoing <span class="free">x</span><span class="main">)</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"sum f' <span class="main">(</span>incoming <span class="free">x</span><span class="main">)</span> <span class="main">=</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_edge_def f'_alt NE 
            <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_split 
            <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum.cong<span class="main">)</span>  
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
      <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>      

  <span class="keyword1" id="Generic_Push_Relabel-excess'_if"><span class="command">lemma</span></span> excess'_if<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"excess f' <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>
           <span class="keyword1">if</span> <span class="free">x</span><span class="main">=</span><span class="free">u</span> <span class="keyword1">then</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">-</span> Δ 
      <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">x</span><span class="main">=</span><span class="free">v</span> <span class="keyword1">then</span> excess <span class="free">f</span> <span class="free">v</span> <span class="main">+</span> Δ 
         <span class="keyword1">else</span> excess <span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Push Effect Locale›</span> 
  
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Complexity›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, we analyze the complexity of the generic push relabel algorithm.
  We will show that it has a complexity of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>E)›</span></span></span></span> basic operations.
  Here, we often trade precise estimation of constant factors for simplicity
  of the proof.
›</span></span>  
 
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>  
  
<span class="keyword1" id="Generic_Push_Relabel-cardE_nz_aux"><span class="command">lemma</span></span> cardE_nz_aux<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"card E <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"card E <span class="main">≥</span> Suc <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"card E <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card E <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> E_not_empty<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"card E <span class="main">≥</span> Suc <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"card E <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The number of nodes can be estimated by the number of edges.
  This estimation is done in various places to get smoother bounds.
›</span></span>  
<span class="keyword1" id="Generic_Push_Relabel-card_V_est_E"><span class="command">lemma</span></span> card_V_est_E<span class="main">:</span> <span class="quoted"><span class="quoted">"card V <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card E"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card V <span class="main">≤</span> card <span class="main">(</span>fst<span class="main">`</span>E<span class="main">)</span> <span class="main">+</span> card <span class="main">(</span>snd<span class="main">`</span>E<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card_Un_le V_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> card_image_le<span class="main">[</span><span class="operator">OF</span> finite_E<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> card_image_le<span class="main">[</span><span class="operator">OF</span> finite_E<span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card V <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  
  

<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Height Bound›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A crucial idea of estimating the complexity is the insight that 
  no label will exceed <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>2|V|-1›</span></span></span></span> during the algorithm.

  We define a locale that states this invariant, and show that the algorithm
  maintains it. The corresponds to the proof of \cormen{26.20}.
›</span></span>  
<span class="keyword1"><span class="command">locale</span></span> Height_Bounded_Labeling <span class="main">=</span> Labeling <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> height_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">l</span> <span class="bound">u</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>    
  <span class="keyword1" id="Generic_Push_Relabel-height_bound'"><span class="command">lemma</span></span> height_bound'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V <span class="main">⟹</span> <span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> height_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> pp_init_height_bound<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> pp_init_f pp_init_l"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">pp_init_f</span> <span class="quoted">pp_init_l</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pp_init_invar<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pp_init_l_def<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">context</span></span> Height_Bounded_Labeling
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As push does not change the labeling, it trivially preserves the 
  height bound.›</span></span>  
<span class="keyword1" id="Generic_Push_Relabel-push_pres_height_bound"><span class="command">lemma</span></span> push_pres_height_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
  <span class="keyword1"><span class="command">from</span></span> push_pres_Labeling<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
  <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"push_effect <span class="free">f</span> <span class="free">e</span>"</span></span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> height_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>    
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In a valid labeling,
  any active node has a (simple) path to the source node in 
  the residual graph~\cormen{26.19}.
›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> excess_imp_source_path<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">U</span></span> <span class="keyword2"><span class="keyword">where</span></span> U_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span> <span class="main">=</span> <span class="main">{</span><span class="bound">v</span><span class="main">|</span><span class="bound">p</span> <span class="bound">v</span><span class="main">.</span> cf.isSimplePath <span class="free">u</span> <span class="bound">p</span> <span class="bound">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> fct1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span> <span class="main">⊆</span> V"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">U</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> U_def cf.isSimplePath_def cf.isPath_rtc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">=</span> <span class="skolem">v</span> <span class="main">∨</span> <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> rtranclE<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> V"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> excess_nodes_only<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> cf.V"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> 
    
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> <span class="skolem">U</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∉</span> <span class="skolem">U</span>"</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">U'</span></span> <span class="keyword2"><span class="keyword">where</span></span> U'_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">U'</span> <span class="main">=</span> V <span class="main">-</span> <span class="skolem">U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span><span class="main">)</span> 
        <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span><span class="main">)</span> 
          <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>incoming <span class="bound">u</span><span class="main">.</span> <span class="free">f</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span><span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>outgoing <span class="bound">u</span><span class="main">.</span> <span class="free">f</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?R1</span> <span class="main">-</span> <span class="var">?R2</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_subtractf<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R1</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> sum_incoming_alt_flow fct1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> subsetCE sum.cong<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
          <span class="keyword1"><span class="command">using</span></span> U'_def fct1 finite_V 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ab_semigroup_add_class.add.commute sum.subset_diff<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.distrib<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R2</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> sum_outgoing_alt_flow fct1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> subsetCE sum.cong<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
          <span class="keyword1"><span class="command">using</span></span> U'_def fct1 finite_V 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ab_semigroup_add_class.add.commute sum.subset_diff<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.distrib<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"card <span class="skolem">A</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">A</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> 0
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">x</span><span class="main">)</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A'</span></span> <span class="skolem"><span class="skolem">a</span></span> 
              <span class="keyword2"><span class="keyword">where</span></span> o1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> insert <span class="skolem">a</span> <span class="skolem">A'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> o2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> card <span class="skolem">A'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> o3<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">A'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_insert_disjoint card_le_Suc_iff le_refl nat.inject<span class="main">)</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> lm<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="skolem">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="skolem">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">g</span> <span class="skolem">a</span>"</span></span> 
              <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>  
              <span class="keyword1"><span class="command">using</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_insert_if n_not_Suc_n 
                        semiring_normalization_rules<span class="main"><span class="main">(</span></span>24<span class="main"><span class="main">)</span></span> sum.insert<span class="main">)</span>

            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
              <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?R1</span> <span class="main">+</span> <span class="var">?R2</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> lm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>     
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R1</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>"</span></span> 
              <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?R1_1</span> <span class="main">+</span> <span class="var">?R1_2</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> lm sum.distrib <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> add.assoc
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R1_2</span> <span class="main">+</span> <span class="var">?R2</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?R1_2'</span> <span class="main">+</span> <span class="var">?R2'</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> lm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R1_1</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
              <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?R1_1'</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> Suc.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">A'</span></span><span class="main">]</span> o2 o3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> add.assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R1_1'</span> <span class="main">+</span> <span class="var">?R1_2'</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">A'</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> lm sum.cong sum.distrib<span class="main">)</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> lm<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">U</span></span><span class="main">]</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct1 finite_V finite_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> <span class="skolem">U</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> U_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="skolem">U</span> <span class="main">⟹</span> excess <span class="free">f</span> <span class="skolem">u</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span> 
        <span class="keyword1"><span class="command">using</span></span> fct1 excess_non_negative' <span class="quoted"><span class="quoted">‹<span class="free">s</span> <span class="main">∉</span> <span class="skolem">U</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms fct1 finite_V
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_cancel Diff_eq_empty_iff 
                  Diff_infinite_finite finite_Diff sum_pos2<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
      fct2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">have</span></span> fct3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_nonneg<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span><span class="skolem">U</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">U'</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_nonneg<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
      
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">u'</span> <span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">u'</span> <span class="main">∈</span> <span class="skolem">U</span> <span class="main">∧</span> <span class="bound">v'</span> <span class="main">∈</span> <span class="skolem">U'</span> <span class="main">∧</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">u'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u'</span> <span class="bound">v'</span><span class="main">.</span> <span class="bound">u'</span> <span class="main">∈</span> <span class="skolem">U</span> <span class="main">∧</span> <span class="bound">v'</span> <span class="main">∈</span> <span class="skolem">U'</span> <span class="main">∧</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">u'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">u'</span> <span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">u'</span> <span class="main">∈</span> <span class="skolem">U</span> <span class="main">∧</span> <span class="bound">v'</span> <span class="main">∈</span> <span class="skolem">U'</span> <span class="main">⟶</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">u'</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> le_neq_trans<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> fct3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span> <span class="main">∈</span> <span class="skolem">U</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> <span class="skolem">U'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">u</span> <span class="skolem">p1</span> <span class="skolem">u'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> U_def <span class="quoted"><span class="quoted">‹<span class="skolem">u'</span> <span class="main">∈</span> <span class="skolem">U</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> not_less zero_flow_simp<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf_def 
        <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">u</span> <span class="main">(</span><span class="skolem">p1</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">v'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> Graph.isPath_append_edge Graph.isSimplePath_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">u</span> <span class="skolem">p2</span> <span class="skolem">v'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> cf.isSPath_pathLE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> <span class="skolem">U</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> U_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v'</span> <span class="main">∈</span> <span class="skolem">U'</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> U'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">u</span> <span class="skolem">p'</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> U_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relabel operations preserve the height bound~\cormen{26.20}.›</span></span>
<span class="keyword1" id="Generic_Push_Relabel-relabel_pres_height_bound"><span class="command">lemma</span></span> relabel_pres_height_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> relabel_pres_Labeling<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>  
  <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> l'.excess_imp_source_path <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p_obt<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">u</span> <span class="skolem">p</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> V"</span></span> <span class="keyword1"><span class="command">using</span></span> excess_nodes_only <span class="quoted"><span class="quoted">‹excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p</span> <span class="main">&lt;</span> card V"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> cf.simplePath_length_less_V<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> p_obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l'</span> <span class="free">u</span> <span class="main">≤</span> <span class="var">?l'</span> <span class="free">s</span> <span class="main">+</span> length <span class="skolem">p</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> p_obt l'.gen_valid<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="skolem">p</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">]</span> p_obt 
    <span class="keyword1"><span class="command">unfolding</span></span> cf.isSimplePath_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l'</span> <span class="free">s</span> <span class="main">=</span> card V"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> l'.Labeling_axioms Labeling_def Labeling_axioms_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l'</span> <span class="free">u</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="var">?l'</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> height_bound relabel_preserve_other
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>  
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Thus, the total number of relabel operations is 
  bounded by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>)›</span></span></span></span>~\cormen{26.21}. 

  We express this bound by defining a measure function, and show that 
  it is decreased by relabel operations.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">sum_heights_measure</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span>"</span></span>
  
<span class="keyword1"><span class="command">corollary</span></span> relabel_measure<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sum_heights_measure <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> sum_heights_measure <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> relabel_pres_height_bound<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
  <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> excess_nodes_only relabel_precond_def<span class="main">)</span>
      
  <span class="keyword1"><span class="command">hence</span></span> V_split<span class="main">:</span> <span class="quoted"><span class="quoted">"V <span class="main">=</span> insert <span class="free">u</span> V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command">using</span></span> relabel_increase_u<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> relabel_preserve_other<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> l'.height_bound 
    <span class="keyword1"><span class="command">unfolding</span></span> sum_heights_measure_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="quasi_keyword">at</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">∑</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">∈</span></span><span class="main"><span class="main">⌑</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> V_split<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.insert_remove<span class="main"><span class="main">[</span></span><span class="operator">OF</span> finite_V<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>V›</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>   
<span class="keyword1"><span class="command">qed</span></span>        
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Height Bounded Labeling›</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> sum_height_measure_is_OV2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"sum_heights_measure <span class="free">l</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span><span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>  sum_heights_measure_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="free">l</span> <span class="skolem">v</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="free">l</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> card V<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> card V<span class="main">)</span> <span class="main">=</span> card V <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> card V<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> finite_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="free">l</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">2</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> power2_eq_square<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Formulation of the Abstract Algorithm›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We give a simple relational characterization 
  of the abstract algorithm as a labeled transition system,
  where the labels indicate the type of operation (push or relabel) that
  have been executed.
›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">datatype</span></span> pr_operation <span class="main">=</span> <span class="entity">is_PUSH</span><span class="main">:</span> PUSH <span class="main">|</span> <span class="entity">is_RELABEL</span><span class="main">:</span> RELABEL
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">pr_algo_lts</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'capacity</span> flow<span class="main">×</span>labeling<span class="main">)</span> <span class="main">×</span> pr_operation <span class="main">×</span> <span class="main">(</span><span class="tfree">'capacity</span> flow<span class="main">×</span>labeling<span class="main">)</span><span class="main">)</span> set"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  push<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span>PUSH<span class="main">,</span><span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_lts</span>"</span></span>
<span class="main">|</span> relabel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">⟧</span>
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span>RELABEL<span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span>relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_lts</span>"</span></span>

  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show invariant maintenance and correctness on termination›</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> pr_algo_maintains_hb_labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f'</span> <span class="free">l'</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_pres_height_bound relabel_pres_height_bound<span class="main">)</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> pr_algo_term_maxflow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∉</span>Domain pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∄</span><span class="bound">e</span><span class="main">.</span> push_precond <span class="free">f</span> <span class="free">l</span> <span class="bound">e</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∄</span><span class="bound">u</span><span class="main">.</span> relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="bound">u</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Domain_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pr_algo_lts.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> push_relabel_term_imp_maxflow <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>      
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Saturating and Non-Saturating Push Operations›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For complexity estimation, it is distinguished whether a push operation
  saturates the edge or not.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sat_push_precond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> labeling <span class="main">⇒</span> edge <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat_push_precond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">u</span> <span class="main">&gt;</span> <span class="main">0</span> 
          <span class="main">∧</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">u</span> <span class="main">≥</span> cf_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> 
          <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">u</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nonsat_push_precond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> labeling <span class="main">⇒</span> edge <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nonsat_push_precond</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">u</span> <span class="main">&gt;</span> <span class="main">0</span> 
          <span class="main">∧</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">u</span> <span class="main">&lt;</span> cf_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f</span></span></span> 
          <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">u</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1" id="Generic_Push_Relabel-push_precond_eq_sat_or_nonsat"><span class="command">lemma</span></span> push_precond_eq_sat_or_nonsat<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span> <span class="main">⟷</span> sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span> <span class="main">∨</span> nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def sat_push_precond_def nonsat_push_precond_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
<span class="keyword1" id="Generic_Push_Relabel-sat_nonsat_push_disj"><span class="command">lemma</span></span> sat_nonsat_push_disj<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span> <span class="main">⟹</span> <span class="main">¬</span>nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span> <span class="main">⟹</span> <span class="main">¬</span>sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sat_push_precond_def nonsat_push_precond_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
<span class="keyword1" id="Generic_Push_Relabel-sat_push_alt"><span class="command">lemma</span></span> sat_push_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span> 
  <span class="main">⟹</span> push_effect <span class="free">f</span> <span class="free">e</span> <span class="main">=</span> augment_edge <span class="free">f</span> <span class="free">e</span> <span class="main">(</span>cf_of <span class="free">f</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> push_effect_def push_precond_eq_sat_or_nonsat sat_push_precond_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> min_absorb2<span class="main">)</span>
    
<span class="keyword1" id="Generic_Push_Relabel-nonsat_push_alt"><span class="command">lemma</span></span> nonsat_push_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> 
  <span class="main">⟹</span> push_effect <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> augment_edge <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>excess <span class="free">f</span> <span class="free">u</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> push_effect_def push_precond_eq_sat_or_nonsat nonsat_push_precond_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> min_absorb1<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword1"><span class="command">context</span></span> push_effect_locale
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Generic_Push_Relabel-nonsat_push_Δ"><span class="command">lemma</span></span> nonsat_push_Δ<span class="main">:</span> <span class="quoted"><span class="quoted">"nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">⟹</span> Δ <span class="main">=</span> excess <span class="free">f</span> <span class="free">u</span>"</span></span>      
    <span class="keyword1"><span class="command">unfolding</span></span> Δ_def nonsat_push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1" id="Generic_Push_Relabel-sat_push_Δ"><span class="command">lemma</span></span> sat_push_Δ<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">⟹</span> Δ <span class="main">=</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>      
    <span class="keyword1"><span class="command">unfolding</span></span> Δ_def sat_push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword2"><span class="keyword">end</span></span>    
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refined Labeled Transition System›</span></span>
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For simpler reasoning, we make explicit the different push operations,
  and integrate the invariant into the LTS›</span></span>
  
<span class="keyword1"><span class="command">datatype</span></span> pr_operation' <span class="main">=</span> 
  <span class="entity">is_RELABEL'</span><span class="main">:</span> RELABEL' 
<span class="main">|</span> <span class="entity">is_NONSAT_PUSH'</span><span class="main">:</span> NONSAT_PUSH'
<span class="main">|</span> <span class="entity">is_SAT_PUSH'</span><span class="main">:</span> SAT_PUSH' <span class="quoted">edge</span>   
  
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">pr_algo_lts'</span> <span class="keyword2"><span class="keyword">where</span></span>
  nonsat_push'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> nonsat_push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span>NONSAT_PUSH'<span class="main">,</span><span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_lts'</span>"</span></span>
<span class="main">|</span> sat_push'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> sat_push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span>SAT_PUSH' <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_lts'</span>"</span></span>
<span class="main">|</span> relabel'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">⟧</span>
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span>RELABEL'<span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span>relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_lts'</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">project_operation</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">project_operation</span> RELABEL' <span class="main">=</span> RELABEL"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">project_operation</span> NONSAT_PUSH' <span class="main">=</span> PUSH"</span></span>  
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">project_operation</span> <span class="main">(</span>SAT_PUSH' <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> PUSH"</span></span>  

<span class="keyword1" id="Generic_Push_Relabel-is_RELABEL_project_conv"><span class="command">lemma</span></span> is_RELABEL_project_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_RELABEL <span class="main">∘</span> project_operation <span class="main">=</span> is_RELABEL'"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Generic_Push_Relabel-is_PUSH_project_conv"><span class="command">lemma</span></span> is_PUSH_project_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_PUSH <span class="main">∘</span> project_operation <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> is_SAT_PUSH' <span class="bound">x</span> <span class="main">∨</span> is_NONSAT_PUSH' <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword1"><span class="command">context</span></span> Height_Bounded_Labeling
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> xfer_run<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span> 
               <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> map project_operation <span class="free">p'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p'</span><span class="main">.</span> 
      Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f'</span> <span class="free">l'</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="bound">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts' 
    <span class="main">∧</span> <span class="free">p</span> <span class="main">=</span> map project_operation <span class="bound">p'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f'</span></span> <span class="quoted"><span class="free">l'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Height_Bounded_Labeling_axioms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> snoc.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fh</span></span> <span class="skolem"><span class="skolem">lh</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> PP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">fh</span><span class="main">,</span> <span class="skolem">lh</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> LAST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span><span class="skolem">l'</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>pr_algo_lts"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trcl_rev_uncons<span class="main">)</span>  

    <span class="keyword1"><span class="command">from</span></span> snoc.IH<span class="main">[</span><span class="operator">OF</span> PP<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> HBL<span class="main">:</span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">fh</span> <span class="skolem">lh</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> PP'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span><span class="main">,</span> <span class="skolem">p'</span><span class="main">,</span> <span class="skolem">fh</span><span class="main">,</span> <span class="skolem">lh</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> map project_operation <span class="skolem">p'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        
    <span class="keyword1"><span class="command">from</span></span> LAST <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a'</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> LAST'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">a'</span><span class="main">,</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span><span class="skolem">l'</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>pr_algo_lts'"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> project_operation <span class="skolem">a'</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">cases</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> push_precond_eq_sat_or_nonsat
          <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> relabel'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> HBL<span class="main"><span class="main">]</span></span> nonsat_push'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> HBL<span class="main"><span class="main">]</span></span> sat_push'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> HBL<span class="main"><span class="main">]</span></span><span class="main">)</span>  
    
    <span class="keyword1"><span class="command">note</span></span> HBL' <span class="main">=</span> 
      Height_Bounded_Labeling.pr_algo_maintains_hb_labeling<span class="main">[</span><span class="operator">OF</span> HBL LAST<span class="main">]</span>
      
    <span class="keyword1"><span class="command">from</span></span> HBL' trcl_rev_cons<span class="main">[</span><span class="operator">OF</span> PP' LAST'<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1" id="Generic_Push_Relabel-xfer_relabel_bound"><span class="command">lemma</span></span> xfer_relabel_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BOUND<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p'</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="bound">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts' 
          <span class="main">⟶</span> length <span class="main">(</span>filter is_RELABEL' <span class="bound">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RUN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_RELABEL <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="free">B</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> xfer_run<span class="main">[</span><span class="operator">OF</span> RUN<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> RUN'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> map project_operation <span class="skolem">p'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_RELABEL <span class="free">p</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>filter is_RELABEL' <span class="skolem">p'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> BOUND<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> RUN'<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_RELABEL' <span class="skolem">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-xfer_push_bounds"><span class="command">lemma</span></span> xfer_push_bounds<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BOUND_SAT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p'</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="bound">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts' 
          <span class="main">⟶</span> length <span class="main">(</span>filter is_SAT_PUSH' <span class="bound">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">B1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> BOUND_NONSAT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p'</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="bound">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts' 
          <span class="main">⟶</span> length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="bound">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">B2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RUN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_PUSH <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="free">B1</span> <span class="main">+</span> <span class="free">B2</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  
  <span class="keyword1"><span class="command">from</span></span> xfer_run<span class="main">[</span><span class="operator">OF</span> RUN<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> RUN'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> map project_operation <span class="skolem">p'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">[</span><span class="bound">x</span><span class="main">←</span><span class="skolem">p'</span> <span class="main">.</span> is_SAT_PUSH' <span class="bound">x</span> <span class="main">∨</span> is_NONSAT_PUSH' <span class="bound">x</span><span class="main">]</span>
    <span class="main">=</span> length <span class="main">(</span>filter is_SAT_PUSH' <span class="skolem">p'</span><span class="main">)</span> <span class="main">+</span> length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="skolem">p'</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">)</span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_PUSH <span class="free">p</span><span class="main">)</span> 
    <span class="main">=</span> length <span class="main">(</span>filter is_SAT_PUSH' <span class="skolem">p'</span><span class="main">)</span> <span class="main">+</span> length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="skolem">p'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> BOUND_SAT<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> RUN'<span class="main">]</span>    
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> BOUND_NONSAT<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> RUN'<span class="main">]</span>    
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
  
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Height Bounded Labeling›</span> 

  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Bounding the Relabel Operations›</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> relabel_action_bound'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">fxl</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">fxl'</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span>is_RELABEL'<span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>   
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span>is_RELABEL'<span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> sum_heights_measure <span class="main">(</span>snd <span class="free">fxl</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> trcl.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Height_Bounded_Labeling.relabel_measure<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> sum_height_measure_is_OV2
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span>is_RELABEL'<span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> relabel_action_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span>is_RELABEL<span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> xfer_relabel_bound relabel_action_bound' A <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Bounding the Saturating Push Operations›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The basic idea is to estimate the saturating push operations per edge:
  After a saturating push, the edge disappears from the residual graph.
  It can only re-appear due to a push over the reverse edge, which requires
  relabeling of the nodes. 

  The estimation in \cormen{26.22} uses the same idea. However, it invests 
  some extra work in getting a more precise constant factor 
  by counting the pushes for an edge and its reverse edge together.
›</span></span>  

<span class="keyword1" id="Generic_Push_Relabel-labels_path_increasing"><span class="command">lemma</span></span> labels_path_increasing<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">l'</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fh</span></span> <span class="skolem"><span class="skolem">lh</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> FIRST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_lts'"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> PP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span><span class="main">:</span> trcl pr_algo_lts'"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv<span class="main">)</span>  
      
  <span class="keyword1"><span class="command">from</span></span> FIRST <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
    
  <span class="keyword1"><span class="command">from</span></span> FIRST Cons.IH<span class="main">[</span><span class="operator">OF</span> PP<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> relabel_increase_u relabel_preserve_other
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> le_trans nat_le_linear not_less<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-edge_reappears_at_increased_labeling"><span class="command">lemma</span></span> edge_reappears_at_increased_labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">u</span> <span class="main">≥</span> <span class="free">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∉</span> cfE_of <span class="free">f</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> E'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="free">f'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="free">l'</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1-3<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> E' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fh</span></span> <span class="skolem"><span class="skolem">lh</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> FIRST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_lts'"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> PP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span><span class="main">:</span> trcl pr_algo_lts'"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv<span class="main">)</span>  
      
  <span class="keyword1"><span class="command">from</span></span> FIRST <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">consider</span></span> 
    <span class="main">(</span>push<span class="main">)</span> <span class="skolem">u'</span> <span class="skolem">v'</span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"push_precond <span class="skolem">f</span> <span class="skolem">l</span> <span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fh</span> <span class="main">=</span> push_effect <span class="skolem">f</span> <span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lh</span><span class="main">=</span><span class="skolem">l</span>"</span></span>
  <span class="main">|</span> <span class="main">(</span>relabel<span class="main">)</span> <span class="skolem">u'</span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"relabel_precond <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">u'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fh</span><span class="main">=</span><span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lh</span><span class="main">=</span>relabel_effect <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">u'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> FIRST       
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> push_precond_eq_sat_or_nonsat<span class="main">)</span>  
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> push
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> push<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>  
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The push operation cannot go on edge <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(u,v)›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(v,u)›</span></span></span></span>›</span></span>  
    <span class="keyword1"><span class="command">from</span></span> push<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">≠</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">≠</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">l</span> <span class="free">u</span> <span class="main">≥</span> <span class="skolem">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>cf.E›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> push_precond_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> NE'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>cfE_of <span class="skolem">fh</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>cf.E›</span></span>
      <span class="keyword1"><span class="command">using</span></span> cfE_augment_ss<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">u'</span></span> <span class="quoted"><span class="skolem">v'</span></span> <span class="quoted"><span class="skolem">f</span></span><span class="main">]</span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> push_effect_def<span class="main">)</span>  
    <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> PP _ NE'<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">l</span> <span class="free">u</span> <span class="main">≥</span> <span class="skolem">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> relabel
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> relabel<span class="main">(</span>2<span class="main">)</span>  
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">=</span><span class="free">v</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False 
      <span class="keyword1"><span class="command">from</span></span> False relabel<span class="main">(</span>3<span class="main">)</span> relabel_preserve_other <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lh</span> <span class="free">v</span> <span class="main">=</span> <span class="skolem">l</span> <span class="free">v</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> False relabel<span class="main">(</span>3<span class="main">)</span> 
           relabel_preserve_other relabel_increase_u<span class="main">[</span><span class="operator">OF</span> relabel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lh</span> <span class="free">u</span> <span class="main">≥</span> <span class="skolem">l</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">=</span><span class="free">u</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">l</span> <span class="free">u</span> <span class="main">≥</span> <span class="skolem">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> LHG<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lh</span> <span class="free">u</span> <span class="main">≥</span> <span class="skolem">lh</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
      <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> PP LHG<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>cf.E›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> relabel<span class="main">(</span>3<span class="main">)</span>  
      <span class="keyword1"><span class="command">from</span></span> True relabel_increase_u<span class="main">[</span><span class="operator">OF</span> relabel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="skolem">lh</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> labels_path_increasing<span class="main">[</span><span class="operator">OF</span> PP<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>       
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-sat_push_edge_action_bound'"><span class="command">lemma</span></span> sat_push_edge_action_bound'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="free">e</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card V"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">=</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">-</span> <span class="free">l</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span>
    <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> length_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">p</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>        
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p'</span><span class="main">)</span> 
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.prems"</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fh</span></span> <span class="skolem"><span class="skolem">lh</span></span> 
        <span class="keyword2"><span class="keyword">where</span></span> FIRST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_lts'"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> PP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">p'</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trcl_uncons<span class="main">)</span>  
        
      <span class="keyword1"><span class="command">from</span></span> FIRST <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
          
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span><span class="main">)</span>  
        <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> False
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.IH"</span> PP <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p'</span><span class="main">)</span> 
          <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="skolem">lh</span> <span class="skolem">v</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> FIRST <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ua</span> <span class="main">::</span> <span class="quoted">nat</span>
          <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p'</span><span class="main">)</span> 
                    <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> relabel_effect <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">ua</span> <span class="skolem">v</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> a2<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">ua</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> relabel_effect <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">ua</span> <span class="skolem">v</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="skolem">l</span> <span class="skolem">v</span> 
          <span class="main">⟶</span> length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="skolem">l</span> <span class="skolem">v</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> a1 order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p'</span><span class="main">)</span> 
                    <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="skolem">l</span> <span class="skolem">v</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> a2 a1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> Labeling.relabel_increase_u 
                Labeling_axioms diff_le_mono2 nat_less_le 
                relabel_preserve_other<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>  
      <span class="keyword1"><span class="command">next</span></span>          
        <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
  
        <span class="keyword1"><span class="command">from</span></span> FIRST <span class="keyword1"><span class="command">have</span></span> 
          <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fh</span> <span class="main">=</span> push_effect <span class="skolem">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lh</span> <span class="main">=</span> <span class="skolem">l</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_push_precond <span class="skolem">f</span> <span class="skolem">l</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span> <span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases<span class="main">)</span>  
          
        <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">l</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> sat_push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            
        <span class="keyword1"><span class="command">have</span></span> UVNEH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>cfE_of <span class="skolem">fh</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">≠</span><span class="skolem">v</span>›</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
                  <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sat_push_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span> augment_edge_cf'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            
            
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">p'</span>"</span></span><span class="main">)</span>  
          <span class="keyword3"><span class="command">case</span></span> False 
          <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p'</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">)</span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">using</span></span> bspec<span class="main">[</span><span class="operator">OF</span> height_bound <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>V›</span></span><span class="main">]</span>  
            <span class="keyword1"><span class="command">using</span></span> bspec<span class="main">[</span><span class="operator">OF</span> height_bound <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>V›</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">using</span></span> card_V_ge2 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> 
            <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> NP1<span class="main">:</span> <span class="quoted"><span class="quoted">"SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> set <span class="skolem">p1</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> in_set_conv_decomp_first<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
              
          <span class="keyword1"><span class="command">from</span></span> NP1 <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p1</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p1</span></span><span class="main">)</span> <span class="operator">auto</span>
              
          <span class="keyword1"><span class="command">from</span></span> PP <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f2</span></span> <span class="skolem"><span class="skolem">l2</span></span> <span class="skolem"><span class="skolem">f3</span></span> <span class="skolem"><span class="skolem">l3</span></span> 
            <span class="keyword2"><span class="keyword">where</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">p1</span><span class="main">,</span><span class="main">(</span><span class="skolem">f2</span><span class="main">,</span><span class="skolem">l2</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f2</span><span class="main">,</span><span class="skolem">l2</span><span class="main">)</span><span class="main">,</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">f3</span><span class="main">,</span><span class="skolem">l3</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_lts'"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> P2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f3</span><span class="main">,</span><span class="skolem">l3</span><span class="main">)</span><span class="main">,</span><span class="skolem">p2</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>trcl pr_algo_lts'"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv<span class="main">)</span>  
          <span class="keyword1"><span class="command">from</span></span> S <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="skolem">f2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l3</span><span class="main">=</span><span class="skolem">l2</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sat_push_precond_def<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> edge_reappears_at_increased_labeling<span class="main">[</span><span class="operator">OF</span> P1 _ UVNEH<span class="main">]</span> 
            <span class="quoted"><span class="quoted">‹<span class="skolem">l</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">l</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>›</span></span>
          <span class="keyword1"><span class="command">have</span></span> AUX1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="skolem">v</span> <span class="main">&lt;</span> <span class="skolem">l2</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
          <span class="keyword1"><span class="command">from</span></span> S <span class="keyword1"><span class="command">interpret</span></span> l2<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f2</span></span> <span class="quoted"><span class="skolem">l2</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases<span class="main">)</span>
              
          <span class="keyword1"><span class="command">from</span></span> spec<span class="main">[</span><span class="operator">OF</span> <span class="quoted">"1.IH"</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2</span>"</span></span><span class="main">]</span> S P2 <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"Suc <span class="main">(</span>length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">p2</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="skolem">l2</span> <span class="skolem">v</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">-</span> <span class="skolem">l</span> <span class="skolem">v</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> AUX1
            <span class="keyword1"><span class="command">using</span></span> bspec<span class="main">[</span><span class="operator">OF</span> l2.height_bound <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>V›</span></span><span class="main">]</span>  
            <span class="keyword1"><span class="command">using</span></span> bspec<span class="main">[</span><span class="operator">OF</span> l2.height_bound <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>V›</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>  
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>  
<span class="keyword1"><span class="command">qed</span></span>          

<span class="keyword1" id="Generic_Push_Relabel-sat_push_action_bound'"><span class="command">lemma</span></span> sat_push_action_bound'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_SAT_PUSH' <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">4</span> <span class="main">*</span> card V <span class="main">*</span> card E"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> IN_E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"SAT_PUSH' <span class="skolem">e</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">e</span>
    <span class="keyword1"><span class="command">using</span></span> that cfE_of_ss_invE
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv sat_push_precond_def 
        <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases
      <span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    
  <span class="keyword1"><span class="command">have</span></span> AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="main">∃</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">S</span><span class="main">.</span> <span class="bound">a</span> <span class="main">=</span> SAT_PUSH' <span class="bound">e</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">S</span><span class="main">.</span> length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="bound">e</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">S</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">S</span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">induction</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> length_filter_disj_or_conv<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fo_rule</span> arg_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_SAT_PUSH' <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span><span class="main">.</span> <span class="skolem">a</span> <span class="main">=</span> SAT_PUSH' <span class="bound">e</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span>
    <span class="keyword1"><span class="command">using</span></span> IN_E that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_SAT_PUSH' <span class="free">p</span><span class="main">)</span> 
    <span class="main">=</span> length <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="main">∃</span><span class="bound">e</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span><span class="main">.</span> <span class="bound">a</span> <span class="main">=</span> SAT_PUSH' <span class="bound">e</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> filter_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span><span class="main">.</span> length <span class="main">(</span>filter <span class="main">(</span><span class="main">(=)</span> <span class="main">(</span>SAT_PUSH' <span class="bound">e</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> AUX<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">∈</span>E <span class="main">∪</span> E<span class="main">¯</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> card V<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> sum_mono<span class="main">[</span><span class="operator">OF</span> sat_push_edge_action_bound'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> A<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> K<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"E<span class="main">∪</span>E<span class="main">¯</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="numeral">4</span> <span class="main">*</span> card V <span class="main">*</span> card E"</span></span> <span class="keyword1"><span class="command">using</span></span> card_Un_le<span class="main">[</span><span class="operator">of</span> <span class="quoted">E</span> <span class="quoted"><span class="quoted">"E<span class="main">¯</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_SAT_PUSH' <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">4</span> <span class="main">*</span> card V <span class="main">*</span> card E"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Bounding the Non-Saturating Push Operations›</span></span>    

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For estimating the number of non-saturating push operations, we
  define a potential function that is the sum of the labels of
  all active nodes, and examine the effect of the operations
  on this potential:
    <span class="antiquoted"><span class="antiquoted">▪</span></span> A non-saturating push deactivates the source node and may activate 
      the target node. As the source node's label is higher, the potential
      decreases.
    <span class="antiquoted"><span class="antiquoted">▪</span></span> A saturating push may activate a node, thus increasing the potential 
      by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V)›</span></span></span></span>.
    <span class="antiquoted"><span class="antiquoted">▪</span></span> A relabel operation may increase the potential by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V)›</span></span></span></span>.

  As there are at most <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>)›</span></span></span></span> relabel and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(VE)›</span></span></span></span> saturating push operations,
  the above bounds suffice to yield an <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>E)›</span></span></span></span> bound for the non-saturating 
  push operations.

  This argumentation corresponds to \cormen{26.23}.
›</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Sum of heights of all active nodes›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">nonsat_potential</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> sum <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">context</span></span> Height_Bounded_Labeling
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The potential does not exceed <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>)›</span></span></span></span>. ›</span></span>  
<span class="keyword1" id="Generic_Push_Relabel-nonsat_potential_bound"><span class="command">lemma</span></span> nonsat_potential_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="free">f</span> <span class="free">l</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="free">f</span> <span class="free">l</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span><span class="main">.</span> <span class="free">l</span> <span class="bound">v</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> nonsat_potential_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">l</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> sum.subset_diff<span class="main">[</span><span class="operator">OF</span> f1 finite_V<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span>  <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> height_bound <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> card V <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card V <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> card V <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">*</span> card V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> power2_eq_square<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A non-saturating push decreases the potential.›</span></span>  
<span class="keyword1" id="Generic_Push_Relabel-nonsat_push_decr_nonsat_potential"><span class="command">lemma</span></span> nonsat_push_decr_nonsat_potential<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span> <span class="main">&lt;</span> nonsat_potential <span class="free">f</span> <span class="free">l</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Pair <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">simp</span>  
    <span class="keyword1"><span class="command">interpret</span></span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">using</span></span> assms 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_precond_eq_sat_or_nonsat<span class="main">)</span>
      
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> nonsat_push_Δ<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
  
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span><span class="main">=</span><span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span>V<span class="main">.</span> <span class="bound">x</span><span class="main">≠</span><span class="skolem">u</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">≠</span><span class="skolem">v</span> <span class="main">∧</span> <span class="main">0</span><span class="main">&lt;</span>excess <span class="free">f</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> S_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span><span class="main">∈</span>V<span class="main">.</span> <span class="bound">x</span><span class="main">≠</span><span class="skolem">u</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">≠</span><span class="skolem">v</span> <span class="main">∧</span> <span class="main">0</span><span class="main">&lt;</span>excess f' <span class="bound">x</span><span class="main">}</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
    <span class="keyword1"><span class="command">have</span></span> NES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∉</span><span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span><span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∉</span><span class="skolem">S</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">S</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">using</span></span> excess_s_non_pos
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      
    <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess f' <span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">s</span><span class="main">=</span><span class="skolem">v</span> <span class="keyword1">then</span> <span class="skolem">S</span> <span class="keyword1">else</span> insert <span class="skolem">v</span> <span class="skolem">S</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> S_alt
      <span class="keyword1"><span class="command">using</span></span> excess_u_pos excess_non_negative' l'.excess_s_non_pos
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> add_nonneg_pos<span class="main">)</span>
        
    <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> 
      <span class="main">=</span> insert <span class="skolem">u</span> <span class="skolem">S</span> <span class="main">∪</span> <span class="main">(</span><span class="keyword1">if</span> excess <span class="free">f</span> <span class="skolem">v</span><span class="main">&gt;</span><span class="main">0</span> <span class="keyword1">then</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>    
      <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">using</span></span> excess_u_pos <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"nonsat_potential f' <span class="free">l</span> <span class="main">&lt;</span> nonsat_potential <span class="free">f</span> <span class="free">l</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> nonsat_potential_def 1 2
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">=</span><span class="skolem">v</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">&lt;</span>excess <span class="free">f</span> <span class="skolem">v</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NES<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>      
<span class="keyword1"><span class="command">qed</span></span>
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A saturating push increases the potential by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V)›</span></span></span></span>.›</span></span>
<span class="keyword1" id="Generic_Push_Relabel-sat_push_nonsat_potential"><span class="command">lemma</span></span> sat_push_nonsat_potential<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span> 
      <span class="main">≤</span> nonsat_potential <span class="free">f</span> <span class="free">l</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> card V"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="operator">auto</span>   
  
  <span class="keyword1"><span class="command">interpret</span></span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span>
    <span class="keyword1"><span class="command">using</span></span> PRE
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_precond_eq_sat_or_nonsat<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> excess <span class="free">f</span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Only target node may get activated›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> excess f' <span class="bound">v</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> insert <span class="skolem">v</span> <span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> excess <span class="free">f</span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">}</span>"</span></span>    
    <span class="keyword1"><span class="command">using</span></span> Δ_positive
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess'_if<span class="main">)</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Thus, potential increases by at most <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l v›</span></span></span></span>›</span></span>    
  <span class="keyword1"><span class="command">with</span></span> sum_mono2<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nonsat_potential f' <span class="free">l</span> <span class="main">≤</span> nonsat_potential <span class="free">f</span> <span class="free">l</span> <span class="main">+</span> <span class="free">l</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> nonsat_potential_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.insert_if <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Which is bounded by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V)›</span></span></span></span>›</span></span>    
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> height_bound'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A relabeling increases the potential by at most <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V)›</span></span></span></span>›</span></span>
<span class="keyword1" id="Generic_Push_Relabel-relabel_nonsat_potential"><span class="command">lemma</span></span> relabel_nonsat_potential<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="free">f</span> <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span> 
       <span class="main">≤</span> nonsat_potential <span class="free">f</span> <span class="free">l</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> card V"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> excess <span class="free">f</span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
      
  <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> relabel_pres_height_bound<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
      
  <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> U_ACTIVE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> <span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">.</span> excess <span class="free">f</span> <span class="bound">v</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def <span class="keyword1"><span class="command">using</span></span> excess_nodes_only
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="free">f</span> <span class="var">?l'</span> 
      <span class="main">=</span> sum <span class="var">?l'</span> <span class="main">(</span><span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> <span class="main">+</span> <span class="var">?l'</span> <span class="free">u</span>"</span></span>    
    <span class="keyword1"><span class="command">unfolding</span></span> nonsat_potential_def
    <span class="keyword1"><span class="command">using</span></span> U_ACTIVE <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum_arb<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="var">?l'</span> <span class="main">(</span><span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> 
      <span class="main">=</span> sum <span class="free">l</span> <span class="main">(</span><span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> relabel_preserve_other <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l'</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">l</span> <span class="free">u</span> <span class="main">+</span> <span class="numeral">2</span><span class="main">*</span>card V"</span></span>    
    <span class="keyword1"><span class="command">using</span></span> l'.height_bound'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>V›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nonsat_potential <span class="free">f</span> <span class="var">?l'</span> 
              <span class="main">≤</span> sum <span class="free">l</span> <span class="main">(</span><span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> <span class="main">+</span> <span class="free">l</span> <span class="free">u</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> card V"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="free">l</span> <span class="main">(</span><span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="bound">v</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> <span class="main">+</span> <span class="free">l</span> <span class="free">u</span> 
           <span class="main">=</span> nonsat_potential <span class="free">f</span> <span class="free">l</span>"</span></span>    
    <span class="keyword1"><span class="command">unfolding</span></span> nonsat_potential_def
    <span class="keyword1"><span class="command">using</span></span> U_ACTIVE <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum_arb<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>   
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Height Bounded Labeling›</span>  
  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-nonsat_push_action_bound'"><span class="command">lemma</span></span> nonsat_push_action_bound'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">18</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> B1<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="free">p</span><span class="main">)</span> 
    <span class="main">≤</span>   nonsat_potential <span class="free">f</span> <span class="free">l</span> 
      <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">*</span> <span class="main">(</span>length <span class="main">(</span>filter is_SAT_PUSH' <span class="free">p</span><span class="main">)</span><span class="main">)</span>
      <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">*</span> <span class="main">(</span>length <span class="main">(</span>filter is_RELABEL' <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>    
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fh</span></span> <span class="skolem"><span class="skolem">lh</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> FIRST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>pr_algo_lts'"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> PP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">fh</span><span class="main">,</span><span class="skolem">lh</span><span class="main">)</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts'"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv<span class="main">)</span>  
    <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> Cons.IH<span class="main">[</span><span class="operator">OF</span> PP<span class="main">]</span>
  
    <span class="keyword1"><span class="command">from</span></span> FIRST <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> FIRST IH
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases 
          <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> relabel_nonsat_potential nonsat_push_decr_nonsat_potential 
          <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sat_push_nonsat_potential
      <span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  
  
  <span class="comment1">(* TODO: Technical case distinction, as we do not assume invariant on f,l! *)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a'</span> <span class="skolem">p'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">using</span></span> A
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_lts'.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> B1  
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> nonsat_potential_bound  
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> sat_push_action_bound'<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> relabel_action_bound'<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="free">p</span><span class="main">)</span>
      <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">+</span> <span class="numeral">8</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E <span class="main">+</span> <span class="numeral">4</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">3</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> power2_eq_square power3_eq_cube<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">3</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_V_est_E power2_eq_square power3_eq_cube<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="free">p</span><span class="main">)</span> 
      <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">+</span> <span class="numeral">16</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span><span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter is_NONSAT_PUSH' <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">18</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>    
        
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>  
        
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Assembling the Final Theorem›</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We combine the bounds for saturating and non-saturating push 
  operations.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> push_action_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>filter <span class="main">(</span>is_PUSH<span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">22</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> xfer_push_bounds<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ A<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> sat_push_action_bound'<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> nonsat_push_action_bound'<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> power2_eq_square<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We estimate the cost of a push by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(1)›</span></span></span></span>, and of 
  a relabel operation by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V)›</span></span></span></span>›</span></span>
    
<span class="keyword1"><span class="command">fun</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> <span class="entity">cost_estimate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"pr_operation <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cost_estimate</span> RELABEL <span class="main">=</span> card V"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cost_estimate</span> PUSH <span class="main">=</span> <span class="main">1</span>"</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show the complexity bound of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>E)›</span></span></span></span> when starting from any valid
  labeling \cormen{26.24}.›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> pr_algo_cost_bound<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">←</span><span class="free">p</span><span class="main">.</span> cost_estimate <span class="bound">a</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">26</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">2</span> <span class="main">*</span> card E"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">←</span><span class="free">p</span><span class="main">.</span> cost_estimate <span class="bound">a</span><span class="main">)</span> 
    <span class="main">=</span> card V <span class="main">*</span> length <span class="main">(</span>filter is_RELABEL <span class="free">p</span><span class="main">)</span> <span class="main">+</span> length <span class="main">(</span>filter is_PUSH <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card V <span class="main">*</span> length <span class="main">(</span>filter is_RELABEL <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">3</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> relabel_action_bound<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> power2_eq_square power3_eq_cube<span class="main">)</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> push_action_bound<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map cost_estimate <span class="free">p</span><span class="main">)</span> 
              <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">^</span> <span class="numeral">3</span> <span class="main">+</span> <span class="numeral">22</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">3</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_V_est_E power2_eq_square power3_eq_cube<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>     
<span class="keyword1"><span class="command">qed</span></span>      
      
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Main Theorem: Correctness and Complexity›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we state the main theorem of this section:
  If the algorithm executes some steps from the beginning, then
    <span class="antiquoted"><span class="antiquoted">▸</span></span> If no further steps are possible from the reached state, we have 
      computed a maximum flow~\cormen{26.18}.
    <span class="antiquoted"><span class="antiquoted">▸</span></span> The cost of these steps is bounded by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>O(V<span class="hidden">⇧</span><sup>2</sup>E)›</span></span></span></span>~\cormen{26.24}. 
      Note that this also implies termination.
›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> generic_preflow_push_OV2E_and_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>pp_init_f<span class="main">,</span> pp_init_l<span class="main">)</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="main">(</span><span class="free">f</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">←</span><span class="free">p</span><span class="main">.</span> cost_estimate <span class="bound">x</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">26</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main">^</span><span class="numeral">2</span> <span class="main">*</span> card E"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∉</span>Domain pr_algo_lts <span class="main">⟶</span> isMaxFlow <span class="free">f</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> pp_init_height_bound Height_Bounded_Labeling.pr_algo_cost_bound A 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pp_init_height_bound trcl_conv 
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Height_Bounded_Labeling.pr_algo_maintains_hb_labeling<span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
    <span class="keyword1"><span class="command">from</span></span> pr_algo_term_maxflow <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>      
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Convenience Tools for Implementation›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In order to show termination of the algorithm, 
  we only need a well-founded relation over push and relabel steps›</span></span>
  
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">pr_algo_rel</span> <span class="keyword2"><span class="keyword">where</span></span>
  push<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_rel</span>"</span></span>
<span class="main">|</span> relabel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">⟧</span>
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span>relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">pr_algo_rel</span>"</span></span>

<span class="keyword1" id="Generic_Push_Relabel-pr_algo_rel_alt"><span class="command">lemma</span></span> pr_algo_rel_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"pr_algo_rel <span class="main">=</span> 
    <span class="main">{</span> <span class="main">(</span><span class="main">(</span>push_effect <span class="bound">f</span> <span class="bound">e</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f</span> <span class="bound">e</span> <span class="bound">l</span><span class="main">.</span> 
        Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span> <span class="main">∧</span> push_precond <span class="bound">f</span> <span class="bound">l</span> <span class="bound">e</span> <span class="main">}</span>
  <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> relabel_effect <span class="bound">f</span> <span class="bound">l</span> <span class="bound">u</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f</span> <span class="bound">u</span> <span class="bound">l</span><span class="main">.</span> 
        Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span> <span class="main">∧</span> relabel_precond <span class="bound">f</span> <span class="bound">l</span> <span class="bound">u</span> <span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pr_algo_rel.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> pr_algo_rel.intros<span class="main">)</span>
  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pr_algo_len_bound</span> <span class="main">≡</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">+</span> <span class="numeral">22</span> <span class="main">*</span> <span class="main">(</span>card V<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>2</sup></span> <span class="main">*</span> card E"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> pr_algo_lts_length_bound<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="main">(</span><span class="free">f'</span><span class="main">,</span> <span class="free">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">≤</span> pr_algo_len_bound"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> length <span class="main">(</span>filter is_PUSH <span class="free">p</span><span class="main">)</span> <span class="main">+</span> length <span class="main">(</span>filter is_RELABEL <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> push_action_bound<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> relabel_action_bound<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> pr_algo_len_bound_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
<span class="keyword1"><span class="command">qed</span></span>    
    
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> path_set_finite<span class="main">:</span>  
  <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">p</span><span class="main">.</span> <span class="main">∃</span><span class="bound">f'</span> <span class="bound">l'</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">have</span></span> FIN_OPS<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV<span class="main">::</span>pr_operation set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{</span>PUSH<span class="main">,</span>RELABEL<span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> pr_operation.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">p</span><span class="main">.</span> <span class="main">∃</span><span class="bound">f'</span> <span class="bound">l'</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts<span class="main">}</span> 
    <span class="main">⊆</span> <span class="main">{</span><span class="bound">p</span><span class="main">.</span> length <span class="bound">p</span> <span class="main">≤</span> pr_algo_len_bound<span class="main">}</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pr_algo_lts_length_bound<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> finite_lists_length_le<span class="main">[</span><span class="operator">OF</span> FIN_OPS<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>finite_subset<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pr_algo_measure</span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> Max <span class="main">{</span>length <span class="bound">p</span> <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="main">∃</span><span class="bound">aa</span> <span class="bound">ba</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">,</span> <span class="bound">p</span><span class="main">,</span> <span class="bound">aa</span><span class="main">,</span> <span class="bound">ba</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts<span class="main">}</span>"</span></span>  
  
<span class="keyword1" id="Generic_Push_Relabel-pr_algo_measure"><span class="command">lemma</span></span> pr_algo_measure<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">fl'</span><span class="main">,</span><span class="free">fl</span><span class="main">)</span> <span class="main">∈</span> pr_algo_rel"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pr_algo_measure <span class="free">fl'</span> <span class="main">&lt;</span> pr_algo_measure <span class="free">fl</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms  
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">fl'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">fl</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">f'</span> <span class="skolem">l'</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span><span class="skolem">l'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_rel"</span></span>  
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> LTS_STEP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span><span class="skolem">l'</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>pr_algo_lts"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> pr_algo_lts.intros<span class="main">)</span>  
      
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>    
  <span class="keyword1"><span class="command">from</span></span> pr_algo_maintains_hb_labeling<span class="main">[</span><span class="operator">OF</span> LTS_STEP<span class="main">]</span> 
  <span class="keyword1"><span class="command">interpret</span></span> f'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="bound">p</span> <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="main">∃</span><span class="bound">fx</span> <span class="bound">lx</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span> <span class="skolem">l</span><span class="main">)</span><span class="main">,</span> <span class="bound">p</span><span class="main">,</span> <span class="bound">fx</span><span class="main">,</span> <span class="bound">lx</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts<span class="main">}</span>"</span></span>    
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="bound">p</span> <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="main">∃</span><span class="bound">fx</span> <span class="bound">lx</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">l'</span><span class="main">)</span><span class="main">,</span> <span class="bound">p</span><span class="main">,</span> <span class="bound">fx</span><span class="main">,</span> <span class="bound">lx</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts<span class="main">}</span>"</span></span>    

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finite_image_set path_set_finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S1</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>   
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="skolem"><span class="skolem">fx</span></span> <span class="skolem"><span class="skolem">lx</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"length <span class="skolem">p</span> <span class="main">=</span> Max <span class="var">?S1</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span> <span class="skolem">l</span><span class="main">)</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">fx</span><span class="main">,</span> <span class="skolem">lx</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Max_in<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finite_image_set f'.path_set_finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S2</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> MG<span class="main">:</span> <span class="quoted"><span class="quoted">"Max <span class="var">?S2</span> <span class="main">≥</span> Max <span class="var">?S1</span>"</span></span>
  
    <span class="keyword1"><span class="command">from</span></span> Max_in<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹finite <span class="var">?S2</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?S2</span><span class="main">≠</span><span class="main">{}</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="skolem"><span class="skolem">fx</span></span> <span class="skolem"><span class="skolem">lx</span></span> <span class="keyword2"><span class="keyword">where</span></span>  
      <span class="quoted"><span class="quoted">"length <span class="skolem">p</span> <span class="main">=</span> Max <span class="var">?S2</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">l'</span><span class="main">)</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">fx</span><span class="main">,</span> <span class="skolem">lx</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> MG LTS_STEP <span class="keyword1"><span class="command">have</span></span>
      LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">a</span><span class="main">#</span><span class="skolem">p</span><span class="main">)</span> <span class="main">&gt;</span> Max <span class="var">?S1</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f</span><span class="main">,</span><span class="skolem">l</span><span class="main">)</span><span class="main">,</span><span class="skolem">a</span><span class="main">#</span><span class="skolem">p</span><span class="main">,</span><span class="main">(</span><span class="skolem">fx</span><span class="main">,</span><span class="skolem">lx</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> trcl pr_algo_lts"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trcl_conv<span class="main">)</span>  
    <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">a</span><span class="main">#</span><span class="skolem">p</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?S1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> Max_ge<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹finite <span class="var">?S1</span>›</span></span> this<span class="main">]</span> LEN <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>   
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"pr_algo_measure <span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">l'</span><span class="main">)</span> <span class="main">&lt;</span> pr_algo_measure <span class="main">(</span><span class="skolem">f</span><span class="main">,</span> <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pr_algo_measure_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="Generic_Push_Relabel-wf_pr_algo_rel"><span class="command">lemma</span></span> wf_pr_algo_rel<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wf pr_algo_rel"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_measure<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">pr_algo_measure</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pr_algo_measure<span class="main">)</span>  
  
      
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Gap Heuristics›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If we find a label value <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>k›</span></span></span></span> that is assigned to no node,
  we may relabel all nodes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>k &lt; l v &lt; card V›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>card V + 1›</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_precond</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_effect</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">&lt;</span> card V <span class="keyword1">then</span> card V <span class="main">+</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span>"</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The gap heuristics preserves a valid labeling.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> gap_pres_Labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"gap_precond <span class="free">l</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="main">≡</span> gap_effect <span class="free">l</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>    
  <span class="keyword1"><span class="command">from</span></span> lab_src <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="free">s</span> <span class="main">=</span> card V"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_effect_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> lab_sink <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="free">t</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_effect_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> l'_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="skolem">v</span> <span class="main">≥</span> <span class="free">l</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_effect_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span>  
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="skolem">u</span> <span class="main">≤</span> <span class="free">l'</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_effect_def
    <span class="keyword1"><span class="command">using</span></span> valid<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> PRE 
    <span class="keyword1"><span class="command">unfolding</span></span> gap_precond_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The gap heuristics also preserves the height bounds.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> gap_pres_hb_labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"gap_precond <span class="free">l</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="main">≡</span> gap_effect <span class="free">l</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l'</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> gap_pres_Labeling<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> <span class="keyword1"><span class="command">interpret</span></span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l'</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> l'_def <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_effect_def <span class="keyword1"><span class="command">using</span></span> height_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We combine the regular relabel operation with the gap heuristics:
  If relabeling results in a gap, the gap heuristics is applied immediately.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_relabel_effect</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">l'</span> <span class="main">=</span> relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">in</span>
  <span class="keyword1">if</span> <span class="main">(</span>gap_precond <span class="bound">l'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span> gap_effect <span class="bound">l'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">l'</span>
"</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The combined gap-relabel operation preserves a valid labeling.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> gap_relabel_pres_Labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="main">≡</span> gap_relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_relabel_effect_def
  <span class="keyword1"><span class="command">using</span></span> relabel_pres_Labeling<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> Labeling.gap_pres_Labeling
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The combined gap-relabel operation preserves the height-bound.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> gap_relabel_pres_hb_labeling<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="main">≡</span> gap_relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l'</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> l'_def gap_relabel_effect_def
  <span class="keyword1"><span class="command">using</span></span> relabel_pres_height_bound<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> Height_Bounded_Labeling.gap_pres_hb_labeling
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Termination with Gap Heuristics›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Intuitively, the algorithm with the gap heuristics terminates because 
  relabeling according to the gap heuristics preserves the invariant and 
  increases some labels towards their upper bound. 

  Formally, the simplest way is to combine a heights measure function with
  the already established measure for the standard algorithm:
›</span></span>    
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> gap_measure<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gap_precond <span class="free">l</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sum_heights_measure <span class="main">(</span>gap_effect <span class="free">l</span> <span class="free">k</span><span class="main">)</span> <span class="main">≤</span> sum_heights_measure <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gap_effect_def sum_heights_measure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum_mono<span class="main">)</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Height_Bounded_Labeling<span class="main">)</span> gap_relabel_measure<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sum_heights_measure <span class="main">(</span>gap_relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> sum_heights_measure <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gap_relabel_effect_def
  <span class="keyword1"><span class="command">using</span></span> relabel_measure<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> relabel_pres_height_bound<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> Height_Bounded_Labeling.gap_measure
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Analogously to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> pr_algo_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we provide a well-founded relation 
  that over-approximates the steps of a push-relabel algorithm with gap 
  heuristics.
›</span></span>    
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">gap_algo_rel</span> <span class="keyword2"><span class="keyword">where</span></span>
  push<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">gap_algo_rel</span>"</span></span>
<span class="main">|</span> relabel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">⟧</span>
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span>gap_relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">gap_algo_rel</span>"</span></span>
  
<span class="keyword1" id="Generic_Push_Relabel-wf_gap_algo_rel"><span class="command">lemma</span></span> wf_gap_algo_rel<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wf gap_algo_rel"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gap_algo_rel <span class="main">⊆</span> inv_image <span class="main">(</span>less_than <span class="keyword1">&lt;*lex*&gt;</span> less_than<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>sum_heights_measure <span class="bound">l</span><span class="main">,</span> pr_algo_measure <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> pr_algo_measure  
    <span class="keyword1"><span class="command">using</span></span> Height_Bounded_Labeling.gap_relabel_measure  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> gap_algo_rel.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> pr_algo_rel.intros <span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> wf_subset<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>
  
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Prpu_Common_Inst">
<div class="head">
<h1>Theory Prpu_Common_Inst</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Prpu_Common_Inst
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../flow_networks/theories/#Refine_Add_Fofu">Flow_Networks.Refine_Add_Fofu</a>
  <a href="#Generic_Push_Relabel">Generic_Push_Relabel</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span>relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span>relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_relabel</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span>relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">∧</span> relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span>gap_relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">push</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span>push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span>Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>  

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Fifo_Push_Relabel">
<div class="head">
<h1>Theory Fifo_Push_Relabel</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹FIFO Push Relabel Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Fifo_Push_Relabel
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../flow_networks/theories/#Refine_Add_Fofu">Flow_Networks.Refine_Add_Fofu</a>
  <a href="#Generic_Push_Relabel">Generic_Push_Relabel</a> 
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The FIFO push-relabel algorithm maintains a first-in-first-out queue
  of active nodes. As long as the queue is not empty, it discharges the 
  first node of the queue. 

  Discharging repeatedly applied push operations from the node.
  If no more push operations are possible, and the node is still active, 
  it is relabeled and enqueued.

  Moreover, we implement the gap heuristics, which may accelerate relabeling
  if there is a gap in the label values, i.e., a label value that is assigned 
  to no node.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementing the Discharge Operation›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, we implement push and relabel operations that maintain 
  a queue of all active nodes. 
›</span></span>  
<span class="comment1">(* TODO: Use push and relabel from Prpu_Common_Inst.thy ! *)</span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span>push_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Q</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">≠</span><span class="free">t</span> <span class="main">∧</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">@</span><span class="main">[</span><span class="bound">v</span><span class="main">]</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span>push_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
<span class="main">}</span>"</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the relabel operation, we assume that
  only active nodes are relabeled, and enqueue the relabeled node.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_gap_relabel</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Q</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">@</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>relabel_precond <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V <span class="main">∧</span> relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> gap_relabel_effect <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
<span class="main">}</span>"</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The discharge operation iterates over the edges, and pushes 
  flow, as long as then node is active. If the node is still active after all 
  edges have been saturated, the node is relabeled.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_discharge</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>  
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">u</span><span class="main">=</span>hd <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">Q</span><span class="main">=</span>tl <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">u</span><span class="main">∈</span>V <span class="main">∧</span> <span class="bound">u</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">u</span><span class="main">≠</span><span class="free">t</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> FOREACHc <span class="main">{</span><span class="bound">v</span> <span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">}</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> excess <span class="bound">f</span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="bound">l</span> <span class="bound">u</span> <span class="main">=</span> <span class="bound">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_push <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">.</span> <span class="bound">v'</span><span class="main">≠</span><span class="bound">v</span> <span class="main">⟶</span> cf_of <span class="bound">f'</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">=</span> cf_of <span class="bound">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">if</span> excess <span class="bound">f</span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_gap_relabel <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span> <span class="bound">u</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We will show that the discharge operation maintains the invariant that the queue
  is disjoint and contains exactly the active nodes:
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> distinct <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∧</span> set <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> <span class="main">{</span> <span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">}</span>"</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Inside the loop of the discharge operation, we will use the following 
  version of the invariant:›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">QD_invar</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∧</span> set <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> <span class="main">{</span> <span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">.</span> excess <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">}</span>"</span></span>  

  
<span class="keyword1" id="Fifo_Push_Relabel-Q_invar_when_discharged1"><span class="command">lemma</span></span> Q_invar_when_discharged1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>QD_invar <span class="free">u</span> <span class="free">f</span> <span class="free">Q</span><span class="main">;</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">=</span> <span class="main">0</span><span class="main">⟧</span> <span class="main">⟹</span> Q_invar <span class="free">f</span> <span class="free">Q</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> Q_invar_def QD_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Fifo_Push_Relabel-Q_invar_when_discharged2"><span class="command">lemma</span></span> Q_invar_when_discharged2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>QD_invar <span class="free">u</span> <span class="free">f</span> <span class="free">Q</span><span class="main">;</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">0</span><span class="main">⟧</span> <span class="main">⟹</span> Q_invar <span class="free">f</span> <span class="main">(</span><span class="free">Q</span><span class="main">@</span><span class="main">[</span><span class="free">u</span><span class="main">]</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> Q_invar_def QD_invar_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> push_no_activate_pres_QD_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"QD_invar <span class="free">u</span> <span class="free">f</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">=</span><span class="free">v</span> <span class="main">∨</span> <span class="free">t</span><span class="main">=</span><span class="free">v</span> <span class="main">∨</span> excess <span class="free">f</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"QD_invar <span class="free">u</span> <span class="main">(</span>push_effect <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">v</span></span> 
    <span class="keyword1"><span class="command">using</span></span> PRE <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
  <span class="keyword1"><span class="command">from</span></span> excess_non_negative Δ_positive <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">v</span> <span class="main">+</span> Δ <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
    <span class="keyword1"><span class="command">using</span></span> VC INV
    <span class="keyword1"><span class="command">unfolding</span></span> QD_invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess'_if <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> push_activate_pres_QD_invar<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"QD_invar <span class="free">u</span> <span class="free">f</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"QD_invar <span class="free">u</span> <span class="main">(</span>push_effect <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">Q</span><span class="main">@</span><span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">v</span></span> 
    <span class="keyword1"><span class="command">using</span></span> PRE <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
    <span class="keyword1"><span class="command">using</span></span> VC INV Δ_positive
    <span class="keyword1"><span class="command">unfolding</span></span> QD_invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess'_if <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Main theorem for the discharge operation:
  It maintains a height bounded labeling, the invariant for the FIFO queue,
  and only performs valid steps due to the generic push-relabel algorithm with
  gap-heuristics.
›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> fifo_discharge_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DINV<span class="main">:</span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> QINV<span class="main">:</span> <span class="quoted"><span class="quoted">"Q_invar <span class="free">f</span> <span class="free">Q</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> QNE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_discharge <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">,</span><span class="bound">Q'</span><span class="main">)</span><span class="main">.</span> 
      Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f'</span> <span class="bound">l'</span> 
    <span class="main">∧</span> Q_invar <span class="bound">f'</span> <span class="bound">Q'</span> 
    <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gap_algo_rel<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>
  <span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> QNE <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">Qr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">=</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">Qr</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">from</span></span> QINV <span class="keyword1"><span class="command">have</span></span> U<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"QD_invar <span class="skolem">u</span> <span class="free">f</span> <span class="skolem">Qr</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> XU_orig<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_invar_def QD_invar_def<span class="main">)</span>    

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="free">f</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">V</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> cfE_of_ss_VxV  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> U
    <span class="keyword1"><span class="command">unfolding</span></span> fifo_discharge_def fifo_push_def fifo_gap_relabel_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> split nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"FOREACHc <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> vcg_intro_frame<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">if</span></span> excess <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">≠</span></span> <span class="main"><span class="main">0</span></span> <span class="keyword1"><span class="keyword1">then</span></span> <span class="main"><span class="main">⌑</span></span> <span class="keyword1"><span class="keyword1">else</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> vcg_intro_frame<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> FOREACHc_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
            I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">,</span><span class="bound">Q'</span><span class="main">)</span><span class="main">.</span> 
                Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f'</span> <span class="bound">l'</span> 
              <span class="main">∧</span> QD_invar <span class="skolem">u</span> <span class="bound">f'</span> <span class="bound">Q'</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gap_algo_rel<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>
              <span class="main">∧</span> <span class="bound">it</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="bound">f'</span> <span class="main">}</span>
              <span class="main">∧</span> <span class="main">(</span>excess <span class="bound">f'</span> <span class="skolem">u</span><span class="main">≠</span><span class="main">0</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="bound">f'</span> <span class="main">}</span><span class="main">-</span><span class="bound">it</span><span class="main">.</span> <span class="bound">l'</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="bound">l'</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
            <span class="main">)</span>
            "</span></span>
          <span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> DINV QINV it_step_insert_iff <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v it f' l' Q' <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">assume</span></span> HBL<span class="main">:</span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f'</span> <span class="skolem">l'</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="keyword1"><span class="command">.</span></span>  
      
      <span class="keyword3"><span class="command">assume</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> QDI<span class="main">:</span> <span class="quoted"><span class="quoted">"QD_invar <span class="skolem">u</span> <span class="skolem">f'</span> <span class="skolem">Q'</span>"</span></span>  
          
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">it</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ITSS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">it</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> l'.cf.E<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> UVE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> l'.cf.E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      
      <span class="keyword3"><span class="command">assume</span></span> REL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">l'</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span> <span class="main">∈</span> gap_algo_rel<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>    
          
      <span class="keyword3"><span class="command">assume</span></span> SAT_EDGES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="skolem">f'</span><span class="main">}</span> <span class="main">-</span> <span class="skolem">it</span><span class="main">.</span> <span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">≠</span> Suc <span class="main">(</span><span class="skolem">l'</span> <span class="bound">v</span><span class="main">)</span>"</span></span>  
        
      <span class="keyword1"><span class="command">from</span></span> X UI l'.excess_non_negative <span class="keyword1"><span class="command">have</span></span> X'<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>   
          
      <span class="keyword1"><span class="command">have</span></span> PP<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">l'</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">using</span></span> that UVE X' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_rem_frame<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">if</span></span> <span class="main"><span class="main">_</span></span> <span class="keyword1"><span class="keyword1">then</span></span> <span class="main"><span class="main">(</span></span><span class="keyword1"><span class="keyword1">assert</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⪢</span></span> <span class="main"><span class="main">⌑</span></span><span class="main"><span class="main">)</span></span> <span class="keyword1"><span class="keyword1">else</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> vcg_intro_frame<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> REL <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> PP l'.push_pres_height_bound HBL QDI <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">=</span> Suc <span class="main">(</span><span class="skolem">l'</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> 
          <span class="keyword3"><span class="command">assume</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> pe<span class="main">:</span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
          
          <span class="keyword1"><span class="command">have</span></span> UVNE'<span class="main">:</span> <span class="quoted"><span class="quoted">"l'.cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>    
            <span class="keyword1"><span class="command">using</span></span> l'.resE_positive <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_rem_frame<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> l'.push_pres_height_bound<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>  
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pe.cf'_alt augment_edge_cf_def<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
              <span class="keyword1"><span class="command">using</span></span> l'.push_activate_pres_QD_invar<span class="main">[</span><span class="operator">OF</span> QDI PRE<span class="main">]</span> 
              <span class="keyword1"><span class="command">using</span></span> l'.push_no_activate_pres_QD_invar<span class="main">[</span><span class="operator">OF</span> QDI PRE<span class="main">]</span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> gap_algo_rel.push REL PRE converse_rtrancl_into_rtrancl HBL<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="skolem">it</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">≠</span><span class="skolem">v</span>"</span></span>
              <span class="keyword1"><span class="command">with</span></span> ITSS <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∈</span>l'.cf.E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">v</span>›</span></span>
                <span class="keyword1"><span class="command">unfolding</span></span> pe.f'_alt 
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_edge_cf'<span class="main">)</span>
                <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def  
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v' <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">u</span> <span class="main">≠</span> pe.Δ"</span></span>
              <span class="keyword1"><span class="command">hence</span></span> PED<span class="main">:</span> <span class="quoted"><span class="quoted">"pe.Δ <span class="main">=</span> l'.cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">unfolding</span></span> pe.Δ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">hence</span></span> E'SS<span class="main">:</span> <span class="quoted"><span class="quoted">"pe.l'.cf.E <span class="main">⊆</span> <span class="main">(</span>l'.cf.E <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
                <span class="keyword1"><span class="command">unfolding</span></span> pe.f'_alt 
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_edge_cf'<span class="main">)</span>
                <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def  
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
                  
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> <span class="skolem">it</span> <span class="main">⟶</span> <span class="skolem">v'</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UV'E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> pe.l'.cf.E"</span></span> <span class="keyword2"><span class="keyword">and</span></span> LUSLV'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">v</span> <span class="main">=</span> <span class="skolem">l'</span> <span class="skolem">v'</span>"</span></span>    
              <span class="keyword1"><span class="command">with</span></span> E'SS <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∉</span><span class="skolem">it</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> UV'E E'SS pe.uv_not_eq<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>l'.cf.E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">≠</span> Suc <span class="main">(</span><span class="skolem">l'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> SAT_EDGES <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
              <span class="keyword1"><span class="command">with</span></span> LUSLV' <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
            <span class="keyword1"><span class="command">qed</span></span>      
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span>      
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> ITSS <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> SAT_EDGES <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> f' l' Q' <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> UI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="free">t</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> QDI<span class="main">:</span> <span class="quoted"><span class="quoted">"QD_invar <span class="skolem">u</span> <span class="skolem">f'</span> <span class="skolem">Q'</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> REL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">f'</span><span class="main">,</span> <span class="skolem">l'</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span> <span class="main">∈</span> gap_algo_rel<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> NO_ADM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> l'.cf.E <span class="main">⟶</span> <span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">≠</span> Suc <span class="main">(</span><span class="skolem">l'</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
        
      <span class="keyword1"><span class="command">from</span></span> X <span class="keyword1"><span class="command">have</span></span> X'<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> l'.excess_non_negative UI <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>    
          
      <span class="keyword1"><span class="command">from</span></span> X' UI NO_ADM <span class="keyword1"><span class="command">have</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="skolem">u</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
      <span class="keyword1"><span class="command">from</span></span> l'.height_bound <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>V›</span></span> card_V_ge2 <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
      <span class="keyword1"><span class="command">from</span></span> l'.relabel_pres_height_bound<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
      <span class="keyword1"><span class="command">interpret</span></span> l''<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="quoted">"relabel_effect <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
          
      <span class="keyword1"><span class="command">from</span></span> l''.height_bound <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>V›</span></span> card_V_ge2 <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="skolem">u</span> <span class="skolem">u</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_rem_frame<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> UI PRE 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> l'.gap_relabel_pres_hb_labeling<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_invar_when_discharged2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> QDI X<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>    
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> PRE REL gap_algo_rel.relabel l'.Height_Bounded_Labeling_axioms rtrancl_into_trancl2<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    <span class="keyword1"><span class="command">qed</span></span>      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_invar_when_discharged1 Q_invar_when_discharged2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> XU_orig <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Pair_inject rtranclD<span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_invar_when_discharged1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> XU_orig <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Pair_inject rtranclD<span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Main Algorithm›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The main algorithm initializes the flow, labeling, and the queue, 
  and then applies the discharge operation until the queue is empty:
›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> pp_init_f<span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> pp_init_l<span class="main">;</span>

  <span class="bound">Q</span> <span class="main">←</span> <span class="keyword1">spec</span> <span class="bound">l</span><span class="main">.</span> distinct <span class="bound">l</span> <span class="main">∧</span> set <span class="bound">l</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">v</span></span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="bound">f</span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">;</span> <span class="comment1">― ‹TODO: This is exactly <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>E``{s} - {t}›</span></span>!›</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="bound">Q</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    fifo_discharge <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Having proved correctness of the discharge operation, the correctness 
  theorem of the main algorithm is straightforward: 
  As the discharge operation implements the generic algorithm, the loop
  will terminate after finitely many steps.
  Upon termination, the queue that contains exactly the active nodes is empty.
  Thus, all nodes are inactive, and the resulting preflow is actually a maximal 
  flow. 
›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> fifo_push_relabel_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"fifo_push_relabel <span class="main">≤</span> SPEC isMaxFlow"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span>  
      WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
            I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span> <span class="main">∧</span> Q_invar <span class="bound">f</span> <span class="bound">Q</span>"</span></span>
        <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>gap_algo_rel<span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> pp_init_height_bound<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> wf_lex_prod wf_trancl<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> initQ f l <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f</span> <span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Q_invar <span class="skolem">f</span> <span class="main">[]</span>"</span></span>    
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="skolem">f</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Q_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> no_excess_imp_maxflow<span class="main">)</span>    
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
    
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Graph_Topological_Ordering">
<div class="head">
<h1>Theory Graph_Topological_Ordering</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Topological Ordering of Graphs"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Graph_Topological_Ordering
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../refine_imperative_hol/theories/#Sepref_Misc">Refine_Imperative_HOL.Sepref_Misc</a>
  <span class="quoted">"<a href="../List-Index/List_Index.html">List-Index.List_Index</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹List-Before Relation›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Two elements of a list are in relation if the first element comes (strictly) before
  the second element.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">list_before_rel</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">l1</span> <span class="bound">l2</span> <span class="bound">l3</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">=</span><span class="bound">l1</span><span class="main">@</span><span class="bound">a</span><span class="main">#</span><span class="bound">l2</span><span class="main">@</span><span class="bound">b</span><span class="main">#</span><span class="bound">l3</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹list-before only relates elements of the list›</span></span>    
<span class="keyword1" id="Graph_Topological_Ordering-list_before_rel_on_elems"><span class="command">lemma</span></span> list_before_rel_on_elems<span class="main">:</span> <span class="quoted"><span class="quoted">"list_before_rel <span class="free">l</span> <span class="main">⊆</span> set <span class="free">l</span> <span class="main">×</span> set <span class="free">l</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Irreflexivity of list-before is equivalent to the elements of the list being disjoint.›</span></span>  
<span class="keyword1" id="Graph_Topological_Ordering-list_before_irrefl_eq_distinct"><span class="command">lemma</span></span> list_before_irrefl_eq_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"irrefl <span class="main">(</span>list_before_rel <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> distinct <span class="free">l</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> not_distinct_decomp<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> irrefl_def list_before_rel_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative characterization via indexes›</span></span>    
<span class="keyword1" id="Graph_Topological_Ordering-list_before_rel_alt"><span class="command">lemma</span></span> list_before_rel_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"list_before_rel <span class="free">l</span> <span class="main">=</span> <span class="main">{</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="bound">i</span><span class="main">,</span> <span class="free">l</span><span class="main">!</span><span class="bound">j</span><span class="main">)</span> <span class="main">|</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span>length <span class="free">l</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a b l1 l2 l3  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">l1</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">l1</span> <span class="main">+</span> Suc <span class="main">(</span>length <span class="skolem">l2</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> i j
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"take <span class="skolem">i</span> <span class="free">l</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"drop <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>take <span class="skolem">j</span> <span class="free">l</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"drop <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="free">l</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_nth_drop_Suc drop_take_drop_unsplit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹list-before is a strict ordering, i.e., it is transitive and asymmetric.›</span></span>    
<span class="keyword1" id="Graph_Topological_Ordering-list_before_trans"><span class="command">lemma</span></span> list_before_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">l</span> <span class="main">⟹</span> trans <span class="main">(</span>list_before_rel <span class="free">l</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trans_def list_before_rel_alt<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> index_nth_id less_trans<span class="main">)</span>    
    
<span class="keyword1" id="Graph_Topological_Ordering-list_before_asym"><span class="command">lemma</span></span> list_before_asym<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">l</span> <span class="main">⟹</span> asym <span class="main">(</span>list_before_rel <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> asym.intros irrefl_def list_before_irrefl_eq_distinct list_before_trans transE<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Structural properties on the list›</span></span>    
<span class="keyword1" id="Graph_Topological_Ordering-list_before_rel_empty"><span class="command">lemma</span></span> list_before_rel_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_before_rel <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1" id="Graph_Topological_Ordering-list_before_rel_cons"><span class="command">lemma</span></span> list_before_rel_cons<span class="main">:</span> <span class="quoted"><span class="quoted">"list_before_rel <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">×</span>set <span class="free">l</span><span class="main">)</span> <span class="main">∪</span> list_before_rel <span class="free">l</span>"</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_paired_all<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a b <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> list_before_rel <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">l</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> IDX_BOUND<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span><span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>Suc <span class="main">(</span>length <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span><span class="main">!</span><span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">=</span><span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span><span class="main">!</span><span class="skolem">j</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">=</span><span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>set <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IDX_BOUND
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≠</span><span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> IDX_BOUND <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="free">l</span><span class="main">!</span><span class="main">(</span><span class="skolem">i</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">=</span><span class="free">l</span><span class="main">!</span><span class="main">(</span><span class="skolem">j</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">-</span><span class="main">1</span> <span class="main">&lt;</span> <span class="skolem">j</span><span class="main">-</span><span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">-</span><span class="main">1</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> list_before_rel <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a b  
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>set <span class="free">l</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="free">l</span><span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span><span class="main">!</span><span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span><span class="main">!</span>Suc <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> Suc <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>    
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> list_before_rel <span class="free">l</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> list_before_rel_alt
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> Suc_mono nth_Cons_Suc<span class="main">)</span>  
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Topological Ordering›</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A topological ordering of a graph (binary relation) is an enumeration of its
  nodes, such that for any two nodes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>,<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span> with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> being enumerated earlier than <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span>,
  there is no path from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> in the graph.

  We define the predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>is_top_sorted›</span></span></span></span> to capture the sortedness criterion, but
  not the completeness criterion, i.e., the list needs not contain all 
  nodes of the graph.
›</span></span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_top_sorted</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> list_before_rel <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">∩</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>  
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_alt"><span class="command">lemma</span></span> is_top_sorted_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="free">l</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">∈</span>list_before_rel <span class="free">l</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">∉</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_top_sorted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_empty_rel"><span class="command">lemma</span></span> is_top_sorted_empty_rel<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="main">{}</span> <span class="free">l</span> <span class="main">⟷</span> distinct <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_top_sorted_def list_before_irrefl_eq_distinct<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> irrefl_def<span class="main">)</span>

<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_empty_list"><span class="command">lemma</span></span> is_top_sorted_empty_list<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_top_sorted_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A topological sorted list must be distinct›</span></span>    
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_distinct"><span class="command">lemma</span></span> is_top_sorted_distinct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="free">l</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>  
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>distinct <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> list_before_irrefl_eq_distinct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>list_before_rel <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> irrefl_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> is_top_sorted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>      
<span class="keyword1"><span class="command">qed</span></span>  
  
    
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_cons"><span class="command">lemma</span></span> is_top_sorted_cons<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">×</span>set <span class="free">l</span> <span class="main">∩</span> <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∧</span> is_top_sorted <span class="free">R</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_top_sorted_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_before_rel_cons<span class="main">)</span>
    
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_append"><span class="command">lemma</span></span> is_top_sorted_append<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="main">(</span><span class="free">l1</span><span class="main">@</span><span class="free">l2</span><span class="main">)</span> 
  <span class="main">⟷</span> <span class="main">(</span>set <span class="free">l1</span><span class="main">×</span>set <span class="free">l2</span> <span class="main">∩</span> <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∧</span> is_top_sorted <span class="free">R</span> <span class="free">l1</span> <span class="main">∧</span> is_top_sorted <span class="free">R</span> <span class="free">l2</span>"</span></span>    
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l1</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_top_sorted_cons<span class="main">)</span>

<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_remove_elem"><span class="command">lemma</span></span> is_top_sorted_remove_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="main">(</span><span class="free">l1</span><span class="main">@</span><span class="free">x</span><span class="main">#</span><span class="free">l2</span><span class="main">)</span> <span class="main">⟹</span> is_top_sorted <span class="free">R</span> <span class="main">(</span><span class="free">l1</span><span class="main">@</span><span class="free">l2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_top_sorted_cons is_top_sorted_append<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Removing edges from the graph preserves topological sorting›</span></span>
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_antimono"><span class="command">lemma</span></span> is_top_sorted_antimono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main">⊆</span><span class="free">R'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R'</span> <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="free">l</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">unfolding</span></span> is_top_sorted_alt  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtrancl_mono_mp<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Adding a node to the graph, which has no incoming edges preserves topological ordering.
›</span></span>    
<span class="keyword1" id="Graph_Topological_Ordering-is_top_sorted_isolated_constraint"><span class="command">lemma</span></span> is_top_sorted_isolated_constraint<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R'</span> <span class="main">⊆</span> <span class="free">R</span> <span class="main">∪</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">×</span><span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R'</span><span class="main">∩</span>UNIV<span class="main">×</span><span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∉</span>set <span class="free">l</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R</span> <span class="free">l</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="free">R'</span> <span class="free">l</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">≠</span><span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">≠</span><span class="free">x</span>"</span></span>  
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> base
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span><span class="main">≠</span><span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
      <span class="keyword1"><span class="command">with</span></span> step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX<span class="main">=</span>this
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span> AUX list_before_rel_on_elems 
    <span class="keyword1"><span class="command">unfolding</span></span> is_top_sorted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>  



<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Relabel_To_Front">
<div class="head">
<h1>Theory Relabel_To_Front</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Relabel-to-Front Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Relabel_To_Front
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="#Prpu_Common_Inst">Prpu_Common_Inst</a> 
  <a href="#Graph_Topological_Ordering">Graph_Topological_Ordering</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As an example for an implementation, Cormen et al.\ discuss the 
    relabel-to-front algorithm.
    It iterates over a queue of nodes, discharging each node, and putting
    a node to the front of the queue if it has been relabeled.
›</span></span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Admissible Network›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The admissible network consists of those edges over which we 
  can push flow. ›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">adm_edges</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> <span class="main">(</span>nat<span class="main">⇒</span>nat<span class="main">)</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adm_edges</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound"><span class="bound">u</span></span><span class="main">,</span><span class="bound"><span class="bound">v</span></span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">u</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">}</span>"</span></span>
    
  <span class="keyword1" id="Relabel_To_Front-adm_edges_inv_disj"><span class="command">lemma</span></span> adm_edges_inv_disj<span class="main">:</span> <span class="quoted"><span class="quoted">"adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">∩</span> <span class="main">(</span>adm_edges <span class="free">f</span> <span class="free">l</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1" id="Relabel_To_Front-finite_adm_edges"><span class="command">lemma</span></span> finite_adm_edges<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>adm_edges <span class="free">f</span> <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"cfE_of <span class="free">f</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> adm_edges_def<span class="main">)</span>
  
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The edge of a push operation is admissible.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> push_effect_locale<span class="main">)</span> uv_adm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A push operation will not create new admissible edges, but the 
  edge that we pushed over may become inadmissible \cormen{26.27}.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> push_adm_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span> <span class="main">⊆</span> adm_edges <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span> <span class="main">⊆</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>sat<span class="main">)</span> <span class="quoted"><span class="quoted">"sat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span> 
                 <span class="main">|</span> <span class="main">(</span>nonsat<span class="main">)</span> <span class="quoted"><span class="quoted">"nonsat_push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> push_precond_eq_sat_or_nonsat<span class="main">)</span>                  
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G1</span> <span class="main">∧</span> <span class="var">?G2</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> sat <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> sat_push_alt<span class="main">[</span><span class="operator">OF</span> sat<span class="main">]</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="comment1">(* TODO: Clean up. Use push_effect_locale! *)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">(</span>augment_edge <span class="free">f</span> <span class="free">e</span> <span class="main">(</span>cf <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span> <span class="quoted"><span class="free">l</span></span> 
        <span class="keyword1"><span class="command">using</span></span> push_pres_Labeling<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> sat_push_alt<span class="main">[</span><span class="operator">OF</span> sat<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
    
      <span class="keyword1"><span class="command">from</span></span> sat <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∈</span>adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>    
        <span class="keyword1"><span class="command">unfolding</span></span> sat_push_precond_def adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"l'.cf.E <span class="main">⊆</span> insert <span class="main">(</span>prod.swap <span class="free">e</span><span class="main">)</span> cf.E <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"l'.cf.E <span class="main">⊇</span> cf.E <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> l'.cf_def cf_def
        <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def residualGraph_def Graph.E_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits prod.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l'.cf.E <span class="main">=</span> insert <span class="main">(</span>prod.swap <span class="free">e</span><span class="main">)</span> cf.E <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span> <span class="main">∨</span> l'.cf.E <span class="main">=</span> cf.E <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="var">?f'</span> <span class="free">l</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> disjE<span class="main"><span class="main">[</span></span><span class="operator">consumes</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> 1
        <span class="keyword1"><span class="command">from</span></span> sat <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> sat_push_precond_def adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> adm_edges_inv_disj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prod.swap <span class="free">e</span> <span class="main">∉</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_in_iff_inv<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="var">?f'</span> <span class="free">l</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> G1
          <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def 1   
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> 2
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="var">?f'</span> <span class="free">l</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> <span class="main">{</span><span class="free">e</span><span class="main">}</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def 2   
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>    
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> nonsat
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nonsat_push_alt<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">=</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
      
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"<span class="main">(</span>augment_edge <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>excess <span class="free">f</span> <span class="skolem">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span> <span class="quoted"><span class="free">l</span></span> 
        <span class="keyword1"><span class="command">using</span></span> push_pres_Labeling<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> nonsat_push_alt nonsat
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
      <span class="keyword1"><span class="command">from</span></span> nonsat <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> nonsat_push_precond_def adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> adm_edges_inv_disj <span class="keyword1"><span class="command">have</span></span> AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"prod.swap <span class="free">e</span> <span class="main">∉</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_in_iff_inv<span class="main">)</span>
          
      <span class="keyword1"><span class="command">from</span></span> nonsat <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="skolem">u</span> <span class="main">&lt;</span> cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> excess <span class="free">f</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="skolem">u</span> <span class="main">=</span> <span class="free">l</span> <span class="skolem">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> nonsat_push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l'.cf.E <span class="main">⊆</span> insert <span class="main">(</span>prod.swap <span class="free">e</span><span class="main">)</span> cf.E"</span></span> <span class="quoted"><span class="quoted">"l'.cf.E <span class="main">⊇</span> cf.E"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> l'.cf_def cf_def
        <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_def residualGraph_def Graph.E_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> capacity_const diff_0_right 
                diff_strict_left_mono not_less<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_le_same_cancel1 f_non_negative linorder_not_le<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"l'.cf.E <span class="main">=</span> insert <span class="main">(</span>prod.swap <span class="free">e</span><span class="main">)</span> cf.E <span class="main">∨</span> l'.cf.E <span class="main">=</span> cf.E"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="var">?f'</span> <span class="free">l</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> AUX
        <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def  
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command">qed</span></span>  
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>      
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
<span class="keyword1"><span class="command">qed</span></span>    
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹After a relabel operation, there is at least 
  one admissible edge leaving the relabeled node, 
  but no admissible edges do enter the relabeled node~\cormen{26.28}.
  Moreover, the part of the admissible network not adjacent to the relabeled 
  node does not change.
›</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> relabel_adm_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="main">≡</span> relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="free">f</span> <span class="free">l'</span> <span class="main">∩</span> cf.outgoing <span class="free">u</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="free">f</span> <span class="free">l'</span> <span class="main">∩</span> cf.incoming <span class="free">u</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="free">f</span> <span class="free">l'</span> <span class="main">-</span> cf.adjacent <span class="free">u</span> <span class="main">=</span> adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> cf.adjacent <span class="free">u</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span>  
        NOT_SINK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">t</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ACTIVE<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> NO_ADM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">⟹</span> <span class="free">l</span> <span class="free">u</span> <span class="main">≠</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">l</span> <span class="bound">v</span> <span class="main">|</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> active_has_cf_outgoing<span class="main">[</span><span class="operator">OF</span> ACTIVE<span class="main">]</span> cf.outgoing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> VUE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="skolem">v</span> <span class="main">=</span> Min <span class="main">{</span><span class="free">l</span> <span class="bound">v</span> <span class="main">|</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cf.E<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Min_in<span class="main">[</span><span class="operator">OF</span> finite_min_cf_outgoing<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main"><span class="main">]</span></span> NE<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> adm_edges <span class="free">f</span> <span class="free">l'</span> <span class="main">∩</span> cf.outgoing <span class="free">u</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> l'_def relabel_effect_def adm_edges_def cf.outgoing_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf_no_self_loop<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">uh</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">uh</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> adm_edges <span class="free">f</span> <span class="free">l'</span>"</span></span>  
    <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="skolem">uh</span> <span class="main">=</span> <span class="free">l'</span> <span class="free">u</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UHUE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">uh</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">uh</span> <span class="main">≠</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> cf_no_self_loop <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l'</span> <span class="skolem">uh</span> <span class="main">=</span> <span class="free">l</span> <span class="skolem">uh</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> l'_def relabel_effect_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> 1 relabel_increase_u<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">,</span> <span class="operator">folded</span> l'_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="skolem">uh</span> <span class="main">&gt;</span> <span class="free">l</span> <span class="free">u</span> <span class="main">+</span> <span class="main">1</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> valid<span class="main">[</span><span class="operator">OF</span> UHUE<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
  <span class="keyword1"><span class="command">}</span></span>    
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.incoming_def<span class="main">)</span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span>    
    <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> l'_def relabel_effect_def cf.adjacent_def 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.incoming_def cf.outgoing_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
      
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Neighbor Lists›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For each node, the algorithm will cycle through the adjacent edges 
  when discharging. This cycling takes place across the boundaries of
  discharge operations, i.e.\ when a node is discharged, discharging will 
  start at the edge where the last discharge operation stopped.

  The crucial invariant for the neighbor lists is that already visited 
  edges are not admissible.

  Formally, we maintain a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n :: node ⇒ node set›</span></span></span></span> from 
  each node to the set of target nodes of not yet visited edges.
›</span></span>
  
<span class="keyword1"><span class="command">locale</span></span> neighbor_invar <span class="main">=</span> Height_Bounded_Labeling <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node set"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> neighbors_adm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v</span> <span class="main">∈</span> adjacent_nodes <span class="free">u</span> <span class="main">-</span> <span class="free">n</span> <span class="free">u</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∉</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> neighbors_adj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="free">u</span> <span class="main">⊆</span> adjacent_nodes <span class="free">u</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> neighbors_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">n</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1" id="Relabel_To_Front-nbr_is_hbl"><span class="command">lemma</span></span> nbr_is_hbl<span class="main">:</span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1" id="Relabel_To_Front-push_pres_nbr_invar"><span class="command">lemma</span></span> push_pres_nbr_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>push_effect <span class="free">f</span> <span class="free">e</span><span class="main">)</span> <span class="free">l</span> <span class="free">n</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Pair <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">interpret</span></span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> push_pres_height_bound<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
    <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f'</span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">.</span></span>
  
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> f' <span class="free">l</span> <span class="free">n</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">using</span></span> push_adm_edges<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> neighbors_adm neighbors_adj
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword1" id="Relabel_To_Front-relabel_pres_nbr_invar"><span class="command">lemma</span></span> relabel_pres_nbr_invar<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span><span class="main">(</span><span class="free">u</span><span class="main">:=</span>adjacent_nodes <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> relabel_pres_height_bound<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
  <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> neighbors_adj
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">≠</span><span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>adjacent_nodes <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∉</span> <span class="free">n</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span>adm_edges <span class="free">f</span> <span class="var">?l'</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> A relabel_adm_edges<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> neighbors_adm
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="comment1">(* TODO: Clean up this mess *)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> DiffD2 Diff_triv adm_edges_def cf.incoming_def 
          mem_Collect_eq prod.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> relabel_preserve_other<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="Relabel_To_Front-excess_nz_iff_gz"><span class="command">lemma</span></span> excess_nz_iff_gz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">u</span><span class="main">∈</span>V<span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟷</span> excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> excess_non_negative' <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  
<span class="keyword1" id="Relabel_To_Front-no_neighbors_relabel_precond"><span class="command">lemma</span></span> no_neighbors_relabel_precond<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="free">u</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms neighbors_adm cfE_ss_invE 
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def adm_edges_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> adjacent_nodes_def excess_nz_iff_gz<span class="main">)</span>
  
<span class="keyword1" id="Relabel_To_Front-remove_neighbor_pres_nbr_invar"><span class="command">lemma</span></span> remove_neighbor_pres_nbr_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>adm_edges <span class="free">f</span> <span class="free">l</span> 
  <span class="main">⟹</span> neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">n</span> <span class="main">(</span><span class="free">u</span> <span class="main">:=</span> <span class="free">n</span> <span class="free">u</span> <span class="main">-</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">using</span></span> neighbors_adm neighbors_adj
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    
<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Discharge Operation›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The discharge operation performs push and relabel operations on a 
  node until it becomes inactive.
  The lemmas in this section are based on the ideas described in
 the proof of \cormen{26.29}.
›</span></span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">discharge</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>  
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">.</span> excess <span class="bound">f</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">v</span> <span class="main">←</span> <span class="keyword1">select</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">v</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">l</span> <span class="main">←</span> relabel <span class="bound">f</span> <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> adjacent_nodes <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">v</span><span class="main">∈</span>V <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="bound">f</span> <span class="main">∧</span> <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="bound">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">f</span> <span class="main">←</span> push <span class="bound">f</span> <span class="bound">l</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∉</span> adm_edges <span class="bound">f</span> <span class="bound">l</span> <span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">(</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">)</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">}</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Invariant for the discharge loop›</span></span>  
<span class="keyword1"><span class="command">locale</span></span> discharge_invar <span class="main">=</span> 
        neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">n</span></span> 
  <span class="main">+</span> lo<span class="main">:</span> neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">fo</span></span> <span class="quoted"><span class="free">lo</span></span> <span class="quoted"><span class="free">no</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">u</span> <span class="main">::</span> <span class="quoted">node</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fo</span> <span class="free">lo</span> <span class="free">no</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lu_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lo</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> u_node<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> no_relabel_adm_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lo</span> <span class="free">u</span> <span class="main">=</span> <span class="free">l</span> <span class="free">u</span> <span class="main">⟹</span> adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">⊆</span> adm_edges <span class="free">fo</span> <span class="free">lo</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_relabel_excess<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">lo</span> <span class="free">u</span> <span class="main">=</span> <span class="free">l</span> <span class="free">u</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span><span class="main">;</span> excess <span class="free">fo</span> <span class="free">v</span> <span class="main">≠</span> excess <span class="free">f</span> <span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>adm_edges <span class="free">fo</span> <span class="free">lo</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> adm_edges_leaving_u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> adm_edges <span class="free">fo</span> <span class="free">lo</span> <span class="main">⟹</span> <span class="free">u'</span><span class="main">=</span><span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> relabel_u_no_incoming_adm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lo</span> <span class="free">u</span> <span class="main">≠</span> <span class="free">l</span> <span class="free">u</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> algo_rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">fo</span><span class="main">,</span><span class="free">lo</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> pr_algo_rel<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Relabel_To_Front-u_node_simp1"><span class="command">lemma</span></span> u_node_simp1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≠</span><span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">≠</span><span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> u_node <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="Relabel_To_Front-u_node_simp2"><span class="command">lemma</span></span> u_node_simp2<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">using</span></span> u_node <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>   
  
<span class="keyword1" id="Relabel_To_Front-dis_is_lbl"><span class="command">lemma</span></span> dis_is_lbl<span class="main">:</span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1" id="Relabel_To_Front-dis_is_hbl"><span class="command">lemma</span></span> dis_is_hbl<span class="main">:</span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1" id="Relabel_To_Front-dis_is_nbr"><span class="command">lemma</span></span> dis_is_nbr<span class="main">:</span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
<span class="keyword1" id="Relabel_To_Front-new_adm_imp_relabel"><span class="command">lemma</span></span> new_adm_imp_relabel<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>adm_edges <span class="free">f</span> <span class="free">l</span> <span class="main">-</span> adm_edges <span class="free">fo</span> <span class="free">lo</span> <span class="main">⟹</span> <span class="free">lo</span> <span class="free">u</span> <span class="main">≠</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> no_relabel_adm_edges adm_edges_leaving_u <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1" id="Relabel_To_Front-push_pres_dis_invar"><span class="command">lemma</span></span> push_pres_dis_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">fo</span> <span class="free">lo</span> <span class="free">no</span> <span class="main">(</span>push_effect <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">interpret</span></span> push_effect_locale <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
  <span class="keyword1"><span class="command">from</span></span> push_pres_nbr_invar<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> <span class="keyword1"><span class="command">interpret</span></span> neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f'</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">n</span></span> <span class="keyword1"><span class="command">.</span></span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">fo</span> <span class="free">lo</span> <span class="free">no</span> f' <span class="free">l</span> <span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> lu_incr <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> no_relabel_adm_edges push_adm_edges<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v' <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">assume</span></span> LOU<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lo</span> <span class="free">u</span> <span class="main">=</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> EXNE<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">fo</span> <span class="skolem">v'</span> <span class="main">≠</span> excess f' <span class="skolem">v'</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> UNV'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="skolem">v'</span>"</span></span>  
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">fo</span> <span class="skolem">v'</span> <span class="main">≠</span> excess <span class="free">f</span> <span class="skolem">v'</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> no_relabel_excess<span class="main">[</span><span class="operator">OF</span> LOU UNV' this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">fo</span> <span class="skolem">v'</span> <span class="main">=</span> excess <span class="free">f</span> <span class="skolem">v'</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> EXNE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="skolem">v'</span> <span class="main">≠</span> excess f' <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> UNV' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess'_if <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> no_relabel_adm_edges<span class="main">[</span><span class="operator">OF</span> LOU<span class="main">]</span> uv_adm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Diff_iff push_adm_edges<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> PRE<span class="main"><span class="main">]</span></span> adm_edges_leaving_u subsetCE<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> push_adm_edges<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> relabel_u_no_incoming_adm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> converse_rtrancl_into_rtrancl<span class="main">[</span>
              <span class="operator">OF</span> pr_algo_rel.push<span class="main"><span class="main">[</span></span><span class="operator">OF</span> dis_is_hbl PRE<span class="main"><span class="main">]</span></span> algo_rel<span class="main">]</span> 
      <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
      
<span class="keyword1" id="Relabel_To_Front-relabel_pres_dis_invar"><span class="command">lemma</span></span> relabel_pres_dis_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">fo</span> <span class="free">lo</span> <span class="free">no</span> <span class="free">f</span> 
            <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span><span class="main">(</span><span class="free">u</span> <span class="main">:=</span> adjacent_nodes <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">n</span><span class="main">(</span><span class="free">u</span> <span class="main">:=</span> adjacent_nodes <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">from</span></span> relabel_pres_nbr_invar<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
  <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?l'</span></span></span> <span class="var"><span class="quoted"><span class="var">?n'</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    
  <span class="keyword1"><span class="command">note</span></span> lu_incr 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> relabel_increase_u<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> INCR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lo</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="var">?l'</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> INCR  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u' v 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarsimp</span>
      <span class="keyword3"><span class="command">assume</span></span> IN'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> adm_edges <span class="free">f</span> <span class="var">?l'</span>"</span></span> 
         <span class="keyword2"><span class="keyword">and</span></span> NOT_INO<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> adm_edges <span class="free">fo</span> <span class="free">lo</span>"</span></span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> IN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> adm_edges_leaving_u NOT_INO <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">=</span><span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> NOT_IN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> IN' relabel_adm_edges<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">=</span><span class="free">u</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> cf.incoming_def cf.outgoing_def cf.adjacent_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> relabel_adm_edges<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
      <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def cf.incoming_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> converse_rtrancl_into_rtrancl<span class="main">[</span>
              <span class="operator">OF</span> pr_algo_rel.relabel<span class="main"><span class="main">[</span></span><span class="operator">OF</span> dis_is_hbl PRE<span class="main"><span class="main">]</span></span> algo_rel<span class="main">]</span> 
      <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>                                                    

<span class="keyword1" id="Relabel_To_Front-push_precondI_nz"><span class="command">lemma</span></span> push_precondI_nz<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>excess <span class="free">f</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">0</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span><span class="main">;</span> <span class="free">l</span> <span class="free">u</span> <span class="main">=</span> <span class="free">l</span> <span class="free">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">⟧</span> <span class="main">⟹</span> push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> excess_nz_iff_gz<span class="main">)</span>
  
  
<span class="keyword1" id="Relabel_To_Front-remove_neighbor_pres_dis_invar"><span class="command">lemma</span></span> remove_neighbor_pres_dis_invar<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>adm_edges <span class="free">f</span> <span class="free">l</span>"</span></span>  
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">n'</span> <span class="main">≡</span> <span class="free">n</span> <span class="main">(</span><span class="free">u</span> <span class="main">:=</span> <span class="free">n</span> <span class="free">u</span> <span class="main">-</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">fo</span> <span class="free">lo</span> <span class="free">no</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> remove_neighbor_pres_nbr_invar<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span> 
  <span class="keyword1"><span class="command">interpret</span></span> neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">n'</span></span> <span class="keyword1"><span class="command">unfolding</span></span> n'_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> lu_incr no_relabel_adm_edges no_relabel_excess adm_edges_leaving_u 
      relabel_u_no_incoming_adm algo_rel
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
<span class="keyword1"><span class="command">qed</span></span>  
    
<span class="keyword1" id="Relabel_To_Front-neighbors_in_V"><span class="command">lemma</span></span> neighbors_in_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">n</span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span>V"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> neighbors_adj<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> E_ss_VxV <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Relabel_To_Front-neighbors_in_E"><span class="command">lemma</span></span> neighbors_in_E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">n</span> <span class="free">u</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> neighbors_adj<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> E_ss_VxV <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    
<span class="keyword1" id="Relabel_To_Front-relabeled_node_has_outgoing"><span class="command">lemma</span></span> relabeled_node_has_outgoing<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def  
  <span class="keyword1"><span class="command">using</span></span> active_has_cf_outgoing <span class="keyword1"><span class="command">unfolding</span></span> cf.outgoing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  
<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> neighbor_invar<span class="main">)</span> discharge_invar_init<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>  
  
  
<span class="keyword1"><span class="command">context</span></span> Network <span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The discharge operation preserves the invariant, and discharges the node.
›</span></span>  
<span class="keyword1" id="Relabel_To_Front-discharge_correct"><span class="command">lemma</span></span> discharge_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DINV<span class="main">:</span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> NOT_ST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"discharge <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="free">u</span> 
    <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">,</span><span class="bound">n'</span><span class="main">)</span><span class="main">.</span> discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="bound">f'</span> <span class="bound">l'</span> <span class="bound">n'</span> 
                       <span class="main">∧</span> excess <span class="bound">f'</span> <span class="free">u</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> discharge_def push_def relabel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
            I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">,</span><span class="bound">n'</span><span class="main">)</span><span class="main">.</span> discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">u</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="bound">f'</span> <span class="bound">l'</span> <span class="bound">n'</span>"</span></span>
        <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>pr_algo_rel <span class="keyword1">&lt;*lex*&gt;</span> finite_psubset<span class="main">)</span> 
                <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">,</span><span class="bound">n'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span><span class="main">,</span><span class="bound">n'</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> wf_lex_prod DINV 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> neighbor_invar.discharge_invar_init<span class="main"><span class="main">[</span></span><span class="operator">OF</span> DINV<span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> neighbor_invar.no_neighbors_relabel_precond 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.relabel_pres_dis_invar 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.push_pres_dis_invar
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.push_precondI_nz pr_algo_rel.relabel 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> pr_algo_rel.push<span class="main"><span class="main">[</span></span><span class="operator">OF</span> discharge_invar.dis_is_hbl<span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.remove_neighbor_pres_dis_invar
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.neighbors_in_V
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.relabeled_node_has_outgoing
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.dis_is_hbl 
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> discharge_invar.dis_is_nbr 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> discharge_invar.dis_is_lbl
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NOT_ST 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neighbor_invar.neighbors_finite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> discharge_invar.dis_is_nbr<span class="main"><span class="main">]</span></span> UIV<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> discharge_invar.neighbors_in_E<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Main Algorithm›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We state the main algorithm and prove its 
  termination and correctness›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Initially, all edges are unprocessed. ›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rtf_init_n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> <span class="keyword1">then</span> adjacent_nodes <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">else</span> <span class="main">{}</span>"</span></span>

<span class="keyword1" id="Relabel_To_Front-rtf_init_n_finite"><span class="command">lemma</span></span> rtf_init_n_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>rtf_init_n <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rtf_init_n_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
<span class="keyword1" id="Relabel_To_Front-init_no_adm_edges"><span class="command">lemma</span></span> init_no_adm_edges<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"adm_edges pp_init_f pp_init_l <span class="main">=</span> <span class="main">{}</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> adm_edges_def pp_init_l_def
  <span class="keyword1"><span class="command">using</span></span> card_V_ge2  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  

<span class="keyword1" id="Relabel_To_Front-rtf_init_neighbor_invar"><span class="command">lemma</span></span> rtf_init_neighbor_invar<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> pp_init_f pp_init_l rtf_init_n"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> pp_init_height_bound 
  <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">pp_init_f</span> <span class="quoted">pp_init_l</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rtf_init_n <span class="skolem">u</span> <span class="main">⊆</span> adjacent_nodes <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtf_init_n_def<span class="main">)</span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel_to_front</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> pp_init_f<span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> pp_init_l<span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> rtf_init_n<span class="main">;</span>

  <span class="keyword1">let</span> <span class="bound">L_left</span><span class="main">=</span><span class="main">[]</span><span class="main">;</span>
  <span class="bound">L_right</span> <span class="main">←</span> <span class="keyword1">spec</span> <span class="bound">l</span><span class="main">.</span> distinct <span class="bound">l</span> <span class="main">∧</span> set <span class="bound">l</span> <span class="main">=</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">.</span> <span class="bound">L_right</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="bound">L_right</span><span class="main">;</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">u</span> <span class="main">∈</span> V<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">old_lu</span> <span class="main">=</span> <span class="bound">l</span> <span class="bound">u</span><span class="main">;</span>
  
      <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span> <span class="main">←</span> discharge <span class="bound">f</span> <span class="bound">l</span> <span class="bound">n</span> <span class="bound">u</span><span class="main">;</span>
  
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">l</span> <span class="bound">u</span> <span class="main">≠</span> <span class="bound">old_lu</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="comment1">― ‹Move <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>u›</span></span> to front of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>l›</span></span>, and restart scanning <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>L›</span></span>›</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="bound">u</span><span class="main">]</span><span class="main">,</span><span class="bound">L_left</span> <span class="main">@</span> tl <span class="bound">L_right</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="comment1">― ‹Goto next node in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>l›</span></span>›</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">L_left</span><span class="main">@</span><span class="main">[</span><span class="bound">u</span><span class="main">]</span><span class="main">,</span> tl <span class="bound">L_right</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span>
      <span class="main">}</span>
  
    <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span>neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span> <span class="bound">n</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">return</span> <span class="bound">f</span>
<span class="main">}</span>"</span></span>
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Invariant for the main algorithm:
  <span class="antiquoted"><span class="antiquoted">▸</span></span> Nodes in the queue left of the current node are not active
  <span class="antiquoted"><span class="antiquoted">▸</span></span> The queue is a topological sort of the admissible network
  <span class="antiquoted"><span class="antiquoted">▸</span></span> All nodes except source and sink are on the queue
›</span></span>    
    
<span class="keyword1"><span class="command">locale</span></span> rtf_invar <span class="main">=</span> neighbor_invar <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">L_left</span> <span class="free">L_right</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node list"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> left_no_excess<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>set <span class="main">(</span><span class="free">L_left</span><span class="main">)</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">0</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> L_sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="main">(</span>adm_edges <span class="free">f</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">L_left</span> <span class="main">@</span> <span class="free">L_right</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> L_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">L_left</span> <span class="main">∪</span> set <span class="free">L_right</span> <span class="main">=</span> V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>  
<span class="keyword2"><span class="keyword">begin</span></span>    
  <span class="keyword1" id="Relabel_To_Front-rtf_is_nbr"><span class="command">lemma</span></span> rtf_is_nbr<span class="main">:</span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
      
  <span class="keyword1" id="Relabel_To_Front-L_distinct"><span class="command">lemma</span></span> L_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span><span class="free">L_left</span> <span class="main">@</span> <span class="free">L_right</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> is_top_sorted_distinct<span class="main">[</span><span class="operator">OF</span> L_sorted<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1" id="Relabel_To_Front-terminated_imp_maxflow"><span class="command">lemma</span></span> terminated_imp_maxflow<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L_right</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>   
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> L_set left_no_excess <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> no_excess_imp_maxflow <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>    
  <span class="keyword1"><span class="command">qed</span></span>        
      
      
<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword1"><span class="command">context</span></span> Network <span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1" id="Relabel_To_Front-rtf_init_invar"><span class="command">lemma</span></span> rtf_init_invar<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> DIS<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">L_left</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">L_left</span> <span class="main">=</span> V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rtf_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> pp_init_f pp_init_l rtf_init_n <span class="main">[]</span> <span class="free">L_left</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> rtf_init_neighbor_invar 
  <span class="keyword1"><span class="command">interpret</span></span> neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">pp_init_f</span> <span class="quoted">pp_init_l</span> <span class="quoted">rtf_init_n</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> DIS L_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>  
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">theorem</span></span> relabel_to_front_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"relabel_to_front <span class="main">≤</span> SPEC isMaxFlow"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_to_front_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span>"</span></span></span> vcg_intro_frame<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span>  
      WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
            I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">.</span> rtf_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span> <span class="bound">n</span> <span class="bound">L_left</span> <span class="bound">L_right</span>"</span></span>
        <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image 
                <span class="main">(</span>pr_algo_rel<span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="keyword1">&lt;*lex*&gt;</span> less_than<span class="main">)</span> 
                <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">,</span>length <span class="bound">L_right</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtf_init_invar rtf_invar.rtf_is_nbr<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> wf_lex_prod wf_trancl<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> _ f l n L_left L_right <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rtf_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">n</span> <span class="skolem">L_left</span> <span class="skolem">L_right</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> rtf_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">L_left</span></span> <span class="quoted"><span class="skolem">L_right</span></span> <span class="keyword1"><span class="command">.</span></span>
        
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">L_right</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">L_right'</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">L_right</span> <span class="main">=</span> <span class="skolem">u</span><span class="main">#</span><span class="skolem">L_right'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">L_right</span></span><span class="main">)</span> <span class="operator">auto</span>
        
    <span class="keyword1"><span class="command">from</span></span> L_set <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≠</span><span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">≠</span><span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        
    <span class="keyword1"><span class="command">from</span></span> L_distinct <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>set <span class="skolem">L_left</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>set <span class="skolem">L_right'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_rem_frame<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">do</span></span> <span class="main"><span class="main">{</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">,</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">,</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">←</span></span> discharge <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">;</span></span> <span class="main"><span class="main">⌑</span></span><span class="main"><span class="main">}</span></span>"</span></span></span> vcg_intro_frame<span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtf_is_nbr <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f' l' n' <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"discharge_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">u</span> <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">n</span> <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="skolem">n'</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> discharge_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="skolem">l'</span></span> <span class="quoted"><span class="skolem">n'</span></span> <span class="keyword1"><span class="command">.</span></span>
      
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_rem_frame<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword3"><span class="command">assume</span></span> RELABEL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">≠</span> <span class="skolem">l</span> <span class="skolem">u</span>"</span></span>
              
            <span class="keyword1"><span class="command">have</span></span> AUX1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">=</span><span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>adm_edges <span class="skolem">f'</span> <span class="skolem">l'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
              <span class="keyword1"><span class="command">using</span></span> that l'.relabel_u_no_incoming_adm<span class="main">[</span><span class="operator">OF</span> RELABEL<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclE<span class="main">)</span>
              
            <span class="keyword1"><span class="command">have</span></span> TS1<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="main">(</span>adm_edges <span class="skolem">f</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">(</span><span class="skolem">L_left</span> <span class="main">@</span> <span class="skolem">L_right'</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> L_sorted <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> is_top_sorted_remove_elem<span class="main">)</span>

            <span class="comment1">― ‹Intuition:›</span>
              <span class="comment1">― ‹new edges come from <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>u›</span></span>, but <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>u›</span></span> has no incoming edges, nor is it in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>L_left@L_right'›</span></span>.›</span>
              <span class="comment1">― ‹thus, these new edges cannot add effective constraints.›</span>
            <span class="keyword1"><span class="command">from</span></span> l'.adm_edges_leaving_u 
              <span class="keyword2"><span class="keyword">and</span></span> l'.relabel_u_no_incoming_adm<span class="main">[</span><span class="operator">OF</span> RELABEL<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="main">⊆</span> adm_edges <span class="skolem">f</span> <span class="skolem">l</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">×</span>UNIV"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"adm_edges <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="main">∩</span> UNIV<span class="main">×</span><span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">=</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> is_top_sorted_isolated_constraint<span class="main">[</span><span class="operator">OF</span> this _ TS1<span class="main">]</span>    
            <span class="keyword1"><span class="command">have</span></span> AUX2<span class="main">:</span> <span class="quoted"><span class="quoted">"is_top_sorted <span class="main">(</span>adm_edges <span class="skolem">f'</span> <span class="skolem">l'</span><span class="main">)</span> <span class="main">(</span><span class="skolem">L_left</span> <span class="main">@</span> <span class="skolem">L_right'</span><span class="main">)</span>"</span></span> 
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>   
                
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rtf_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="skolem">n'</span> <span class="main">[</span><span class="skolem">u</span><span class="main">]</span> <span class="main">(</span><span class="skolem">L_left</span> <span class="main">@</span> <span class="skolem">L_right'</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> AUX2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_top_sorted_cons <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> AUX1<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> L_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
          <span class="keyword1"><span class="command">qed</span></span>  
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> l'.algo_rel <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtranclD<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword3"><span class="command">assume</span></span> NO_RELABEL<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l'</span> <span class="skolem">u</span> <span class="main">=</span> <span class="skolem">l</span> <span class="skolem">u</span>"</span></span>
            <span class="comment1">― ‹Intuition: non-zero excess would imply an admissible edge contrary to <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>top_sorted›</span></span>.›</span>
            <span class="keyword1"><span class="command">have</span></span> AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>set <span class="skolem">L_left</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
              <span class="keyword1"><span class="command">from</span></span> that <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∉</span>set <span class="skolem">L_left</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f'</span> <span class="skolem">v</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> that left_no_excess <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"excess <span class="skolem">f</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>adm_edges <span class="skolem">f</span> <span class="skolem">l</span>"</span></span>    
                <span class="keyword1"><span class="command">using</span></span> l'.no_relabel_excess<span class="main">[</span><span class="operator">OF</span> NO_RELABEL<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              
              <span class="keyword1"><span class="command">with</span></span> L_sorted that <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_top_sorted_append is_top_sorted_cons<span class="main">)</span>
            <span class="keyword1"><span class="command">qed</span></span>      
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rtf_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f'</span> <span class="skolem">l'</span> <span class="skolem">n'</span> <span class="main">(</span><span class="skolem">L_left</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">u</span><span class="main">]</span><span class="main">)</span> <span class="skolem">L_right'</span>"</span></span>  
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> AUX<span class="main">)</span>  
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> is_top_sorted_antimono<span class="main"><span class="main">[</span></span>
                  <span class="operator">OF</span> l'.no_relabel_adm_edges<span class="main"><span class="main">[</span></span><span class="operator">OF</span> NO_RELABEL<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
                <span class="keyword1"><span class="command">using</span></span> L_sorted <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> L_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> l'.algo_rel <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtranclD<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtf_invar.terminated_imp_maxflow<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Prpu_Common_Impl">
<div class="head">
<h1>Theory Prpu_Common_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tools for Implementing Push-Relabel Algorithms›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Prpu_Common_Impl
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Prpu_Common_Inst">Prpu_Common_Inst</a>
  <a href="../../flow_networks/theories/#Network_Impl">Flow_Networks.Network_Impl</a> 
  <a href="../../flow_networks/theories/#NetCheck">Flow_Networks.NetCheck</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Operations›</span></span>
  
<span class="keyword1"><span class="command">type_synonym</span></span> excess_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> capacity_impl"</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl 
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Excess Map›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obtain an excess map with all nodes mapped to zero.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">x_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"excess_impl nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x_init</span> <span class="main">≡</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Get the excess of a node.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">x_get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"excess_impl <span class="main">⇒</span> node <span class="main">⇒</span> capacity_impl nres"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x_get</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Add a capacity to the excess of a node.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">x_add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"excess_impl <span class="main">⇒</span> node <span class="main">⇒</span> capacity_impl <span class="main">⇒</span> excess_impl nres"</span></span>  
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x_add</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">Δ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">Δ</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Labeling›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obtain the initial labeling: All nodes are zero, except the 
  source which is labeled by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>|V|›</span></span></span></span>. The exact cardinality of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>V›</span></span></span></span> is passed
  as a parameter.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span>node <span class="main">⇒</span> nat<span class="main">)</span> nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">l_init</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">(</span><span class="free">s</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Get the label of a node.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> nat nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">l_get</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∈</span> V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Set the label of a node.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>node <span class="main">⇒</span> nat<span class="main">)</span> nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">l_set</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span>card V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Label Frequency Counts for Gap Heuristics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obtain the frequency counts for the initial labeling.
  Again, the cardinality of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>|V|›</span></span></span></span>, which is required to determine the label
  of the source node, is passed as an explicit parameter.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cnt_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cnt_init</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">&lt;</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">(</span><span class="main">0</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">:=</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Get the count for a label value.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cnt_get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> nat nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cnt_get</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Increment the count for a label value by one.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cnt_incr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cnt_incr</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="main">(</span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">+</span> <span class="main">1</span> <span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Decrement the count for a label value by one.›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cnt_decr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cnt_decr</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="main">(</span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span> <span class="free"><span class="bound"><span class="entity">lv</span></span></span> <span class="main">-</span> <span class="main">1</span> <span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>  

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinements to Basic Operations›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl 
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we refine the algorithm to actually use the 
 basic operations.
›</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Explicit Computation of the Excess›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">xf_rel</span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="main">(</span>excess <span class="bound">f</span><span class="main">,</span>cf_of <span class="bound">f</span><span class="main">)</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f</span><span class="main">.</span> True <span class="main">}</span>"</span></span>
<span class="keyword1" id="Prpu_Common_Impl-xf_rel_RELATES"><span class="command">lemma</span></span> xf_rel_RELATES<span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES xf_rel"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_x</span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">u</span><span class="main">=</span><span class="free">s</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">∑</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>outgoing <span class="free">s</span><span class="main">.</span> <span class="main">-</span> <span class="free">c</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  
<span class="keyword1" id="Prpu_Common_Impl-excess_pp_init_f"><span class="command">lemma</span></span> excess_pp_init_f<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"excess pp_init_f <span class="main">=</span> pp_init_x"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u  
    <span class="keyword1"><span class="command">unfolding</span></span> excess_def pp_init_f_def pp_init_x_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">=</span><span class="free">s</span>"</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> outgoing_def incoming_def    
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sum.cong <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_negf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="skolem">e</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">u</span> <span class="main">=</span> <span class="free">s</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>outgoing <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">e</span>
        <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="skolem">e</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">u</span> <span class="main">=</span> <span class="free">s</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> 
        <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>incoming <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">e</span>
        <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.delta<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> incoming_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_cf</span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">v</span><span class="main">=</span><span class="free">s</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">u</span><span class="main">=</span><span class="free">s</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1" id="Prpu_Common_Impl-cf_of_pp_init_f"><span class="command">lemma</span></span> cf_of_pp_init_f<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cf_of pp_init_f <span class="main">=</span> pp_init_cf"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>  
  <span class="keyword1"><span class="command">unfolding</span></span> pp_init_cf_def pp_init_f_def residualGraph_def
  <span class="keyword1"><span class="command">using</span></span> no_parallel_edge  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    
  
<span class="keyword1" id="Prpu_Common_Impl-pp_init_x_rel"><span class="command">lemma</span></span> pp_init_x_rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>pp_init_x<span class="main">,</span> pp_init_cf<span class="main">)</span><span class="main">,</span> pp_init_f<span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> xf_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Algorithm to Compute Initial Excess and Flow›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_xcf2_aux</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">x</span><span class="main">=</span><span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">cf</span><span class="main">=</span><span class="free">c</span><span class="main">;</span>

  <span class="keyword1">foreach</span> <span class="main">(</span>adjacent_nodes <span class="free">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free">s</span> <span class="main">≠</span> <span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">x</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span><span class="main">(</span> <span class="free">s</span> <span class="main">:=</span> <span class="bound">x</span> <span class="free">s</span> <span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="bound">v</span> <span class="main">:=</span> <span class="bound">a</span> <span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">cf</span> <span class="main">=</span> <span class="bound">cf</span><span class="main">(</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">:=</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">a</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1" id="Prpu_Common_Impl-pp_init_xcf2_aux_spec"><span class="command">lemma</span></span> pp_init_xcf2_aux_spec<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pp_init_xcf2_aux <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">=</span>pp_init_x <span class="main">∧</span> <span class="bound">cf</span> <span class="main">=</span> pp_init_cf<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> ADJ_S_AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"adjacent_nodes <span class="free">s</span> <span class="main">=</span> <span class="main">{</span><span class="bound">v</span> <span class="main">.</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">using</span></span> no_incoming_s <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  <span class="keyword1"><span class="command">have</span></span> CSU_AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>adjacent_nodes <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pp_init_xcf2_aux_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> FOREACH_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> 
        <span class="bound">x</span> <span class="free">s</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>adjacent_nodes <span class="free">s</span> <span class="main">-</span> <span class="bound">it</span><span class="main">.</span> <span class="main">-</span> <span class="free">c</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>adjacent_nodes <span class="free">s</span><span class="main">.</span> <span class="bound">x</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">it</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="main">-</span>insert <span class="free">s</span> <span class="main">(</span>adjacent_nodes <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>adjacent_nodes <span class="free">s</span><span class="main">.</span> 
            <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∉</span><span class="bound">it</span> <span class="keyword1">then</span> <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> 
            <span class="keyword1">else</span> <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">u</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">≠</span><span class="free">s</span> <span class="main">⟶</span> <span class="bound">cf</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span><span class="main">∉</span>adjacent_nodes <span class="free">s</span> <span class="main">⟶</span> <span class="bound">cf</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
    "</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CSU_AUX<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v it <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ADJ_S_AUX<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u it _ v <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ADJ_S_AUX<span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ADJ_S_AUX<span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>    
    <span class="comment1">(* TODO: This proof is still a bit fragile *)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x
      <span class="keyword1"><span class="command">unfolding</span></span> pp_init_x_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ADJ_S_AUX outgoing_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum.reindex_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> l<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">snd</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Compl_iff Graph.zero_cap_simp insertE mem_Collect_eq<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x cf    
      <span class="keyword1"><span class="command">unfolding</span></span> pp_init_cf_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CSU_AUX<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>      
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_xcf2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">x</span> <span class="main">←</span> x_init<span class="main">;</span>
  <span class="bound">cf</span> <span class="main">←</span> cf_init<span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span><span class="free">s</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
  <span class="bound">adj</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
  nfoldli <span class="bound">adj</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free">s</span> <span class="main">≠</span> <span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">a</span> <span class="main">←</span> cf_get <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">x</span> <span class="main">←</span> x_add <span class="bound">x</span> <span class="free">s</span> <span class="main">(</span><span class="main">-</span><span class="bound">a</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">x</span> <span class="main">←</span> x_add <span class="bound">x</span> <span class="bound">v</span> <span class="bound">a</span><span class="main">;</span>
    <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">0</span><span class="main">;</span> 
    <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> <span class="bound">a</span><span class="main">;</span> 
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
  
  
<span class="keyword1" id="Prpu_Common_Impl-pp_init_xcf2_refine_aux"><span class="command">lemma</span></span> pp_init_xcf2_refine_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pp_init_xcf2 <span class="free">am</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>pp_init_xcf2_aux<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pp_init_xcf2_def pp_init_xcf2_aux_def
  <span class="keyword1"><span class="command">unfolding</span></span> x_init_def cf_init_def am_get_def cf_get_def cf_set_def x_add_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> LFO_refine<span class="main">[</span><span class="operator">OF</span> am_to_adj_nodes_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">refine</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>  
  <span class="keyword1"><span class="command">using</span></span> E_ss_VxV  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  
<span class="keyword1" id="Prpu_Common_Impl-pp_init_xcf2_refine"><span class="command">lemma</span></span> pp_init_xcf2_refine<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pp_init_xcf2 <span class="free">am</span> <span class="main">≤</span><span class="main">⇓</span>xf_rel <span class="main">(</span>RETURN pp_init_f<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> pp_init_xcf2_refine_aux<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span> pp_init_xcf2_aux_spec pp_init_x_rel
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Computing the Minimal Adjacent Label›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">min_adj_label_aux</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> <span class="keyword1">foreach</span> <span class="main">(</span>adjacent_nodes <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> 
      <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">|</span> Some <span class="bound">xx</span> <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span>min <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="bound">xx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span>
      <span class="keyword1">return</span> <span class="bound">x</span>
  <span class="main">}</span><span class="main">)</span> None<span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">x</span><span class="main">≠</span>None<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span>the <span class="bound">x</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> set_filter_xform_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="main">(</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∨</span> <span class="bound">x</span><span class="main">∈</span><span class="free">S</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">∉</span><span class="free">it</span> <span class="main">)</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">}</span> 
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="main">{</span><span class="free">f</span> <span class="free">a</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="free">f</span> <span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">-</span><span class="free">it</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span>    
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Labeling<span class="main">)</span> min_adj_label_aux_spec<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min_adj_label_aux cf <span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> Min <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="keyword1"><span class="command">unfolding</span></span> cf.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cf.E <span class="main">}</span> 
    <span class="main">=</span> <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span>adjacent_nodes <span class="free">u</span> <span class="main">∧</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">≠</span><span class="main">0</span> <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> AUX
    <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> adjacent_nodes_def<span class="main">)</span>
  
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Min_option</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set <span class="main">⇀</span> nat"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Min_option</span> <span class="skolem">X</span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="skolem">X</span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>Min <span class="skolem">X</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">X</span>
      
  <span class="keyword1"><span class="command">from</span></span> PRE active_has_cf_outgoing <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf.outgoing <span class="free">u</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> relabel_precond_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.outgoing_def <span class="keyword1"><span class="command">using</span></span> cfE_of_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹cf.outgoing <span class="free">u</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> 
  <span class="keyword1"><span class="command">have</span></span> AUX2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> adjacent_nodes <span class="free">u</span> <span class="main">∧</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> AUX Collect_empty_eq Image_singleton_iff UnCI adjacent_nodes_def 
            cf.outgoing_def cf_def converse_iff prod.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> min_adj_label_aux_def EQ   
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> 
        FOREACH_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
          I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">Min_option</span> 
                          <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span>adjacent_nodes <span class="free">u</span> <span class="main">-</span> <span class="bound">it</span> <span class="main">∧</span> cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">≠</span><span class="main">0</span> <span class="main">}</span>"</span></span><span class="main"><span class="main">]</span></span>
        <span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Min_option_def it_step_insert_iff set_filter_xform_aux 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> adjacent_nodes_ss_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> adjacent_nodes_ss_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Min.insert_remove<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> AUX2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
<span class="keyword1"><span class="command">qed</span></span>        

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_adj_label</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
  <span class="bound">adj</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> nfoldli <span class="bound">adj</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span> E <span class="main">∪</span> E<span class="main">¯</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="bound">cfuv</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="bound">cfuv</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">lv</span> <span class="main">←</span> l_get <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span>Some <span class="bound">lv</span><span class="main">)</span> 
      <span class="main">|</span> Some <span class="bound">xx</span> <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span>min <span class="bound">lv</span> <span class="bound">xx</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">return</span> <span class="bound">x</span>
  <span class="main">}</span><span class="main">)</span> None<span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">x</span><span class="main">≠</span>None<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span>the <span class="bound">x</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="Prpu_Common_Impl-min_adj_label_refine"><span class="command">lemma</span></span> min_adj_label_refine<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"relabel_precond <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cf</span> <span class="main">=</span> cf_of <span class="free">f</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min_adj_label <span class="free">am</span> <span class="free">cf</span> <span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> 
        <span class="main">=</span> Min <span class="main">{</span> <span class="free">l</span> <span class="bound">v</span> <span class="main">|</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span> <span class="main">}</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
  <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_adj_label <span class="free">am</span> <span class="main">(</span>cf_of <span class="free">f</span><span class="main">)</span> <span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>min_adj_label_aux <span class="main">(</span>cf_of <span class="free">f</span><span class="main">)</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> min_adj_label_def min_adj_label_aux_def Let_def
    <span class="keyword1"><span class="command">unfolding</span></span> am_get_def cf_get_def l_get_def  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> LFO_refine<span class="main">[</span><span class="operator">OF</span> fun_relD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM IdI<span class="main"><span class="main">]</span></span> _ IdI<span class="main">,</span> <span class="operator">refine</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> min_adj_label_aux_spec<span class="main">[</span><span class="operator">OF</span> PRE<span class="main">]</span>    
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Relabel›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Utilities to Implement Relabel Operations›</span></span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">nl</span> <span class="main">←</span> min_adj_label <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> l_set <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="bound">nl</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">l</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1" id="Prpu_Common_Impl-relabel2_refine"><span class="command">lemma</span></span> relabel2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">li</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"relabel2 <span class="free">am</span> <span class="free">cf</span> <span class="free">li</span> <span class="free">ui</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>relabel <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>    
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">l</span> <span class="bound">v</span> <span class="main">|</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∈</span> V <span class="main">∧</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">l</span> <span class="bound">v</span> <span class="main">|</span><span class="bound">v</span><span class="main">.</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cfE_of_ss_VxV<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> relabel2_def relabel_def
    <span class="keyword1"><span class="command">unfolding</span></span> l_set_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> AM<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">nopre</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xf_rel_def relabel_effect_def <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> a <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>   
      <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="quoted">"relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> relabel_pres_height_bound<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> prems<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span> <span class="free">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relabel_effect_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> l'.height_bound<span class="main">[</span><span class="operator">THEN</span> bspec<span class="main">,</span> <span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>V›</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">+</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> card V"</span></span> <span class="keyword1"><span class="command">using</span></span> card_V_ge2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Push›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">push2_aux</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∪</span> E<span class="main">¯</span> <span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span> <span class="bound">u</span> <span class="main">≠</span> <span class="bound">v</span> <span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Δ</span> <span class="main">=</span> min <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">(</span> <span class="bound">u</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span> <span class="main">-</span> <span class="bound">Δ</span><span class="main">,</span> <span class="bound">v</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="bound">Δ</span> <span class="main">)</span><span class="main">,</span>augment_edge_cf <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">Δ</span><span class="main">)</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
  
<span class="keyword1" id="Prpu_Common_Impl-push2_aux_refine"><span class="command">lemma</span></span> push2_aux_refine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel<span class="main">;</span> <span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id<span class="main">⟧</span> 
    <span class="main">⟹</span> push2_aux <span class="free">x</span> <span class="free">cf</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">⇓</span>xf_rel <span class="main">(</span>push <span class="free">f</span> <span class="free">l</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> push_def push2_aux_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xf_rel_def no_self_loop<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u v 
    <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">using</span></span> cfE_of_ss_invE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u v 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> l'.excess'_if l'.Δ_def l'.cf'_alt l'.uv_not_eq<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>  
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">push2</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∪</span> E<span class="main">¯</span> <span class="main">)</span><span class="main">;</span>
  <span class="bound">xu</span> <span class="main">←</span> x_get <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span><span class="main">;</span>
  <span class="bound">cfuv</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">cfvu</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Δ</span> <span class="main">=</span> min <span class="bound">xu</span> <span class="bound">cfuv</span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> x_add <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span> <span class="main">(</span><span class="main">-</span><span class="bound">Δ</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> x_add <span class="bound">x</span> <span class="bound">v</span> <span class="bound">Δ</span><span class="main">;</span>

  <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="bound">cfuv</span> <span class="main">-</span> <span class="bound">Δ</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">(</span><span class="bound">cfvu</span> <span class="main">+</span> <span class="bound">Δ</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">return</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1" id="Prpu_Common_Impl-push2_refine"><span class="command">lemma</span></span> push2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"push2 <span class="free">x</span> <span class="free">cf</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">⇓</span>xf_rel <span class="main">(</span>push <span class="free">f</span> <span class="free">l</span> <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"push2 <span class="free">x</span> <span class="free">cf</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">(</span>push2_aux <span class="free">x</span> <span class="free">cf</span> <span class="free">ei</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> push2_def push2_aux_def
    <span class="keyword1"><span class="command">unfolding</span></span> x_get_def x_add_def cf_get_def cf_set_def
    <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_cf_def  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
    <span class="keyword1"><span class="command">using</span></span> E_ss_VxV  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> push2_aux_refine<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>    
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span> 
<span class="keyword1"><span class="command">qed</span></span>  
  
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Adding frequency counters to labeling›</span></span>
      
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">l_invar</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">v</span><span class="main">∈</span>V"</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> 
  <span class="main">(</span><span class="main">∀</span><span class="bound">lv</span><span class="main">.</span> <span class="bound">cnt</span> <span class="bound">lv</span> <span class="main">=</span> card <span class="main">{</span> <span class="bound"><span class="bound">u</span></span><span class="main">∈</span>V <span class="main">.</span> <span class="bound">l</span> <span class="bound">u</span> <span class="main">=</span> <span class="bound">lv</span> <span class="main">}</span><span class="main">)</span> 
<span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="bound">l</span> <span class="bound">u</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span> <span class="main">∧</span> l_invar <span class="bound">l</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_rel</span> <span class="main">≡</span> br snd clc_invar"</span></span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_init</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">l</span> <span class="main">←</span> l_init <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">;</span>
  <span class="bound">cnt</span> <span class="main">←</span> cnt_init <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_get</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="bound">u</span><span class="main">.</span> l_get <span class="bound">l</span> <span class="bound">u</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_set</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="bound">u</span> <span class="bound">a</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">a</span><span class="main">&lt;</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">lu</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="bound">u</span><span class="main">;</span>
  <span class="bound">cnt</span> <span class="main">←</span> cnt_decr <span class="bound">cnt</span> <span class="bound">lu</span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> l_set <span class="bound">l</span> <span class="bound">u</span> <span class="bound">a</span><span class="main">;</span>
  <span class="bound">lu</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="bound">u</span><span class="main">;</span>
  <span class="bound">cnt</span> <span class="main">←</span> cnt_incr <span class="bound">cnt</span> <span class="bound">lu</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span>
<span class="main">}</span>"</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_has_gap</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="bound">lu</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">nlu</span> <span class="main">←</span> cnt_get <span class="bound">cnt</span> <span class="bound">lu</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="bound">nlu</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1" id="Prpu_Common_Impl-cardV_le_N"><span class="command">lemma</span></span> cardV_le_N<span class="main">:</span> <span class="quoted"><span class="quoted">"card V <span class="main">≤</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_mono<span class="main">[</span><span class="operator">OF</span> _ V_ss<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="Prpu_Common_Impl-N_not_Z"><span class="command">lemma</span></span> N_not_Z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">N</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_V_ge2 cardV_le_N <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="Prpu_Common_Impl-N_ge_2"><span class="command">lemma</span></span> N_ge_2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span><span class="main">≤</span><span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_V_ge2 cardV_le_N <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1" id="Prpu_Common_Impl-clc_init_refine"><span class="command">lemma</span></span> clc_init_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ci</span><span class="main">,</span><span class="free">C</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> card V"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"clc_init <span class="free">Ci</span> <span class="main">≤</span><span class="main">⇓</span>clc_rel <span class="main">(</span>l_init <span class="free">C</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> AUX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≠</span> <span class="free">s</span> <span class="main">∧</span> <span class="bound">u</span> <span class="main">∈</span> V<span class="main">}</span> <span class="main">=</span> V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> clc_init_def l_init_def cnt_init_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
    <span class="keyword1"><span class="command">unfolding</span></span> clc_rel_def clc_invar_def
    <span class="keyword1"><span class="command">using</span></span> cardV_le_N N_not_Z
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv V_not_empty AUX l_invar_def<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="Prpu_Common_Impl-clc_get_refine"><span class="command">lemma</span></span> clc_get_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel<span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>nat_rel <span class="main">⟧</span> <span class="main">⟹</span> clc_get <span class="free">clc</span> <span class="free">ui</span> <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>l_get <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clc_get_def clc_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_get_rlx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> nat nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">l_get_rlx</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&lt;</span> <span class="free">N</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_get_rlx</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="bound">u</span><span class="main">.</span> l_get_rlx <span class="bound">l</span> <span class="bound">u</span>"</span></span>
  
<span class="keyword1" id="Prpu_Common_Impl-clc_get_rlx_refine"><span class="command">lemma</span></span> clc_get_rlx_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel<span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>nat_rel <span class="main">⟧</span> 
  <span class="main">⟹</span> clc_get_rlx <span class="free">clc</span> <span class="free">ui</span> <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>l_get_rlx <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clc_get_rlx_def clc_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>  
    
<span class="keyword1" id="Prpu_Common_Impl-card_insert_disjointI"><span class="command">lemma</span></span> card_insert_disjointI<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">Y</span><span class="main">;</span> <span class="free">X</span> <span class="main">=</span> insert <span class="free">x</span> <span class="free">Y</span><span class="main">;</span> <span class="free">x</span><span class="main">∉</span><span class="free">Y</span> <span class="main">⟧</span> <span class="main">⟹</span> card <span class="free">X</span> <span class="main">=</span> Suc <span class="main">(</span>card <span class="free">Y</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1" id="Prpu_Common_Impl-clc_set_refine"><span class="command">lemma</span></span> clc_set_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span> <span class="main">∈</span> clc_rel<span class="main">;</span> <span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">;</span> <span class="main">(</span><span class="free">ai</span><span class="main">,</span><span class="free">a</span><span class="main">)</span><span class="main">∈</span>nat_rel <span class="main">⟧</span> <span class="main">⟹</span>
    clc_set <span class="free">clc</span> <span class="free">ui</span> <span class="free">ai</span> <span class="main">≤</span><span class="main">⇓</span>clc_rel <span class="main">(</span>l_set <span class="free">l</span> <span class="free">u</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clc_set_def l_set_def l_get_def cnt_decr_def cnt_incr_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
  <span class="keyword1"><span class="command">unfolding</span></span> clc_rel_def in_br_conv clc_invar_def l_invar_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> cardV_le_N <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card_gt_0_iff<span class="main">)</span>
    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> cnt ll 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> impI conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> le_imp_diff_is_add<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> card_insert_disjointI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">u</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>     
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> card_insert_disjointI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">u</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">card</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    

<span class="keyword1" id="Prpu_Common_Impl-clc_has_gap_correct"><span class="command">lemma</span></span> clc_has_gap_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel<span class="main">;</span> <span class="free">k</span><span class="main">&lt;</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">⟧</span> 
  <span class="main">⟹</span> clc_has_gap <span class="free">clc</span> <span class="free">k</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">⟷</span> gap_precond <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clc_has_gap_def cnt_get_def gap_precond_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
  <span class="keyword1"><span class="command">unfolding</span></span> clc_rel_def clc_invar_def in_br_conv
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
  
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Gap-Heuristics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Utilities to Implement Gap-Heuristics›</span></span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_aux</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  nfoldli <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">]</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">l</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">lv</span> <span class="main">←</span> l_get_rlx <span class="bound">l</span> <span class="bound">v</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">&lt;</span> <span class="bound">lv</span> <span class="main">∧</span> <span class="bound">lv</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">+</span><span class="main">1</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">l</span> <span class="main">←</span> l_set <span class="bound">l</span> <span class="bound">v</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="bound">l</span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="bound">l</span>
  <span class="main">}</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1" id="Prpu_Common_Impl-gap_effect_invar"><span class="command">lemma</span></span> gap_effect_invar<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"l_invar <span class="free">l</span> <span class="main">⟹</span> l_invar <span class="main">(</span>gap_effect <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span>   
  <span class="keyword1"><span class="command">unfolding</span></span> gap_effect_def l_invar_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
<span class="keyword1" id="Prpu_Common_Impl-relabel_effect_invar"><span class="command">lemma</span></span> relabel_effect_invar<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>l_invar <span class="free">l</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span>V<span class="main">⟧</span> <span class="main">⟹</span> l_invar <span class="main">(</span>relabel_effect <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_effect_def l_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1" id="Prpu_Common_Impl-gap_aux_correct"><span class="command">lemma</span></span> gap_aux_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>l_invar <span class="free">l</span><span class="main">;</span> <span class="free">C</span><span class="main">=</span>card V<span class="main">⟧</span> <span class="main">⟹</span> gap_aux <span class="free">C</span> <span class="free">l</span> <span class="free">k</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span>gap_effect <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gap_aux_def l_get_rlx_def l_set_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it1</span> <span class="bound">it2</span> <span class="bound">l'</span><span class="main">.</span> <span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">u</span><span class="main">∈</span>set <span class="bound">it2</span> <span class="keyword1">then</span> <span class="bound">l'</span> <span class="bound">u</span> <span class="main">=</span> <span class="free">l</span> <span class="bound">u</span> <span class="keyword1">else</span> <span class="bound">l'</span> <span class="bound">u</span> <span class="main">=</span> gap_effect <span class="free">l</span> <span class="free">k</span> <span class="bound">u</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upt_eq_lel_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> gap_effect_invar<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> k<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">k</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> l_invar_def <span class="keyword1"><span class="command">using</span></span> V_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> N_not_Z cardV_le_N <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> l_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> gap_effect_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v l' u
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">u</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gap_effect_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap2</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  nfoldli <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">]</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">clc</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">lv</span> <span class="main">←</span> clc_get_rlx <span class="bound">clc</span> <span class="bound">v</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">&lt;</span> <span class="bound">lv</span> <span class="main">∧</span> <span class="bound">lv</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">clc</span> <span class="main">←</span> clc_set <span class="bound">clc</span> <span class="bound">v</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="bound">clc</span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="bound">clc</span>
  <span class="main">}</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1" id="Prpu_Common_Impl-gap2_refine"><span class="command">lemma</span></span> gap2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ci</span><span class="main">,</span><span class="free">C</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ki</span><span class="main">,</span><span class="free">k</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gap2 <span class="free">Ci</span> <span class="free">clc</span> <span class="free">ki</span> <span class="main">≤</span><span class="main">⇓</span>clc_rel <span class="main">(</span>gap_aux <span class="free">C</span> <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gap2_def gap_aux_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> CLC<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_relabel_aux</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">lu</span> <span class="main">←</span> l_get <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> relabel <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="keyword1">if</span> gap_precond <span class="bound">l</span> <span class="bound">lu</span> <span class="keyword1">then</span> 
    gap_aux <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">l</span> <span class="bound">lu</span>
  <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="bound">l</span>
<span class="main">}</span>"</span></span>  

<span class="keyword1" id="Prpu_Common_Impl-gap_relabel_aux_refine"><span class="command">lemma</span></span> gap_relabel_aux_refine<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> card V"</span></span> <span class="quoted"><span class="quoted">"l_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gap_relabel_aux <span class="free">C</span> <span class="free">f</span> <span class="free">l</span> <span class="free">u</span> <span class="main">≤</span> gap_relabel <span class="free">f</span> <span class="free">l</span> <span class="free">u</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> gap_relabel_aux_def gap_relabel_def relabel_def 
    gap_relabel_effect_def l_get_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Let_def nres_monad_laws<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    
    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_adj_label_clc</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="main">⇒</span> min_adj_label <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span>"</span></span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_relabel2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">nl</span> <span class="main">←</span> min_adj_label_clc <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">clc</span> <span class="main">←</span> clc_set <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="bound">nl</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">clc</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1" id="Prpu_Common_Impl-clc_relabel2_refine"><span class="command">lemma</span></span> clc_relabel2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> XF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"clc_relabel2 <span class="free">am</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">ui</span> <span class="main">≤</span> <span class="main">⇓</span>clc_rel <span class="main">(</span>relabel <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>    
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"clc_relabel2 <span class="free">am</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">ui</span> <span class="main">≤</span><span class="main">⇓</span>clc_rel <span class="main">(</span>relabel2 <span class="free">am</span> <span class="free">cf</span> <span class="free">l</span> <span class="free">ui</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> clc_relabel2_def relabel2_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CLC<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> CLC 
      <span class="keyword1"><span class="command">unfolding</span></span> clc_rel_def in_br_conv min_adj_label_clc_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> relabel2_refine<span class="main">[</span><span class="operator">OF</span> XF AM<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">ui</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
<span class="keyword1"><span class="command">qed</span></span>  
  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gap_relabel2</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">lu</span> <span class="main">←</span> clc_get <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">clc</span> <span class="main">←</span> clc_relabel2 <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">has_gap</span> <span class="main">←</span> clc_has_gap <span class="bound">clc</span> <span class="bound">lu</span><span class="main">;</span>
  <span class="keyword1">if</span> <span class="bound">has_gap</span> <span class="keyword1">then</span> gap2 <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">clc</span> <span class="bound">lu</span>
  <span class="keyword1">else</span> 
    RETURN <span class="bound">clc</span>
<span class="main">}</span>"</span></span>  
  
<span class="keyword1" id="Prpu_Common_Impl-gap_relabel2_refine_aux"><span class="command">lemma</span></span> gap_relabel2_refine_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XCF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">cf</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ci</span><span class="main">,</span><span class="free">C</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gap_relabel2 <span class="free">Ci</span> <span class="free">am</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">ui</span> <span class="main">≤</span> <span class="main">⇓</span>clc_rel <span class="main">(</span>gap_relabel_aux <span class="free">C</span> <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> gap_relabel2_def gap_relabel_aux_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> XCF AM CLC if_bind_cond_refine bind_refine'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> refl <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> _ lu
    <span class="keyword1"><span class="command">using</span></span> CLC
    <span class="keyword1"><span class="command">unfolding</span></span> clc_get_def l_get_def clc_rel_def in_br_conv clc_invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
    
<span class="keyword1" id="Prpu_Common_Impl-gap_relabel2_refine"><span class="command">lemma</span></span> gap_relabel2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XCF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">cf</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>    
  <span class="keyword2"><span class="keyword">assumes</span></span> CC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> card V"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gap_relabel2 <span class="free">C</span> <span class="free">am</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">ui</span> <span class="main">≤</span><span class="main">⇓</span>clc_rel <span class="main">(</span>gap_relabel <span class="free">f</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> CLC <span class="keyword1"><span class="command">have</span></span> LINV<span class="main">:</span> <span class="quoted"><span class="quoted">"l_invar <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> clc_rel_def in_br_conv clc_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">note</span></span> gap_relabel2_refine_aux<span class="main">[</span><span class="operator">OF</span> XCF CLC AM IdI IdI<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> gap_relabel_aux_refine<span class="main">[</span><span class="operator">OF</span> CC LINV<span class="main">]</span>  
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
<span class="keyword1"><span class="command">qed</span></span>    
    
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Efficient Data Structures›</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Registration of Abstract Operations›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We register all abstract operations at once, 
  auto-rewriting the capacity matrix type›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> Network_Impl_Sepref_Register 
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">x_get</span> <span class="quoted">x_add</span>
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">l_init</span> <span class="quoted">l_get</span> <span class="quoted">l_get_rlx</span> <span class="quoted">l_set</span>

<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">clc_init</span> <span class="quoted">clc_get</span> <span class="quoted">clc_set</span> <span class="quoted">clc_has_gap</span> <span class="quoted">clc_get_rlx</span>  
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">cnt_init</span> <span class="quoted">cnt_get</span> <span class="quoted">cnt_incr</span> <span class="quoted">cnt_decr</span>  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">gap2</span> <span class="quoted">min_adj_label</span> <span class="quoted">min_adj_label_clc</span> 
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">push2</span> <span class="quoted">relabel2</span> <span class="quoted">clc_relabel2</span> <span class="quoted">gap_relabel2</span>
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">pp_init_xcf2</span>  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Anonymous Context›</span> 
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Excess by Array›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">x_assn</span> <span class="main">≡</span> is_nf <span class="free">N</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>capacity_impl<span class="main">)</span>"</span></span>    
  
<span class="keyword1" id="Prpu_Common_Impl-x_init_hnr"><span class="command">lemma</span></span> x_init_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="main">(</span>Array.new <span class="free">N</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> uncurry0 x_init<span class="main">)</span> <span class="main">∈</span> unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> x_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> <span class="keyword1"><span class="command">unfolding</span></span> x_assn_def x_init_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> nf_init_rule<span class="main">)</span>
    
<span class="keyword1" id="Prpu_Common_Impl-x_get_hnr"><span class="command">lemma</span></span> x_get_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry Array.nth<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST x_get<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cap_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> x_assn_def x_get_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x_add_impl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">Δ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">xu</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="bound">xu</span><span class="main">+</span><span class="free"><span class="bound"><span class="entity">Δ</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">x</span>
<span class="main">}</span>"</span></span>  
<span class="keyword1" id="Prpu_Common_Impl-x_add_hnr"><span class="command">lemma</span></span> x_add_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 x_add_impl<span class="main">,</span> uncurry2 <span class="main">(</span>PR_CONST x_add<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cap_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> x_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> x_assn_def x_add_impl_def x_add_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Labeling by Array›</span></span>      
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">l_assn</span> <span class="main">≡</span> is_nf <span class="free">N</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">l_init_impl</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">cardV</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">l</span> <span class="main">←</span> Array.new <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">cardV</span></span></span> <span class="bound">l</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">l</span>
<span class="main">}</span>"</span></span>  
<span class="keyword1" id="Prpu_Common_Impl-l_init_hnr"><span class="command">lemma</span></span> l_init_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>l_init_impl <span class="free">N</span> <span class="free">s</span><span class="main">,</span> <span class="main">(</span>PR_CONST l_init<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> l_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> l_assn_def l_init_def l_init_impl_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> nf_init_rule<span class="main">)</span>
    
<span class="keyword1" id="Prpu_Common_Impl-l_get_hnr"><span class="command">lemma</span></span> l_get_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry Array.nth<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST l_get<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> l_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> l_assn_def l_get_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    
<span class="keyword1" id="Prpu_Common_Impl-l_get_rlx_hnr"><span class="command">lemma</span></span> l_get_rlx_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry Array.nth<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST l_get_rlx<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> l_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> l_assn_def l_get_rlx_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    
    
<span class="keyword1" id="Prpu_Common_Impl-l_set_hnr"><span class="command">lemma</span></span> l_set_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">i</span> <span class="bound">x</span><span class="main">.</span> Array.upd <span class="bound">i</span> <span class="bound">x</span> <span class="bound">a</span><span class="main">)</span><span class="main">,</span> uncurry2 <span class="main">(</span>PR_CONST l_set<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> l_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> l_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> l_assn_def l_set_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
      
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Label Frequency by Array›</span></span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cnt_assn</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">::</span>node<span class="main">⇒</span>nat<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> 
  <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>length <span class="bound">l</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">≥</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">cnt_init_impl</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">a</span> <span class="main">←</span> Array.new <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">;</span>
  <span class="bound">a</span> <span class="main">←</span> Array.upd <span class="main">0</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="bound">a</span><span class="main">;</span>
  <span class="bound">a</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">1</span> <span class="bound">a</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">a</span>
<span class="main">}</span>"</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">cnt_incr_impl</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">freq</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
  <span class="bound">a</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span><span class="bound">freq</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">a</span>
<span class="main">}</span>"</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">cnt_decr_impl</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">freq</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">;</span>
  <span class="bound">a</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span><span class="bound">freq</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">a</span>
<span class="main">}</span>"</span></span>  
  
 
<span class="keyword1" id="Prpu_Common_Impl-cnt_init_hnr"><span class="command">lemma</span></span> cnt_init_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cnt_init_impl <span class="free">N</span><span class="main">,</span> PR_CONST cnt_init<span class="main">)</span> <span class="main">∈</span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cnt_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
  <span class="keyword1"><span class="command">unfolding</span></span> cnt_init_def cnt_init_impl_def cnt_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> 

<span class="keyword1" id="Prpu_Common_Impl-cnt_get_hnr"><span class="command">lemma</span></span> cnt_get_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry Array.nth<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST cnt_get<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> cnt_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
  <span class="keyword1"><span class="command">unfolding</span></span> cnt_get_def cnt_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> 

<span class="keyword1" id="Prpu_Common_Impl-cnt_incr_hnr"><span class="command">lemma</span></span> cnt_incr_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry cnt_incr_impl<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST cnt_incr<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> cnt_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cnt_assn"</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
  <span class="keyword1"><span class="command">unfolding</span></span> cnt_incr_def cnt_incr_impl_def cnt_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> 
    
<span class="keyword1" id="Prpu_Common_Impl-cnt_decr_hnr"><span class="command">lemma</span></span> cnt_decr_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry cnt_decr_impl<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST cnt_decr<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> cnt_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cnt_assn"</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
  <span class="keyword1"><span class="command">unfolding</span></span> cnt_decr_def cnt_decr_impl_def cnt_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> 
  
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Combined Frequency Count and Labeling›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">clc_assn</span> <span class="main">≡</span> cnt_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> l_assn"</span></span>
    

<span class="keyword1"><span class="command">sepref_thm</span></span> clc_init_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"PR_CONST clc_init"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> clc_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clc_init_def PR_CONST_def clc_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">clc_init_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.clc_init_impl.refine_raw
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> clc_init_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
    
<span class="keyword1"><span class="command">sepref_thm</span></span> clc_get_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST clc_get<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clc_get_def PR_CONST_def clc_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">clc_get_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.clc_get_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> clc_get_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> clc_get_rlx_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST clc_get_rlx<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clc_get_rlx_def PR_CONST_def clc_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">clc_get_rlx_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.clc_get_rlx_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> clc_get_rlx_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
  
<span class="keyword1"><span class="command">sepref_thm</span></span> clc_set_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 <span class="main">(</span>PR_CONST clc_set<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> clc_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clc_set_def PR_CONST_def clc_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">clc_set_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.clc_set_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> clc_set_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> clc_has_gap_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST clc_has_gap<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> bool_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clc_has_gap_def PR_CONST_def clc_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">clc_has_gap_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.clc_has_gap_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> clc_has_gap_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
    
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Push›</span></span>   

<span class="keyword1"><span class="command">sepref_thm</span></span> push_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 <span class="main">(</span>PR_CONST push2<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> edge_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>x_assn<span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>cf_assn<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> push2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">push_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.push_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> push_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Relabel›</span></span>   
<span class="keyword1"><span class="command">sepref_thm</span></span> min_adj_label_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry3 <span class="main">(</span>PR_CONST min_adj_label<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> l_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> min_adj_label_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">min_adj_label_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.min_adj_label_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry3 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> min_adj_label_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>    
  

<span class="keyword1"><span class="command">sepref_thm</span></span> relabel_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry3 <span class="main">(</span>PR_CONST relabel2<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> l_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> l_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> relabel2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">relabel_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.relabel_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry3 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> relabel_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Gap-Relabel›</span></span>   
  
<span class="keyword1"><span class="command">sepref_thm</span></span> gap_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 <span class="main">(</span>PR_CONST gap2<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> clc_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> gap2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gap_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.gap_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> gap_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>

<span class="keyword1"><span class="command">sepref_thm</span></span> min_adj_label_clc_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry3 <span class="main">(</span>PR_CONST min_adj_label_clc<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> min_adj_label_clc_def PR_CONST_def clc_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>    
    
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">min_adj_label_clc_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.min_adj_label_clc_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry3 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> min_adj_label_clc_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> clc_relabel_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry3 <span class="main">(</span>PR_CONST clc_relabel2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> clc_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clc_relabel2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">clc_relabel_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.clc_relabel_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry3 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> clc_relabel_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> gap_relabel_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry4 <span class="main">(</span>PR_CONST gap_relabel2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> 
      <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> clc_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> gap_relabel2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gap_relabel_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.gap_relabel_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry4 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> gap_relabel_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Initialization›</span></span>  
<span class="keyword1"><span class="command">sepref_thm</span></span> pp_init_xcf2_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST pp_init_xcf2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> x_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> pp_init_xcf2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">pp_init_xcf2_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.pp_init_xcf2_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> pp_init_xcf2_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>  
  
  
  
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Fifo_Push_Relabel_Impl">
<div class="head">
<h1>Theory Fifo_Push_Relabel_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of the FIFO Push/Relabel Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Fifo_Push_Relabel_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="#Fifo_Push_Relabel">Fifo_Push_Relabel</a>
  <a href="#Prpu_Common_Impl">Prpu_Common_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Operations›</span></span>
<span class="keyword1"><span class="command">context</span></span> Network_Impl 
<span class="keyword2"><span class="keyword">begin</span></span>  


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Queue›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obtain the empty queue.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">q_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node list nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">q_empty</span> <span class="main">≡</span> <span class="keyword1">return</span> <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Check whether a queue is empty.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">q_is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node list <span class="main">⇒</span> bool nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">q_is_empty</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="keyword1">return</span> <span class="main">(</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Enqueue a node.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">q_enqueue</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list <span class="main">⇒</span> node list nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">q_enqueue</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">@</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dequeue a node.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">q_dequeue</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node list <span class="main">⇒</span> <span class="main">(</span>node <span class="main">×</span> node list<span class="main">)</span> nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">q_dequeue</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span>hd <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span> tl <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinements to Basic Operations›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl 
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we refine the algorithm to actually use the 
 basic operations.
›</span></span>
  
  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Push›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push2_aux</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∪</span> E<span class="main">¯</span> <span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span> <span class="bound">u</span> <span class="main">≠</span> <span class="bound">v</span> <span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Δ</span> <span class="main">=</span> min <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Q</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">≠</span><span class="free">t</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">@</span><span class="main">[</span><span class="bound">v</span><span class="main">]</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">(</span> <span class="bound">u</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span> <span class="main">-</span> <span class="bound">Δ</span><span class="main">,</span> <span class="bound">v</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">v</span> <span class="main">+</span> <span class="bound">Δ</span> <span class="main">)</span><span class="main">,</span>augment_edge_cf <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">Δ</span><span class="main">)</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_push2_aux_refine"><span class="command">lemma</span></span> fifo_push2_aux_refine<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel<span class="main">;</span> <span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id<span class="main">;</span> <span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">⟧</span> 
    <span class="main">⟹</span> fifo_push2_aux <span class="free">x</span> <span class="free">cf</span> <span class="free">Qi</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>fifo_push <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_def fifo_push2_aux_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xf_rel_def no_self_loop<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u v 
    <span class="keyword1"><span class="command">unfolding</span></span> push_precond_def <span class="keyword1"><span class="command">using</span></span> cfE_of_ss_invE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> u v 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"push_precond <span class="free">f</span> <span class="free">l</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> l'<span class="main">:</span> push_effect_locale <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> l'.excess'_if l'.Δ_def l'.cf'_alt l'.uv_not_eq<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>  
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push2</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∪</span> E<span class="main">¯</span> <span class="main">)</span><span class="main">;</span>
  <span class="bound">xu</span> <span class="main">←</span> x_get <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span><span class="main">;</span>
  <span class="bound">xv</span> <span class="main">←</span> x_get <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">v</span><span class="main">;</span>
  <span class="bound">cfuv</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">cfvu</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Δ</span> <span class="main">=</span> min <span class="bound">xu</span> <span class="bound">cfuv</span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> x_add <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">u</span> <span class="main">(</span><span class="main">-</span><span class="bound">Δ</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">x</span> <span class="main">←</span> x_add <span class="bound">x</span> <span class="bound">v</span> <span class="bound">Δ</span><span class="main">;</span>

  <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="bound">cfuv</span> <span class="main">-</span> <span class="bound">Δ</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">(</span><span class="bound">cfvu</span> <span class="main">+</span> <span class="bound">Δ</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">≠</span><span class="free">t</span> <span class="main">∧</span> <span class="bound">xv</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">Q</span> <span class="main">←</span> q_enqueue <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">else</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_push2_refine"><span class="command">lemma</span></span> fifo_push2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_push2 <span class="free">x</span> <span class="free">cf</span> <span class="free">Qi</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>fifo_push <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fifo_push2 <span class="free">x</span> <span class="free">cf</span> <span class="free">Qi</span> <span class="free">ei</span> <span class="main">≤</span> <span class="main">(</span>fifo_push2_aux <span class="free">x</span> <span class="free">cf</span> <span class="free">Qi</span> <span class="free">ei</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> fifo_push2_def fifo_push2_aux_def
    <span class="keyword1"><span class="command">unfolding</span></span> x_get_def x_add_def cf_get_def cf_set_def q_enqueue_def
    <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_cf_def  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
    <span class="keyword1"><span class="command">using</span></span> E_ss_VxV  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fifo_push2_aux_refine<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>    
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span> 
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Gap-Relabel›</span></span>    
  
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_gap_relabel_aux</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">Q</span> <span class="main">←</span> q_enqueue <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
  <span class="bound">lu</span> <span class="main">←</span> l_get <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> relabel <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="keyword1">if</span> gap_precond <span class="bound">l</span> <span class="bound">lu</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">l</span> <span class="main">←</span> gap_aux <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">l</span> <span class="bound">lu</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
<span class="main">}</span>"</span></span>  

<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_gap_relabel_aux_refine"><span class="command">lemma</span></span> fifo_gap_relabel_aux_refine<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> card V"</span></span> <span class="quoted"><span class="quoted">"l_invar <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_gap_relabel_aux <span class="free">C</span> <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span> <span class="main">≤</span> fifo_gap_relabel <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_gap_relabel_aux_def fifo_gap_relabel_def relabel_def 
    gap_relabel_effect_def l_get_def q_enqueue_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Let_def nres_monad_laws<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  
  
  
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_gap_relabel2</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">Q</span> <span class="main">←</span> q_enqueue <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
  <span class="bound">lu</span> <span class="main">←</span> clc_get <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">clc</span> <span class="main">←</span> clc_relabel2 <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">has_gap</span> <span class="main">←</span> clc_has_gap <span class="bound">clc</span> <span class="bound">lu</span><span class="main">;</span>
  <span class="keyword1">if</span> <span class="bound">has_gap</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">clc</span> <span class="main">←</span> gap2 <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">clc</span> <span class="bound">lu</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">else</span> 
    RETURN <span class="main">(</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
<span class="main">}</span>"</span></span>  
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_gap_relabel2_refine_aux"><span class="command">lemma</span></span> fifo_gap_relabel2_refine_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XCF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">cf</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ci</span><span class="main">,</span><span class="free">C</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_gap_relabel2 <span class="free">Ci</span> <span class="free">am</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">Qi</span> <span class="free">ui</span> 
          <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>fifo_gap_relabel_aux <span class="free">C</span> <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_gap_relabel2_def fifo_gap_relabel_aux_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> XCF AM CLC if_bind_cond_refine bind_refine'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> refl <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> _ lu
    <span class="keyword1"><span class="command">using</span></span> CLC
    <span class="keyword1"><span class="command">unfolding</span></span> clc_get_def l_get_def clc_rel_def in_br_conv clc_invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_gap_relabel2_refine"><span class="command">lemma</span></span> fifo_gap_relabel2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XCF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">cf</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>    
  <span class="keyword2"><span class="keyword">assumes</span></span> CC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> card V"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_gap_relabel2 <span class="free">C</span> <span class="free">am</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">Qi</span> <span class="free">ui</span> 
          <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>fifo_gap_relabel <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> CLC <span class="keyword1"><span class="command">have</span></span> LINV<span class="main">:</span> <span class="quoted"><span class="quoted">"l_invar <span class="free">l</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> clc_rel_def in_br_conv clc_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">note</span></span> fifo_gap_relabel2_refine_aux<span class="main">[</span><span class="operator">OF</span> XCF CLC AM IdI IdI IdI<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fifo_gap_relabel_aux_refine<span class="main">[</span><span class="operator">OF</span> CC LINV<span class="main">]</span>  
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Discharge›</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Some lengthy, multi-step refinement of discharge, 
  changing the iteration to iteration over adjacent nodes with filter,
  and showing that we can do the filter wrt.\ the current state, rather than 
  the original state before the loop. 
›</span></span>  
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-am_nodes_as_filter"><span class="command">lemma</span></span> am_nodes_as_filter<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">v</span> <span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span><span class="main">}</span> <span class="main">=</span> set <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="free">am</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms cfE_of_ss_invE 
  <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def Graph.E_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span> 
      
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Fifo_Push_Relabel_Impl-adjacent_nodes_iterate_refine1"><span class="command">lemma</span></span> adjacent_nodes_iterate_refine1<span class="main">:</span>   
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ff</span> <span class="free">u</span> <span class="free">f</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AMR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">si</span><span class="main">.</span> <span class="main">(</span><span class="bound">si</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span>Id <span class="main">⟹</span> <span class="free">cci</span> <span class="bound">si</span> <span class="main">⟷</span> <span class="free">cc</span> <span class="bound">s</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> FR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">vi</span> <span class="bound">s</span> <span class="bound">si</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">vi</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="bound">v</span><span class="main">∈</span>V<span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span><span class="main">;</span> <span class="main">(</span><span class="bound">si</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">⟧</span> <span class="main">⟹</span> 
    <span class="free">ffi</span> <span class="bound">vi</span> <span class="bound">si</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
                      <span class="keyword1">if</span> <span class="main">(</span>cf_of <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="free">ff</span> <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">else</span> RETURN <span class="bound">s</span>
                    <span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">vi</span> <span class="bound">s</span> <span class="bound">si</span><span class="main">.</span> <span class="main">⟦</span><span class="main">_</span><span class="main">;</span><span class="main">_</span><span class="main">;</span><span class="main">_</span><span class="main">;</span><span class="main">_</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">_</span>  <span class="main">≤</span> <span class="main">⇓</span><span class="main">_</span> <span class="main">(</span><span class="var">?ff'</span> <span class="bound">v</span> <span class="bound">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S0R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s0i</span><span class="main">,</span><span class="free">s0</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nfoldli <span class="main">(</span><span class="free">am</span> <span class="free">ui</span><span class="main">)</span> <span class="free">cci</span> <span class="free">ffi</span> <span class="free">s0i</span> 
        <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>FOREACHc <span class="main">{</span><span class="bound">v</span> <span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span><span class="main">}</span> <span class="free">cc</span> <span class="free">ff</span> <span class="free">s0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> fun_relD<span class="main">[</span><span class="operator">OF</span> AMR<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv adjacent_nodes_def<span class="main">)</span>  
  
  <span class="keyword1"><span class="command">from</span></span> AM <span class="keyword1"><span class="command">have</span></span> AM_SS_V<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">am</span> <span class="free">u</span><span class="main">)</span> <span class="main">⊆</span> V"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">×</span>set <span class="main">(</span><span class="free">am</span> <span class="free">u</span><span class="main">)</span> <span class="main">⊆</span> E <span class="main">∪</span> E<span class="main">¯</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def <span class="keyword1"><span class="command">using</span></span> E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">thm</span></span> nfoldli_refine    
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nfoldli <span class="main">(</span><span class="free">am</span> <span class="free">ui</span><span class="main">)</span> <span class="free">cci</span> <span class="free">ffi</span> <span class="free">s0</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>nfoldli <span class="main">(</span><span class="free">am</span> <span class="free">ui</span><span class="main">)</span> <span class="free">cc</span> <span class="var">?ff'</span> <span class="free">s0</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> FR<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> list_rel_congD<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span> 
    <span class="keyword1"><span class="command">using</span></span> CR  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
    <span class="keyword1"><span class="command">using</span></span> AM_SS_V UR <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nfoldli <span class="main">(</span><span class="free">am</span> <span class="free">ui</span><span class="main">)</span> <span class="free">cc</span> <span class="var">?ff'</span> <span class="free">s0</span> 
            <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>FOREACHc <span class="main">(</span>adjacent_nodes <span class="free">u</span><span class="main">)</span> <span class="free">cc</span> <span class="var">?ff'</span> <span class="free">s0</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> LFOc_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fun_relD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AMR UR<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"FOREACHc <span class="main">(</span>adjacent_nodes <span class="free">u</span><span class="main">)</span> <span class="free">cc</span> <span class="var">?ff'</span> <span class="free">s0</span> 
            <span class="main">≤</span> FOREACHc <span class="main">{</span><span class="bound">v</span> <span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>cfE_of <span class="free">f</span><span class="main">}</span> <span class="free">cc</span> <span class="free">ff</span> <span class="free">s0</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> am_nodes_as_filter<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> FOREACHc_filter_deforestation2<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> AM <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_refl<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">fo_rule</span> cong<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
        <span class="keyword1"><span class="command">using</span></span> fun_relD<span class="main">[</span><span class="operator">OF</span> AMR IdI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> S0R <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>    
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_loop_aux</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>distinct <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  nfoldli <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> excess <span class="bound">f</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span>cf_of <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="bound">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_push <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">assert</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">.</span> <span class="bound">v'</span><span class="main">≠</span><span class="bound">v</span> <span class="main">⟶</span> cf_of <span class="bound">f'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">=</span> cf_of <span class="bound">f</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_discharge_aux</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>  
  <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> q_dequeue <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">u</span><span class="main">∈</span>V <span class="main">∧</span> <span class="bound">u</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">u</span><span class="main">≠</span><span class="free">t</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> dis_loop_aux <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">Q</span> <span class="bound">u</span><span class="main">;</span>

  <span class="keyword1">if</span> excess <span class="bound">f</span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_gap_relabel <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span> <span class="bound">u</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_discharge_aux_refine"><span class="command">lemma</span></span> fifo_discharge_aux_refine<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">fi</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">li</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_discharge_aux <span class="free">am</span> <span class="free">fi</span> <span class="free">li</span> <span class="free">Qi</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>fifo_discharge <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_discharge_aux_def fifo_discharge_def dis_loop_aux_def 
  <span class="keyword1"><span class="command">unfolding</span></span> q_dequeue_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> adjacent_nodes_iterate_refine1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> fun_relD<span class="main">[</span><span class="operator">OF</span> AM IdI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"hd <span class="free">Q</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>  
    <span class="keyword1"><span class="command">unfolding</span></span> list_set_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_loop_aux2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>distinct <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  nfoldli <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> excess <span class="bound">f</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">∪</span>E<span class="main">¯</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span>cf_of <span class="bound">f</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="bound">l</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_push <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">assert</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">.</span> <span class="bound">v'</span><span class="main">≠</span><span class="bound">v</span> <span class="main">⟶</span> cf_of <span class="bound">f'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">=</span> cf_of <span class="bound">f</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Fifo_Push_Relabel_Impl-dis_loop_aux2_refine"><span class="command">lemma</span></span> dis_loop_aux2_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dis_loop_aux2 <span class="free">am</span> <span class="free">f<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span> <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>dis_loop_aux <span class="free">am</span> <span class="free">f<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> dis_loop_aux2_def dis_loop_aux_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ASSERT_refine_right ASSERT_refine_left<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nfoldli_invar_refine<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
            I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it1</span> <span class="bound">it2</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="bound">it2</span><span class="main">.</span> cf_of <span class="bound">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> cf_of <span class="free">f<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_leof_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> fifo_push_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_loop_aux3</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V <span class="main">∧</span> distinct <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  monadic_nfoldli <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">xu</span> <span class="main">←</span> x_get <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">xu</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">cfuv</span> <span class="main">←</span> cf_get <span class="bound">cf</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">cfuv</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">lu</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="bound">lv</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="bound">v</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="bound">lu</span> <span class="main">=</span> <span class="bound">lv</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_push2 <span class="bound">x</span> <span class="bound">cf</span> <span class="bound">Q</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Fifo_Push_Relabel_Impl-dis_loop_aux3_refine"><span class="command">lemma</span></span> dis_loop_aux3_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ami</span><span class="main">,</span><span class="free">am</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">li</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dis_loop_aux3 <span class="free">ami</span> <span class="free">x</span> <span class="free">cf</span> <span class="free">li</span> <span class="free">Qi</span> <span class="free">ui</span> 
        <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>dis_loop_aux2 <span class="free">am</span> <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> dis_loop_aux3_def dis_loop_aux2_def
  <span class="keyword1"><span class="command">unfolding</span></span> x_get_def cf_get_def l_get_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws nfoldli_to_monadic<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
  <span class="keyword1"><span class="command">using</span></span> XF  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xf_rel_def in_br_conv<span class="main">)</span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_loop2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">assert</span> <span class="main">(</span>distinct <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">amu</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  monadic_nfoldli <span class="bound">amu</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">xu</span> <span class="main">←</span> x_get <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">xu</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">cfuv</span> <span class="main">←</span> cf_get <span class="bound">cf</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">cfuv</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">lu</span> <span class="main">←</span> clc_get <span class="bound">clc</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="bound">lv</span> <span class="main">←</span> clc_get <span class="bound">clc</span> <span class="bound">v</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="bound">lu</span> <span class="main">=</span> <span class="bound">lv</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_push2 <span class="bound">x</span> <span class="bound">cf</span> <span class="bound">Q</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">clc</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Fifo_Push_Relabel_Impl-dis_loop2_refine_aux"><span class="command">lemma</span></span> dis_loop2_refine_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xi</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cfi</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ami</span><span class="main">,</span><span class="free">am</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">li</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dis_loop2 <span class="free">ami</span> <span class="free">xi</span> <span class="free">cfi</span> <span class="free">clc</span> <span class="free">Qi</span> <span class="free">ui</span> 
        <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>dis_loop_aux3 <span class="free">am</span> <span class="free">x</span> <span class="free">cf</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> dis_loop2_def dis_loop_aux3_def am_get_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CLC<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-dis_loop2_refine"><span class="command">lemma</span></span> dis_loop2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>xf_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ami</span><span class="main">,</span><span class="free">am</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dis_loop2 <span class="free">ami</span> <span class="free">x</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">Qi</span> <span class="free">ui</span> 
        <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>dis_loop_aux <span class="free">am</span> <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>      
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span><span class="main">)</span> <span class="main">=</span> xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prod_rel_comp<span class="main">)</span>
  
  <span class="keyword1"><span class="command">note</span></span> dis_loop2_refine_aux<span class="main">[</span><span class="operator">OF</span> IdI IdI IdI IdI IdI IdI CLC<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> dis_loop_aux3_refine<span class="main">[</span><span class="operator">OF</span> IdI IdI IdI IdI XF<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> dis_loop_aux2_refine  
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> conc_fun_chain monoD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> conc_fun_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    
    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_discharge2</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>  
  <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> q_dequeue <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">u</span><span class="main">∈</span>V <span class="main">∧</span> <span class="bound">u</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">u</span><span class="main">≠</span><span class="free">t</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> dis_loop2 <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">clc</span></span></span> <span class="bound">Q</span> <span class="bound">u</span><span class="main">;</span>

  <span class="bound">xu</span> <span class="main">←</span> x_get <span class="bound">x</span> <span class="bound">u</span><span class="main">;</span>
  <span class="keyword1">if</span> <span class="bound">xu</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> fifo_gap_relabel2 <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">cf</span> <span class="bound">clc</span> <span class="bound">Q</span> <span class="bound">u</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_discharge2_refine"><span class="command">lemma</span></span> fifo_discharge2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XCF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">cf</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CLC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">clc</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>clc_rel"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">Q</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> card V"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_discharge2 <span class="free">C</span> <span class="free">am</span> <span class="free">x</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">Qi</span> 
        <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>fifo_discharge <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fifo_discharge2 <span class="free">C</span> <span class="free">am</span> <span class="free">x</span> <span class="free">cf</span> <span class="free">clc</span> <span class="free">Q</span> 
        <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> clc_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="main">(</span>fifo_discharge_aux <span class="free">am</span> <span class="free">f</span> <span class="free">l</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fifo_discharge2_def fifo_discharge_aux_def  
    <span class="keyword1"><span class="command">unfolding</span></span> x_get_def  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> XCF CLC AM IdI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> CC<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> xf_rel_def in_br_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span> <span class="operator">assumption</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fifo_discharge_aux_refine<span class="main">[</span><span class="operator">OF</span> AM IdI IdI IdI<span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Anonymous Context›</span>    

  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Computing the Initial Queue›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">q_init</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">Q</span> <span class="main">←</span> q_empty<span class="main">;</span>
  <span class="bound">ams</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
  nfoldli <span class="bound">ams</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">Q</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">t</span> <span class="keyword1">then</span> q_enqueue <span class="bound">v</span> <span class="bound">Q</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="bound">Q</span>
  <span class="main">}</span><span class="main">)</span> <span class="bound">Q</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_init_correct"><span class="command">lemma</span></span> q_init_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"q_init <span class="free">am</span> 
    <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">l</span><span class="main">.</span> distinct <span class="bound">l</span> <span class="main">∧</span> set <span class="bound">l</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span> <span class="free">t</span><span class="main">}</span><span class="main">.</span> excess pp_init_f <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
  <span class="keyword1"><span class="command">from</span></span> am_to_adj_nodes_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> V"</span></span>
    <span class="keyword1"><span class="command">using</span></span> adjacent_nodes_ss_V
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"q_init <span class="free">am</span> <span class="main">≤</span> RETURN <span class="main">(</span>filter <span class="main">(</span><span class="main">(≠)</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> q_init_def q_empty_def q_enqueue_def am_get_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l1</span> <span class="main"><span class="bound">_</span></span> <span class="bound">l</span><span class="main">.</span> <span class="bound">l</span> <span class="main">=</span> filter <span class="main">(</span><span class="main">(≠)</span> <span class="free">t</span><span class="main">)</span> <span class="bound">l1</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">l</span><span class="main">.</span> distinct <span class="bound">l</span> <span class="main">∧</span> set <span class="bound">l</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">v</span></span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span> <span class="free">t</span><span class="main">}</span><span class="main">.</span> excess pp_init_f <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
    <span class="keyword1"><span class="command">from</span></span> am_to_adj_nodes_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> adjacent_nodes <span class="free">s</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> list_set_rel_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv<span class="main">)</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> E_ss_VxV
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pp_init_x_def adjacent_nodes_def<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>      
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refining the Main Algorithm›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel_aux</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">cardV</span> <span class="main">←</span> init_C <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">cardV</span> <span class="main">=</span> card V<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> pp_init_f<span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> l_init <span class="bound">cardV</span><span class="main">;</span>

  <span class="bound">Q</span> <span class="main">←</span> q_init <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> monadic_WHILEIT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">qe</span> <span class="main">←</span> q_is_empty <span class="bound">Q</span><span class="main">;</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">¬</span><span class="bound">qe</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      fifo_discharge <span class="bound">f</span> <span class="bound">l</span> <span class="bound">Q</span>
    <span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span>Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">l</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_push_relabel_aux_refine"><span class="command">lemma</span></span> fifo_push_relabel_aux_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_push_relabel_aux <span class="free">am</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>fifo_push_relabel<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_aux_def fifo_push_relabel_def
  <span class="keyword1"><span class="command">unfolding</span></span> l_init_def pp_init_l_def q_is_empty_def bind_to_let_conv
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> specify_left<span class="main"><span class="main">[</span></span><span class="operator">OF</span> init_C_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> q_init_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
    
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">cardV</span> <span class="main">←</span> init_C <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
  <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">←</span> pp_init_xcf2 <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
  <span class="bound">clc</span> <span class="main">←</span> clc_init <span class="bound">cardV</span><span class="main">;</span>
  <span class="bound">Q</span> <span class="main">←</span> q_init <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>

  <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> monadic_WHILEIT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">qe</span> <span class="main">←</span> q_is_empty <span class="bound">Q</span><span class="main">;</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">¬</span><span class="bound">qe</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      fifo_discharge2 <span class="bound">cardV</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">x</span> <span class="bound">cf</span> <span class="bound">clc</span> <span class="bound">Q</span>
    <span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">return</span> <span class="bound">cf</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_push_relabel2_refine"><span class="command">lemma</span></span> fifo_push_relabel2_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fifo_push_relabel2 <span class="free">am</span> 
        <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>br <span class="main">(</span>flow_of_cf<span class="main">)</span> <span class="main">(</span>RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> fifo_push_relabel"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Height_Bounded_Labeling <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f</span> <span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Height_Bounded_Labeling <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="keyword1"><span class="command">.</span></span>  
    <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"flow_of_cf cf <span class="main">=</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fo_rg_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> G2<span class="main">:</span> <span class="quoted"><span class="quoted">"RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> cf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_RPreGraph<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> G1 G2    
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this   
  
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fifo_push_relabel2 <span class="free">am</span> 
        <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>br <span class="main">(</span>flow_of_cf<span class="main">)</span> <span class="main">(</span>RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>fifo_push_relabel_aux <span class="free">am</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel2_def fifo_push_relabel_aux_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> AM am_to_adj_nodes_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>   
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> AUX1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv xf_rel_def AM<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fifo_push_relabel_aux_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>  
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Impl. Locale›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Separating out the Initialization of the Adjacency Matrix›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We split the algorithm into an initialization of the adjacency 
  matrix, and the actual algorithm. This way, the algorithm can handle 
  pre-initialized adjacency matrices.
›</span></span>  
 
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel_init2</span> <span class="main">≡</span> cf_init"</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pp_init_xcf2'</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">x</span> <span class="main">←</span> x_init<span class="main">;</span>

  <span class="keyword1">assert</span> <span class="main">(</span><span class="free">s</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
  <span class="bound">adj</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
  nfoldli <span class="bound">adj</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free">s</span> <span class="main">≠</span> <span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">a</span> <span class="main">←</span> cf_get <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">x</span> <span class="main">←</span> x_add <span class="bound">x</span> <span class="free">s</span> <span class="main">(</span><span class="main">-</span><span class="bound">a</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">x</span> <span class="main">←</span> x_add <span class="bound">x</span> <span class="bound">v</span> <span class="bound">a</span><span class="main">;</span>
    <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">0</span><span class="main">;</span> 
    <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span> <span class="bound">a</span><span class="main">;</span> 
    <span class="keyword1">return</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel_run2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">cardV</span> <span class="main">←</span> init_C <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
  <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">←</span> pp_init_xcf2' <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">;</span>
  <span class="bound">clc</span> <span class="main">←</span> clc_init <span class="bound">cardV</span><span class="main">;</span>
  <span class="bound">Q</span> <span class="main">←</span> q_init <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>

  <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span> <span class="main">←</span> monadic_WHILEIT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">qe</span> <span class="main">←</span> q_is_empty <span class="bound">Q</span><span class="main">;</span> <span class="keyword1">return</span> <span class="main">(</span><span class="main">¬</span><span class="bound">qe</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      fifo_discharge2 <span class="bound">cardV</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">x</span> <span class="bound">cf</span> <span class="bound">clc</span> <span class="bound">Q</span>
    <span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">clc</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">return</span> <span class="bound">cf</span>
<span class="main">}</span>"</span></span>
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-fifo_push_relabel2_alt"><span class="command">lemma</span></span> fifo_push_relabel2_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fifo_push_relabel2 <span class="free">am</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">cf</span> <span class="main">←</span> fifo_push_relabel_init2<span class="main">;</span>
    fifo_push_relabel_run2 <span class="free">am</span> <span class="bound">cf</span>
  <span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_init2_def fifo_push_relabel_run2_def
    fifo_push_relabel2_def pp_init_xcf2_def pp_init_xcf2'_def
    cf_init_def <span class="comment1">(* Unfolding this b/c it's a return and thus can be inlined.*)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Impl. Locale›</span>
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement To Efficient Data Structures›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Registration of Abstract Operations›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We register all abstract operations at once, 
  auto-rewriting the capacity matrix type›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> Network_Impl_Sepref_Register 
<span class="keyword2"><span class="keyword">begin</span></span>  
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">q_empty</span> <span class="quoted">q_is_empty</span> <span class="quoted">q_enqueue</span> <span class="quoted">q_dequeue</span>  
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">fifo_push2</span>  
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">fifo_gap_relabel2</span> 
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">dis_loop2</span> <span class="quoted">fifo_discharge2</span>
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">q_init</span> <span class="quoted">pp_init_xcf2'</span>
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">fifo_push_relabel_run2</span> <span class="quoted">fifo_push_relabel_init2</span>
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">fifo_push_relabel2</span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Anonymous Context›</span> 
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Queue by Two Stacks›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">q_α</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span><span class="bound">R</span><span class="main">)</span><span class="main">.</span> <span class="bound">L</span><span class="main">@</span>rev <span class="bound">R</span>"</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">q_empty_impl</span> <span class="main">≡</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">q_is_empty_impl</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span><span class="bound">R</span><span class="main">)</span><span class="main">.</span> is_Nil <span class="bound">L</span> <span class="main">∧</span> is_Nil <span class="bound">R</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">q_enqueue_impl</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span> <span class="main">(</span><span class="bound">L</span><span class="main">,</span><span class="bound">R</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">L</span><span class="main">,</span><span class="bound">x</span><span class="main">#</span><span class="bound">R</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">q_dequeue_impl</span> 
  <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">#</span><span class="bound">L</span><span class="main">,</span><span class="bound">R</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span><span class="bound">R</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="bound">R</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">case</span> rev <span class="bound">R</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x</span><span class="main">#</span><span class="bound">L</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_empty_impl_correct"><span class="command">lemma</span></span> q_empty_impl_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"q_α q_empty_impl <span class="main">=</span> <span class="main">[]</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> q_α_def q_empty_impl_def<span class="main">)</span>
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_enqueue_impl_correct"><span class="command">lemma</span></span> q_enqueue_impl_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"q_α <span class="main">(</span>q_enqueue_impl <span class="free">x</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> q_α <span class="free">Q</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> q_α_def q_enqueue_impl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_is_empty_impl_correct"><span class="command">lemma</span></span> q_is_empty_impl_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"q_is_empty_impl <span class="free">Q</span> <span class="main">⟷</span> q_α <span class="free">Q</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> q_α_def q_is_empty_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.splits<span class="main">)</span>

    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_dequeue_impl_correct_aux"><span class="command">lemma</span></span> q_dequeue_impl_correct_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>q_α <span class="free">Q</span> <span class="main">=</span> <span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">⟧</span> <span class="main">⟹</span> apsnd q_α <span class="main">(</span>q_dequeue_impl <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> q_α_def q_dequeue_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>  

<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_dequeue_impl_correct"><span class="command">lemma</span></span> q_dequeue_impl_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"q_dequeue_impl <span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">Q'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"q_α <span class="free">Q</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> hd <span class="main">(</span>q_α <span class="free">Q</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"q_α <span class="free">Q'</span> <span class="main">=</span> tl <span class="main">(</span>q_α <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms q_dequeue_impl_correct_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Q</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"q_α <span class="free">Q</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">q_assn</span> <span class="main">≡</span> pure <span class="main">(</span>br q_α <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span><span class="main">)</span>"</span></span>

  
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_empty_impl_hnr"><span class="command">lemma</span></span> q_empty_impl_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="main">(</span><span class="keyword1">return</span> q_empty_impl<span class="main">)</span><span class="main">,</span> uncurry0 q_empty<span class="main">)</span> <span class="main">∈</span> unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sepref_to_hoare</span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> q_assn_def q_empty_def pure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv<span class="main">)</span> 
    
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_is_empty_impl_hnr"><span class="command">lemma</span></span> q_is_empty_impl_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">return</span> <span class="keyword1">o</span> q_is_empty_impl<span class="main">,</span> q_is_empty<span class="main">)</span> <span class="main">∈</span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> bool_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sepref_to_hoare</span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> q_assn_def q_is_empty_def pure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv<span class="main">)</span> 
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_enqueue_impl_hnr"><span class="command">lemma</span></span> q_enqueue_impl_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="main">(</span><span class="keyword1">return</span> <span class="keyword1">oo</span> q_enqueue_impl<span class="main">)</span><span class="main">,</span> uncurry <span class="main">(</span>PR_CONST q_enqueue<span class="main">)</span><span class="main">)</span> 
    <span class="main">∈</span> nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sepref_to_hoare</span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> q_assn_def q_enqueue_def pure_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> 
  
<span class="keyword1" id="Fifo_Push_Relabel_Impl-q_dequeue_impl_hnr"><span class="command">lemma</span></span> q_dequeue_impl_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span>    
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">return</span> <span class="keyword1">o</span> q_dequeue_impl<span class="main">,</span> q_dequeue<span class="main">)</span> <span class="main">∈</span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sepref_to_hoare</span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> q_assn_def q_dequeue_def pure_def prod_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span> 
    
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Push›</span></span>   

<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_push_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry3 <span class="main">(</span>PR_CONST fifo_push2<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> edge_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> 
      <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span><span class="main">(</span>x_assn<span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>cf_assn<span class="main">)</span><span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>q_assn<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_push_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_push_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry3 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_push_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Gap-Relabel›</span></span>   
  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_gap_relabel_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry5 <span class="main">(</span>PR_CONST fifo_gap_relabel2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> 
      <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> clc_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_gap_relabel2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_gap_relabel_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_gap_relabel_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry5 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_gap_relabel_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Discharge›</span></span>  
  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_dis_loop_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry5 <span class="main">(</span>PR_CONST dis_loop2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> 
      <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>x_assn<span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>cf_assn<span class="main">)</span><span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>clc_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> dis_loop2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_dis_loop_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_dis_loop_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry5 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_dis_loop_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_fifo_discharge_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry5 <span class="main">(</span>PR_CONST fifo_discharge2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> clc_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> q_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> 
    <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>x_assn<span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>cf_assn<span class="main">)</span><span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span>clc_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_discharge2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_fifo_discharge_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_fifo_discharge_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry5 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> 
  fifo_fifo_discharge_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Computing the Initial State›</span></span>  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_init_C_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST init_C<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> init_C_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_init_C_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_init_C_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_init_C_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_q_init_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST q_init<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> q_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> q_init_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_q_init_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_q_init_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_q_init_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>

<span class="keyword1"><span class="command">sepref_thm</span></span> pp_init_xcf2'_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST pp_init_xcf2'<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> x_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> pp_init_xcf2'_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">pp_init_xcf2'_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.pp_init_xcf2'_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> pp_init_xcf2'_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Main Algorithm›</span></span>  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_push_relabel_run_impl 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST fifo_push_relabel_run2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_run2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_push_relabel_run_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_push_relabel_run_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> 
  fifo_push_relabel_run_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_push_relabel_init_impl 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry0 <span class="main">(</span>PR_CONST fifo_push_relabel_init2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_init2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_push_relabel_init_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_push_relabel_init_impl.refine_raw 
    <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> 
  fifo_push_relabel_init_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>

  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_push_relabel_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST fifo_push_relabel2<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel2_alt PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_push_relabel_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_push_relabel_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_push_relabel_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Impl. Locale›</span>
  
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">fifo_push_relabel_impl</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp 
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combining the Refinement Steps›</span></span>  
  
  
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network_Impl<span class="main">)</span> fifo_push_relabel_impl_correct<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span>am_assn <span class="free">am</span> <span class="free">ami</span><span class="main">&gt;</span> 
      fifo_push_relabel_impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">ami</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">cfi</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">cf</span><span class="main">.</span> 
        am_assn <span class="free">am</span> <span class="free">ami</span> <span class="main">*</span> cf_assn <span class="bound">cf</span> <span class="bound">cfi</span> 
      <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>isMaxFlow <span class="main">(</span>flow_of_cf <span class="bound">cf</span><span class="main">)</span> <span class="main">∧</span> RGraph_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="bound">cf</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> fifo_push_relabel2_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span>    
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fifo_push_relabel_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> R1<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"fifo_push_relabel2 <span class="free">am</span> 
    <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span>br flow_of_cf <span class="main">(</span>RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>SPEC isMaxFlow<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>  

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span><span class="main">⇓</span><span class="skolem">R</span> <span class="main">(</span>RES <span class="skolem">X</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="skolem">X</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> R2 <span class="main">=</span> fifo_push_relabel_impl.refine<span class="main">[</span>
              <span class="operator">OF</span> Network_Impl_axioms<span class="main">,</span> <span class="operator">to_hnr</span><span class="main">,</span> <span class="operator">unfolded</span> <span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> R3 <span class="main">=</span> hn_refine_ref<span class="main">[</span><span class="operator">OF</span> R1 R2<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">ami</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> R4 <span class="main">=</span> R3<span class="main">[</span><span class="operator">unfolded</span> hn_ctxt_def pure_def<span class="main">,</span> <span class="operator">THEN</span> hn_refineD<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    
  <span class="keyword1"><span class="command">note</span></span> RGII <span class="main">=</span> rgraph_and_network_impl_imp_rgraph_impl<span class="main">[</span><span class="operator">OF</span> 
    RPreGraph.maxflow_imp_rgraph
    Network_Impl_axioms
      <span class="main">]</span>  
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
        <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> R4 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RGII
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> in_br_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combination with Network Checker and Main Correctness Theorem›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel_impl_tab_am</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">ami</span> <span class="main">←</span> Array.make <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>  <span class="comment1">― ‹TODO/DUP: Called <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>init_ps›</span></span> in Edmonds-Karp impl›</span>
  <span class="bound">cfi</span> <span class="main">←</span> fifo_push_relabel_impl <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="bound">ami</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="bound">ami</span><span class="main">,</span><span class="bound">cfi</span><span class="main">)</span>
<span class="main">}</span>"</span></span>  
  
  
<span class="keyword1"><span class="command">theorem</span></span> fifo_push_relabel_impl_tab_am_correct<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> NW<span class="main">:</span> <span class="quoted"><span class="quoted">"Network <span class="free">c</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VN<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ABS_PS<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.is_adj_map <span class="free">c</span> <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
      fifo_push_relabel_impl_tab_am <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">am</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="main">(</span><span class="bound">ami</span><span class="main">,</span><span class="bound">cfi</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">cf</span><span class="main">.</span> 
        am_assn <span class="free">N</span> <span class="free">am</span> <span class="bound">ami</span> <span class="main">*</span> cf_assn <span class="free">N</span> <span class="bound">cf</span> <span class="bound">cfi</span>
      <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>Network.isMaxFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>Network.flow_of_cf <span class="free">c</span> <span class="bound">cf</span><span class="main">)</span>
        <span class="main">∧</span> RGraph_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="bound">cf</span>
        <span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Network <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> Network_Impl <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">N</span></span> <span class="keyword1"><span class="command">using</span></span> VN <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>    
  
  <span class="keyword1"><span class="command">from</span></span> ABS_PS <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">am</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≥</span><span class="free">N</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def
    <span class="keyword1"><span class="command">using</span></span> E_ss_VxV VN that 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>V"</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> inV_less_N<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_impl_tab_am_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Hoare_Triple.cons_rule<span class="main"><span class="main">[</span></span>
            <span class="operator">OF</span> _ _ fifo_push_relabel_impl_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ABS_PS<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> am_assn_def is_nf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ent_refl<span class="main">)</span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>        
  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">case</span> prepareNet <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="keyword1">return</span> None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">ami</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">←</span> fifo_push_relabel_impl_tab_am <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">N</span> <span class="bound">am</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">ami</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">fifo_push_relabel</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

  
<span class="comment1">(* TODO: Also generate correctness theorem for fifo_push_relabel_run!
  For this, push the split up to abstract level!
*)</span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Main correctness statement:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> If <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fifo_push_relabel›</span></span></span></span> returns <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span>, the edge list was invalid or 
    described an invalid network. 
  <span class="antiquoted"><span class="antiquoted">▪</span></span> If it returns <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Some (c,am,N,cfi)›</span></span></span></span>, then the edge list is valid and describes 
    a valid network. Moreover, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cfi›</span></span></span></span> is an integer square matrix of dimension 
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>N›</span></span></span></span>, which describes a valid residual graph in the network, whose 
    corresponding flow is maximal. Finally, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>am›</span></span></span></span> is a valid adjacency map of the
    graph, and the nodes of the graph are integers less than <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>N›</span></span></span></span>.
›</span></span>  
  
<span class="keyword1"><span class="command">theorem</span></span> fifo_push_relabel_correct<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span>
  fifo_push_relabel <span class="free">el</span> <span class="free">s</span> <span class="free">t</span>
  <span class="main">&lt;</span><span class="main">λ</span>
    None <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">ami</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cfi</span><span class="main">)</span> <span class="main">⇒</span> 
      <span class="main">↑</span><span class="main">(</span><span class="bound">c</span> <span class="main">=</span> ln_α <span class="free">el</span> <span class="main">∧</span> ln_invar <span class="free">el</span> <span class="main">∧</span> Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span> 
    <span class="main">*</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">am</span> <span class="bound">cf</span><span class="main">.</span> am_assn <span class="bound">N</span> <span class="bound">am</span> <span class="bound">ami</span> <span class="main">*</span> cf_assn <span class="bound">N</span> <span class="bound">cf</span> <span class="bound">cfi</span> 
          <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>RGraph_Impl <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">N</span> <span class="bound">cf</span> <span class="main">∧</span> Graph.is_adj_map <span class="bound">c</span> <span class="bound">am</span>
            <span class="main">∧</span> Network.isMaxFlow <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>Network.flow_of_cf <span class="bound">c</span> <span class="bound">cf</span><span class="main">)</span><span class="main">)</span>
      <span class="main">)</span>
  <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>
  "</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_def
  <span class="keyword1"><span class="command">using</span></span> prepareNet_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_rel_def in_br_conv<span class="main">)</span>
  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Justification of Splitting into Prepare and Run Phase›</span></span>    
<span class="comment1">(* TODO: Show correctness theorems for both phases separately!  *)</span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel_prepare_impl</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">case</span> prepareNet <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="keyword1">return</span> None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">ami</span> <span class="main">←</span> Array.make <span class="bound">N</span> <span class="bound">am</span><span class="main">;</span>
      <span class="bound">cfi</span> <span class="main">←</span> fifo_push_relabel_init_impl <span class="bound">c</span> <span class="bound">N</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">N</span><span class="main">,</span><span class="bound">ami</span><span class="main">,</span><span class="bound">c</span><span class="main">,</span><span class="bound">cfi</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> justify_fifo_push_relabel_prep_run_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fifo_push_relabel <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> 
  <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">pr</span> <span class="main">←</span> fifo_push_relabel_prepare_impl <span class="free">el</span> <span class="free">s</span> <span class="free">t</span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">pr</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="keyword1">return</span> None
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">N</span><span class="main">,</span><span class="bound">ami</span><span class="main">,</span><span class="bound">c</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">cf</span> <span class="main">←</span> fifo_push_relabel_run_impl <span class="free">s</span> <span class="free">t</span> <span class="bound">N</span> <span class="bound">ami</span> <span class="bound">cf</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">ami</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span>
  <span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_def fifo_push_relabel_prepare_impl_def
    fifo_push_relabel_impl_tab_am_def fifo_push_relabel_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>  
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Usage Example: Computing Maxflow Value ›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We implement a function to compute the value of the maximum flow.›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fifo_push_relabel_compute_flow_val</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">r</span> <span class="main">←</span> fifo_push_relabel <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
  <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="keyword1">return</span> None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> compute_flow_val_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">N</span> <span class="bound">am</span> <span class="bound">cf</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">)</span>
    <span class="main">}</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The computed flow value is correct›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> fifo_push_relabel_compute_flow_val_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
    fifo_push_relabel_compute_flow_val <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> 
  <span class="main">&lt;</span><span class="main">λ</span>
    None <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>
  <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span> ln_invar <span class="free">el</span> 
      <span class="main">∧</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> ln_α <span class="free">el</span> <span class="keyword1">in</span>
          Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">∧</span> Network.is_max_flow_val <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">v</span>
        <span class="main">)</span><span class="main">)</span>    
  <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cf</span> <span class="skolem">N</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"RGraph_Impl <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">N</span> <span class="skolem">cf</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> RGraph <span class="quoted"><span class="quoted">"<span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">cf</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> RGraph_Impl.axioms<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"f <span class="main">=</span> flow_of_cf <span class="skolem">cf</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux<span class="main">=</span>this
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fifo_push_relabel_compute_flow_val_def    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Network.is_max_flow_val_def aux<span class="main">)</span>
      
<span class="keyword1"><span class="command">qed</span></span>    
      
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">fifo_push_relabel_compute_flow_val</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp  
  

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Relabel_To_Front_Impl">
<div class="head">
<h1>Theory Relabel_To_Front_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Relabel-to-Front›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Relabel_To_Front_Impl
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#Relabel_To_Front">Relabel_To_Front</a>
  <a href="#Prpu_Common_Impl">Prpu_Common_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Operations›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Neighbor Lists›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">n_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> nres"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n_init</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">(</span> <span class="free">s</span> <span class="main">:=</span> <span class="main">[]</span><span class="main">,</span> <span class="free">t</span> <span class="main">:=</span> <span class="main">[]</span><span class="main">)</span> <span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">n_at_end</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> bool nres"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n_at_end</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">n_get_hd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> node nres"</span></span>    
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n_get_hd</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span>hd <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">n_move_next</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> <span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n_move_next</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> tl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">n_reset</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node 
    <span class="main">⇒</span> <span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> nres"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n_reset</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
  
<span class="keyword1" id="Relabel_To_Front_Impl-n_init_refine"><span class="command">lemma</span></span> n_init_refine<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"n_init <span class="free">am</span> 
    <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> rtf_init_n<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">am</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∉</span>V"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> that <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"adjacent_nodes <span class="skolem">v</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">using</span></span> E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> am_to_adj_nodes_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>      
    <span class="keyword1"><span class="command">unfolding</span></span> n_init_def rtf_init_n_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> list_set_autoref_empty 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> am_to_adj_nodes_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Basic Operations›</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Discharge›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">discharge2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>  
  <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">∈</span> V<span class="main">)</span><span class="main">;</span>
  monadic_WHILEIT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">xu</span> <span class="main">←</span> x_get <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">xu</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">}</span> <span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">at_end</span> <span class="main">←</span> n_at_end <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">at_end</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">l</span> <span class="main">←</span> relabel2 <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">cf</span> <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="bound">n</span> <span class="main">←</span> n_reset <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">v</span> <span class="main">←</span> n_get_hd <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="bound">cfuv</span> <span class="main">←</span> cf_get <span class="bound">cf</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">lu</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
        <span class="bound">lv</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="bound">v</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="bound">cfuv</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">lu</span> <span class="main">=</span> <span class="bound">lv</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">←</span> push2 <span class="bound">x</span> <span class="bound">cf</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">n</span> <span class="main">←</span> n_move_next <span class="bound">n</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">}</span>
    <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1" id="Relabel_To_Front_Impl-discharge_structure_refine_aux"><span class="command">lemma</span></span> discharge_structure_refine_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ni</span><span class="main">,</span><span class="free">n</span><span class="main">)</span><span class="main">∈</span>nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SU<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> fNR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fNi</span> <span class="main">≤</span> <span class="main">⇓</span><span class="free">R</span> <span class="free">fN</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> fSR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">vi</span> <span class="bound">vs</span><span class="main">.</span> <span class="main">⟦</span> 
      <span class="main">(</span><span class="bound">vi</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="bound">v</span><span class="main">∈</span><span class="free">n</span> <span class="free">u</span><span class="main">;</span> <span class="free">ni</span> <span class="free">u</span> <span class="main">=</span> <span class="bound">v</span><span class="main">#</span><span class="bound">vs</span><span class="main">;</span> <span class="main">(</span><span class="bound">v</span><span class="main">#</span><span class="bound">vs</span><span class="main">,</span><span class="free">n</span> <span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel 
    <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">fSi</span> <span class="bound">vi</span> <span class="main">≤</span> <span class="main">⇓</span><span class="free">R</span> <span class="main">(</span><span class="free">fS</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">at_end</span> <span class="main">←</span> n_at_end <span class="free">ni</span> <span class="free">ui</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">at_end</span> <span class="keyword1">then</span> <span class="free">fNi</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> n_get_hd <span class="free">ni</span> <span class="free">ui</span><span class="main">;</span>
      <span class="free">fSi</span> <span class="bound">v</span>
    <span class="main">}</span>
  <span class="main">}</span> <span class="main">)</span> <span class="main">≤</span> <span class="main">⇓</span><span class="free">R</span> <span class="main">(</span>

  <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">v</span> <span class="main">←</span> <span class="keyword1">select</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span><span class="free">n</span> <span class="free">u</span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">v</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="free">fN</span>
    <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free">fS</span> <span class="bound">v</span>
  <span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span><span class="main">⇓</span><span class="free">R</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> n_at_end_def n_get_hd_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ni</span> <span class="free">u</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> fun_relD<span class="main">[</span><span class="operator">OF</span> SR SU<span class="main">]</span> SU UIV fNR
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v vs
    <span class="keyword1"><span class="command">using</span></span> fun_relD<span class="main">[</span><span class="operator">OF</span> SR SU<span class="main">]</span> SU UIV
    <span class="keyword1"><span class="command">using</span></span> fSR<span class="main">[</span><span class="operator">OF</span> IdI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main">]</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
  
<span class="keyword1" id="Relabel_To_Front_Impl-xf_rel_RELATES"><span class="command">lemma</span></span> xf_rel_RELATES<span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES xf_rel"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>
  
<span class="keyword1" id="Relabel_To_Front_Impl-discharge2_refine"><span class="command">lemma</span></span> discharge2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>     
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">cf</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">)</span> <span class="main">∈</span> xf_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">li</span><span class="main">,</span><span class="free">l</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> NR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ni</span><span class="main">,</span><span class="free">n</span><span class="main">)</span><span class="main">∈</span>nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"discharge2 <span class="free">am</span> <span class="free">x</span> <span class="free">cf</span> <span class="free">li</span> <span class="free">ni</span> <span class="free">ui</span> 
    <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>xf_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">(</span>nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel<span class="main">)</span><span class="main">)</span> <span class="main">(</span>discharge <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> discharge2_def discharge_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"monadic_WHILEIT <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> vcg_intro_frame<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> A NR<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xf_rel_def x_get_def<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f l n x cf ni   
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> vcg_rem_frame<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> n_reset_def cf_get_def l_get_def n_move_next_def  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> discharge_structure_refine_aux<span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">refine_vcg</span> AM<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">assumption</span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_relD fun_relD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v vs <span class="keyword1"><span class="command">unfolding</span></span> xf_rel_def Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v vs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹ Initialization of Queue ›</span></span>
    
<span class="keyword1" id="Relabel_To_Front_Impl-V_is_adj_nodes"><span class="command">lemma</span></span> V_is_adj_nodes<span class="main">:</span> <span class="quoted"><span class="quoted">"V <span class="main">=</span> <span class="main">{</span> <span class="bound">v</span> <span class="main">.</span> adjacent_nodes <span class="bound">v</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> V_def adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_CQ</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">cardV</span><span class="main">=</span><span class="main">0</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">Q</span><span class="main">=</span><span class="main">[]</span><span class="main">;</span>
  nfoldli <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">]</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">v</span><span class="main">&lt;</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">inV</span> <span class="main">←</span> am_is_in_V <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">v</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">inV</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">cardV</span> <span class="main">=</span> <span class="bound">cardV</span> <span class="main">+</span> <span class="main">1</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">s</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">≠</span><span class="free">t</span> <span class="keyword1">then</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span><span class="bound">v</span><span class="main">#</span><span class="bound">Q</span><span class="main">)</span>
      <span class="keyword1">else</span> 
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span>
<span class="main">}</span>"</span></span>    

<span class="keyword1" id="Relabel_To_Front_Impl-init_CQ_correct"><span class="command">lemma</span></span> init_CQ_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"init_CQ <span class="free">am</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">C</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="bound">C</span> <span class="main">=</span> card V <span class="main">∧</span> distinct <span class="bound">Q</span> <span class="main">∧</span> set <span class="bound">Q</span> <span class="main">=</span> V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> init_CQ_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> 
      nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l1</span> <span class="main"><span class="bound">_</span></span> <span class="main">(</span><span class="bound">C</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> 
             <span class="bound">C</span> <span class="main">=</span> card <span class="main">(</span>V<span class="main">∩</span>set <span class="bound">l1</span><span class="main">)</span> <span class="main">∧</span> distinct <span class="bound">Q</span> <span class="main">∧</span> set <span class="bound">Q</span> <span class="main">=</span> <span class="main">(</span>V<span class="main">∩</span>set <span class="bound">l1</span><span class="main">)</span><span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> "</span></span><span class="main"><span class="main">]</span></span>
      <span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> am_to_adj_nodes_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> V_ss <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upt_eq_lel_conv Int_absorb2<span class="main">)</span>
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Main Algorithm›</span></span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel_to_front2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span> <span class="bound">L_right</span><span class="main">)</span> <span class="main">←</span> init_CQ <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>

  <span class="bound">xcf</span> <span class="main">←</span> pp_init_xcf2 <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
  <span class="bound">l</span> <span class="main">←</span> l_init <span class="bound">cardV</span><span class="main">;</span>
  <span class="bound">n</span> <span class="main">←</span> n_init <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>

  <span class="keyword1">let</span> <span class="bound">L_left</span><span class="main">=</span><span class="main">[]</span><span class="main">;</span>

  <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">.</span> <span class="bound">L_right</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">L_right</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">u</span> <span class="main">=</span> hd <span class="bound">L_right</span><span class="main">;</span>
      <span class="bound">old_lu</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="bound">u</span><span class="main">;</span>
  
      <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span> <span class="main">←</span> discharge2 <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">x</span> <span class="bound">cf</span> <span class="bound">l</span> <span class="bound">n</span> <span class="bound">u</span><span class="main">;</span>
  
      <span class="bound">lu</span> <span class="main">←</span> l_get <span class="bound">l</span> <span class="bound">u</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">lu</span> <span class="main">≠</span> <span class="bound">old_lu</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="comment1">― ‹Move <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>u›</span></span> to front of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>l›</span></span>, and restart scanning <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>L›</span></span>. The cost for›</span>
        <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>rev_append›</span></span> is amortized by going to next node in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>L›</span></span>›</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="bound">u</span><span class="main">]</span><span class="main">,</span>rev_append <span class="bound">L_left</span> <span class="main">(</span>tl <span class="bound">L_right</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="comment1">― ‹Goto next node in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>L›</span></span>›</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">u</span><span class="main">#</span><span class="bound">L_left</span><span class="main">,</span> tl <span class="bound">L_right</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span>
      <span class="main">}</span>
  
    <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">xcf</span><span class="main">,</span><span class="bound">l</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span><span class="bound">L_left</span><span class="main">,</span><span class="bound">L_right</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1">return</span> <span class="bound">cf</span>
<span class="main">}</span>"</span></span>
  
    
<span class="keyword1" id="Relabel_To_Front_Impl-relabel_to_front2_refine"><span class="command">lemma</span></span> relabel_to_front2_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"relabel_to_front2 <span class="free">am</span> 
    <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>br <span class="main">(</span>flow_of_cf<span class="main">)</span> <span class="main">(</span>RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> relabel_to_front"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">s_rel</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="main">_</span> <span class="main">×</span> <span class="main">(</span>
       capacity_impl flow 
    <span class="main">×</span> <span class="main">(</span>nat<span class="main">⇒</span>nat<span class="main">)</span> 
    <span class="main">×</span> <span class="main">(</span>node<span class="main">⇒</span>node set<span class="main">)</span> 
    <span class="main">×</span> node list 
    <span class="main">×</span> node list<span class="main">)</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s_rel</span> <span class="main">≡</span> 
       xf_rel 
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id 
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">(</span>nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel<span class="main">)</span> 
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> br rev <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES <span class="skolem">s_rel</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> RELATES_def <span class="keyword1"><span class="command">..</span></span>
      
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"neighbor_invar <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f</span> <span class="skolem">l</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> neighbor_invar <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="keyword1"><span class="command">.</span></span>  
    <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"flow_of_cf cf <span class="main">=</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fo_rg_inv<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> G2<span class="main">:</span> <span class="quoted"><span class="quoted">"RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> cf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_RPreGraph<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> G1 G2    
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this   
      
  <span class="keyword1"><span class="command">have</span></span> AUXR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">cardV</span><span class="main">,</span> <span class="bound">L_right</span><span class="main">)</span> <span class="main">←</span> init_CQ <span class="free">am</span><span class="main">;</span>
      <span class="bound">xcf</span> <span class="main">←</span> pp_init_xcf2 <span class="free">am</span><span class="main">;</span>
      <span class="bound">l</span> <span class="main">←</span> l_init <span class="bound">cardV</span><span class="main">;</span>
      <span class="bound">n</span> <span class="main">←</span> n_init <span class="free">am</span><span class="main">;</span>
      <span class="skolem">Fi</span> <span class="bound">L_right</span> <span class="bound">xcf</span> <span class="bound">l</span> <span class="bound">n</span>
    <span class="main">}</span>
    <span class="main">≤</span> <span class="main">⇓</span><span class="skolem">R</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">L_right</span> <span class="main">←</span> <span class="keyword1">spec</span> <span class="bound">l</span><span class="main">.</span> distinct <span class="bound">l</span> <span class="main">∧</span> set <span class="bound">l</span> <span class="main">=</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span> <span class="free">t</span><span class="main">}</span><span class="main">;</span>
      <span class="skolem">F</span> <span class="bound">L_right</span>
    <span class="main">}</span><span class="main">)</span>
  "</span></span> 
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">L_right</span> <span class="bound">xcf</span> <span class="bound">n</span><span class="main">.</span> 
    <span class="main">⟦</span> <span class="main">(</span><span class="bound">xcf</span><span class="main">,</span>pp_init_f<span class="main">)</span><span class="main">∈</span>xf_rel<span class="main">;</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span>rtf_init_n<span class="main">)</span> <span class="main">∈</span> nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel <span class="main">⟧</span>
    <span class="main">⟹</span> <span class="skolem">Fi</span> <span class="bound">L_right</span> <span class="bound">xcf</span> pp_init_l <span class="bound">n</span> <span class="main">≤</span> <span class="main">⇓</span><span class="skolem">R</span> <span class="main">(</span><span class="skolem">F</span> <span class="bound">L_right</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">Fi</span> <span class="skolem">F</span> <span class="skolem">R</span>
    <span class="keyword1"><span class="command">unfolding</span></span> l_init_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine2specI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> pp_init_xcf2_refine
            <span class="main">[</span><span class="operator">OF</span> AM<span class="main">,</span> <span class="operator">unfolded</span> conc_fun_RETURN<span class="main">,</span> <span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> n_init_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">,</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> AM V_ss<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> L_right x cf n
      <span class="keyword1"><span class="command">using</span></span> that<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">cf</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="skolem">L_right</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> pp_init_l_def  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">meson</span><span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relabel_to_front2_def relabel_to_front_def Let_def l_get_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> nres_monad_laws<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUXR<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command">unfolding</span></span> s_rel_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_br_conv rev_append_eq xf_rel_def AUX1 fun_relD 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> am_to_adj_nodes_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>  
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Efficient Data Structures›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> Network_Impl_Sepref_Register 
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">n_init</span>  
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">n_at_end</span>
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">n_get_hd</span>
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">n_move_next</span>
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">n_reset</span>
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">discharge2</span>
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"init_CQ"</span></span>
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">relabel_to_front2</span>
<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Neighbor Lists by Array of Lists›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">n_assn</span> <span class="main">≡</span> is_nf <span class="free">N</span> <span class="main">(</span><span class="main">[]</span><span class="main">::</span>nat list<span class="main">)</span>"</span></span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">n_init_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">n</span> <span class="main">←</span> array_copy <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
  <span class="bound">n</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">[]</span> <span class="bound">n</span><span class="main">;</span>
  <span class="bound">n</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">[]</span> <span class="bound">n</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">n</span>
<span class="main">}</span>"</span></span>      
    
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>n_init_impl <span class="free">s</span> <span class="free">t</span><span class="main">,</span>PR_CONST n_init<span class="main">)</span> <span class="main">∈</span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> n_assn"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
  <span class="keyword1"><span class="command">unfolding</span></span> am_assn_def n_assn_def n_init_impl_def n_init_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span><span class="main">)</span>  
    
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">n_at_end_impl</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">nu</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span>is_Nil <span class="bound">nu</span><span class="main">)</span>
<span class="main">}</span>"</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry n_at_end_impl<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST n_at_end<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> n_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> bool_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> <span class="keyword1"><span class="command">unfolding</span></span> n_at_end_impl_def n_at_end_def n_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">n_get_hd_impl</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">nu</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span>hd <span class="bound">nu</span><span class="main">)</span>
<span class="main">}</span>"</span></span>      
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry n_get_hd_impl<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST n_get_hd<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> n_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> node_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> <span class="keyword1"><span class="command">unfolding</span></span> n_get_hd_impl_def n_get_hd_def n_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">n_move_next_impl</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">nu</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">n</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>tl <span class="bound">nu</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">n</span>
<span class="main">}</span>"</span></span> 
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry n_move_next_impl<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST n_move_next<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> n_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> n_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> n_move_next_impl_def n_move_next_def n_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">n_reset_impl</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">nu</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="bound">n</span> <span class="main">←</span> Array.upd <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">nu</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">n</span>
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 n_reset_impl<span class="main">,</span> uncurry2 <span class="main">(</span>PR_CONST n_reset<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> n_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> n_assn"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> n_reset_impl_def n_reset_def n_assn_def am_assn_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Discharge›</span></span>  
<span class="keyword1"><span class="command">sepref_thm</span></span> discharge_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry5 <span class="main">(</span>PR_CONST discharge2<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> x_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> l_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> n_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> 
    <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>x_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="main">)</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> l_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> n_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> discharge2_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">discharge_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.discharge_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry5 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> discharge_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>    

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Initialization of Queue›</span></span>  
  
<span class="keyword1"><span class="command">sepref_thm</span></span> init_CQ_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST init_CQ<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> list_assn nat_assn"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> init_CQ_def PR_CONST_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> HOL_list.fold_custom_empty<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">init_CQ_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.init_CQ_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> init_CQ_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>    
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Main Algorithm›</span></span>  
<span class="keyword1"><span class="command">sepref_thm</span></span> relabel_to_front_impl <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST relabel_to_front2<span class="main">)</span>"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_to_front2_def PR_CONST_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"Let <span class="main"><span class="main">[]</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> HOL_list.fold_custom_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">[</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">]</span></span>"</span></span></span> HOL_list.fold_custom_empty<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">relabel_to_front_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.relabel_to_front_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> relabel_to_front_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span> 
  
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">relabel_to_front_impl</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combination with Network Checker and Correctness›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network_Impl <span class="keyword2"><span class="keyword">begin</span></span>
  
  <span class="keyword1"><span class="command">theorem</span></span> relabel_to_front_impl_correct<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
      <span class="main">&lt;</span>am_assn <span class="free">am</span> <span class="free">ami</span><span class="main">&gt;</span> 
        relabel_to_front_impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">ami</span>
      <span class="main">&lt;</span><span class="main">λ</span><span class="bound">cfi</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">cf</span><span class="main">.</span> cf_assn <span class="bound">cf</span> <span class="bound">cfi</span> 
                <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>isMaxFlow <span class="main">(</span>flow_of_cf <span class="bound">cf</span><span class="main">)</span> <span class="main">∧</span> RGraph_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="bound">cf</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> relabel_to_front2_refine<span class="main">[</span><span class="operator">OF</span> AM<span class="main">]</span>    
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> relabel_to_front_correct
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> R1<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"relabel_to_front2 <span class="free">am</span> 
      <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span>br flow_of_cf <span class="main">(</span>RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>SPEC isMaxFlow<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>  

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span><span class="main">⇓</span><span class="skolem">R</span> <span class="main">(</span>RES <span class="skolem">X</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="skolem">X</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
        
    <span class="keyword1"><span class="command">note</span></span> R2 <span class="main">=</span> relabel_to_front_impl.refine<span class="main">[</span>
      <span class="operator">OF</span> Network_Impl_axioms<span class="main">,</span> <span class="operator">to_hnr</span><span class="main">,</span> <span class="operator">unfolded</span> <span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> R3 <span class="main">=</span> hn_refine_ref<span class="main">[</span><span class="operator">OF</span> R1 R2<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">ami</span></span><span class="main">]</span>  
    <span class="keyword1"><span class="command">note</span></span> R4 <span class="main">=</span> R3<span class="main">[</span><span class="operator">unfolded</span> hn_ctxt_def pure_def<span class="main">,</span> <span class="operator">THEN</span> hn_refineD<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

    <span class="keyword1"><span class="command">note</span></span> RGII <span class="main">=</span> rgraph_and_network_impl_imp_rgraph_impl<span class="main">[</span><span class="operator">OF</span> 
      RPreGraph.maxflow_imp_rgraph
      Network_Impl_axioms
        <span class="main">]</span>  
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> R4 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> in_br_conv RGII<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>    

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel_to_front_impl_tab_am</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">ami</span> <span class="main">←</span> Array.make <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>  <span class="comment1">― ‹TODO/DUP: Called <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>init_ps›</span></span> in Edmonds-Karp impl›</span>
  relabel_to_front_impl <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="bound">ami</span>
<span class="main">}</span>"</span></span>  
  
<span class="keyword1"><span class="command">theorem</span></span> relabel_to_front_impl_tab_am_correct<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> NW<span class="main">:</span> <span class="quoted"><span class="quoted">"Network <span class="free">c</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VN<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ABS_PS<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.is_adj_map <span class="free">c</span> <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
      relabel_to_front_impl_tab_am <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">am</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">cfi</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">cf</span><span class="main">.</span> 
        asmtx_assn <span class="free">N</span> id_assn <span class="bound">cf</span> <span class="bound">cfi</span> 
      <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>Network.isMaxFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>Network.flow_of_cf <span class="free">c</span> <span class="bound">cf</span><span class="main">)</span>
        <span class="main">∧</span> RGraph_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="bound">cf</span>
        <span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Network <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> Network_Impl <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">N</span></span> <span class="keyword1"><span class="command">using</span></span> VN <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>    
  
  <span class="keyword1"><span class="command">from</span></span> ABS_PS <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">am</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≥</span><span class="free">N</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def
    <span class="keyword1"><span class="command">using</span></span> E_ss_VxV VN that 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>V"</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> inV_less_N<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relabel_to_front_impl_tab_am_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> 
        Hoare_Triple.cons_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ relabel_to_front_impl_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ABS_PS<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> am_assn_def is_nf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf_assn_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>        
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relabel_to_front</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">case</span> prepareNet <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="keyword1">return</span> None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">cf</span> <span class="main">←</span> relabel_to_front_impl_tab_am <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">N</span> <span class="bound">am</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">relabel_to_front</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Main correctness statement:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> If <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>relabel_to_front›</span></span></span></span> returns <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span>, the edge list was invalid or described 
    an invalid network. 
  <span class="antiquoted"><span class="antiquoted">▪</span></span> If it returns <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Some (c,am,N,cfi)›</span></span></span></span>, then the edge list is valid and describes
    a valid network. Moreover, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cfi›</span></span></span></span> is an integer square matrix of 
    dimension <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>N›</span></span></span></span>, which describes a valid residual graph in the network, whose
    corresponding flow is maximal. Finally, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>am›</span></span></span></span> is a valid adjacency map of the
    graph, and the nodes of the graph are integers less than <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>N›</span></span></span></span>.
›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> relabel_to_front_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span>
  relabel_to_front <span class="free">el</span> <span class="free">s</span> <span class="free">t</span>
  <span class="main">&lt;</span><span class="main">λ</span>
    None <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cfi</span><span class="main">)</span> <span class="main">⇒</span> 
      <span class="main">↑</span><span class="main">(</span><span class="bound">c</span> <span class="main">=</span> ln_α <span class="free">el</span> <span class="main">∧</span> ln_invar <span class="free">el</span><span class="main">)</span> 
    <span class="main">*</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">cf</span><span class="main">.</span> asmtx_assn <span class="bound">N</span> int_assn <span class="bound">cf</span> <span class="bound">cfi</span>
          <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>RGraph_Impl <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">N</span> <span class="bound">cf</span> 
            <span class="main">∧</span> Network.isMaxFlow <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>Network.flow_of_cf <span class="bound">c</span> <span class="bound">cf</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>Graph.is_adj_map <span class="bound">c</span> <span class="bound">am</span><span class="main">)</span>
  <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>
  "</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relabel_to_front_def
  <span class="keyword1"><span class="command">using</span></span> prepareNet_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_rel_def in_br_conv<span class="main">)</span>
  

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Generated_Code_Test">
<div class="head">
<h1>Theory Generated_Code_Test</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Example Usage of Generated ML Code›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Generated_Code_Test
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Fifo_Push_Relabel_Impl">Fifo_Push_Relabel_Impl</a> <a href="#Relabel_To_Front_Impl">Relabel_To_Front_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  
  <span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnv_edge_list</span> <span class="main">=</span> 
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">u</span><span class="main">,</span><span class="entity">v</span><span class="main">,</span><span class="entity">w</span><span class="main">)</span> <span class="main">=&gt;</span> 
              <span class="main">(</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">u</span><span class="main">,</span> 
                <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">v</span><span class="main">,</span> 
                 <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">int_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">w</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">relabel_to_front</span> <span class="entity">el</span> <span class="entity">s</span> <span class="entity">t</span> <span class="main">=</span> 
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">relabel_to_front</span><span class="antiquote">}</span></span></span> 
          <span class="main">(</span><span class="entity">cnv_edge_list</span> <span class="entity">el</span><span class="main">)</span> 
          <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">s</span><span class="main">)</span>
          <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">t</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fifo_push_relabel</span> <span class="entity">el</span> <span class="entity">s</span> <span class="entity">t</span> <span class="main">=</span> 
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">fifo_push_relabel</span><span class="antiquote">}</span></span></span> 
          <span class="main">(</span><span class="entity">cnv_edge_list</span> <span class="entity">el</span><span class="main">)</span> 
          <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">s</span><span class="main">)</span>
          <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">t</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fifo_push_relabel_cvv</span> <span class="entity">el</span> <span class="entity">s</span> <span class="entity">t</span> <span class="main">=</span> 
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">fifo_push_relabel_compute_flow_val</span><span class="antiquote">}</span></span></span> 
          <span class="main">(</span><span class="entity">cnv_edge_list</span> <span class="entity">el</span><span class="main">)</span> 
          <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">s</span><span class="main">)</span>
          <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">t</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_net</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span><span class="inner_numeral">1</span><span class="main">,</span><span class="inner_numeral">22</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span><span class="inner_numeral">2</span><span class="main">,</span><span class="inner_numeral">22</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span><span class="inner_numeral">3</span><span class="main">,</span><span class="inner_numeral">20</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span><span class="inner_numeral">3</span><span class="main">,</span><span class="inner_numeral">20</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span><span class="inner_numeral">4</span><span class="main">,</span><span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span><span class="inner_numeral">4</span><span class="main">,</span><span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_numeral">4</span><span class="main">,</span><span class="inner_numeral">3</span><span class="main">,</span><span class="inner_numeral">2</span><span class="main">)</span>
      <span class="main">]</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r1</span> <span class="main">=</span> <span class="entity">relabel_to_front</span> <span class="entity">test_net</span> <span class="inner_numeral">0</span> <span class="inner_numeral">3</span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r2</span> <span class="main">=</span> <span class="entity">fifo_push_relabel</span> <span class="entity">test_net</span> <span class="inner_numeral">0</span> <span class="inner_numeral">3</span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r3</span> <span class="main">=</span> <span class="entity">fifo_push_relabel_cvv</span> <span class="entity">test_net</span> <span class="inner_numeral">0</span> <span class="inner_numeral">3</span> <span class="main">(</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">r1</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> ERROR <span class="inner_quoted">"rtf"</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">r2</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> ERROR <span class="inner_quoted">"fifo"</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">r3</span> <span class="main">=</span> SOME <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">int_of_integer</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">42</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="keyword3"><span class="keyword">raise</span></span> ERROR <span class="inner_quoted">"fifo-cvv"</span>

    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">r1</span><span class="main">,</span><span class="entity">r2</span><span class="main">,</span><span class="entity">r3</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  ›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>