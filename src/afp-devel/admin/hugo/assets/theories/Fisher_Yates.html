<div id="Fisher_Yates">
<div class="head">
<h1>Theory Fisher_Yates</h1>
</div>
<pre class="source"><span class="comment1">(*
    File: Fisher_Yates.thy
    Author: Manuel Eberl, TU München
    
    Definition and correctness proofs for two variants of the 
    Fisher-Yates shuffle, an algorithm to shuffle an array in-place
    in linear time, i.e. produce a permutation uniformly at random.
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Fisher--Yates shuffle›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Fisher_Yates
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Probability/Probability.html">HOL-Probability.Probability</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* TODO Move *)</span>

<span class="keyword1" id="Fisher_Yates-integral_pmf_of_multiset"><span class="command">lemma</span></span> integral_pmf_of_multiset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{#}</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∫</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="main">::</span> real<span class="main">)</span> <span class="main">∂</span>measure_pmf <span class="main">(</span>pmf_of_multiset <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>set_mset <span class="free">A</span><span class="main">.</span> of_nat <span class="main">(</span>count <span class="free">A</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">/</span> of_nat <span class="main">(</span>size <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> integral_measure_pmf<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"set_mset <span class="free"><span class="free"><span class="free">A</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_divide_distrib mult_ac<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-pmf_bind_pmf_of_multiset"><span class="command">lemma</span></span> pmf_bind_pmf_of_multiset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{#}</span> <span class="main">⟹</span> pmf <span class="main">(</span>pmf_of_multiset <span class="free">A</span> <span class="main">⤜</span> <span class="free">f</span><span class="main">)</span> <span class="free">y</span> <span class="main">=</span> 
     <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>set_mset <span class="free">A</span><span class="main">.</span> real <span class="main">(</span>count <span class="free">A</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> pmf <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">y</span><span class="main">)</span> <span class="main">/</span> real <span class="main">(</span>size <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_bind integral_pmf_of_multiset<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-pmf_map_inj_inv"><span class="command">lemma</span></span> pmf_map_inj_inv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>set_pmf <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>map_pmf <span class="free">f</span> <span class="free">p</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> range <span class="free">f</span> <span class="keyword1">then</span> pmf <span class="free">p</span> <span class="main">(</span><span class="free">f'</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">`</span> set_pmf <span class="free">p</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> set_pmf <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>map_pmf <span class="free">f</span> <span class="free">p</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> pmf <span class="free">p</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_map_inj<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> y assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="free">f'</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> set_pmf <span class="main">(</span>map_pmf <span class="free">f</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>map_pmf <span class="free">f</span> <span class="free">p</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_pmf_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> range <span class="free">f</span> <span class="keyword1">then</span> pmf <span class="free">p</span> <span class="main">(</span><span class="free">f'</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> set_pmf_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="comment1">(* END MOVE *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Swapping elements in a list›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">swap</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">swap</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">!</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1" id="Fisher_Yates-length_swap"><span class="command">lemma</span></span> length_swap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>swap <span class="free">xs</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_def<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-swap_eq_Nil_iff"><span class="command">lemma</span></span> swap_eq_Nil_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"swap <span class="free">xs</span> <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_def<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-nth_swap"><span class="command">lemma</span></span> nth_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> 
    swap <span class="free">xs</span> <span class="free">i</span> <span class="free">j</span> <span class="main">!</span> <span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">k</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">then</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">k</span> <span class="main">=</span> <span class="free">j</span> <span class="keyword1">then</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="keyword1">else</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> swap_def nth_list_update<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-map_swap"><span class="command">lemma</span></span> map_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> map <span class="free">f</span> <span class="main">(</span>swap <span class="free">xs</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> swap <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_def map_update map_nth<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-swap_swap"><span class="command">lemma</span></span> swap_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> swap <span class="main">(</span>swap <span class="free">xs</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="free">j</span> <span class="free">i</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> nth_equalityI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_swap nth_list_update<span class="main">)</span>
  
<span class="keyword1" id="Fisher_Yates-mset_swap"><span class="command">lemma</span></span> mset_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> mset <span class="main">(</span>swap <span class="free">xs</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_update swap_def nth_list_update<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-hd_swap_0"><span class="command">lemma</span></span> hd_swap_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> hd <span class="main">(</span>swap <span class="free">xs</span> <span class="main">0</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> swap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> hd_conv_nth<span class="main">)</span> <span class="main">(</span><span class="operator">subst</span> nth_list_update <span class="main"><span class="keyword3">|</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Random Permutations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, we prove the intuitively obvious fact that choosing a random 
  permutation of a multiset can be done by first randomly choosing the 
  first element and then randomly choosing the rest of the list.
›</span></span>

<span class="keyword1" id="Fisher_Yates-pmf_of_set_permutations_of_multiset_nonempty"><span class="command">lemma</span></span> pmf_of_set_permutations_of_multiset_nonempty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="tfree">'a</span> multiset<span class="main">)</span> <span class="main">≠</span> <span class="main">{#}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
           <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> pmf_of_multiset <span class="free">A</span><span class="main">;</span>
               <span class="bound">xs</span> <span class="main">←</span> pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
               return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">#</span><span class="bound">xs</span><span class="main">)</span>
              <span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?lhs</span> <span class="skolem">xs</span> <span class="main">=</span> pmf <span class="var">?rhs</span> <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> permutations_of_multiset <span class="free">A</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∉</span> set_pmf <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> assms False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∉</span> set_pmf <span class="var">?rhs</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> permutations_of_multiset_Cons_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_pmf_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> permutations_of_multisetD<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> range_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> range <span class="main">(</span><span class="main">(#)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⟷</span> hd <span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> True nonempty 
      <span class="keyword1"><span class="command">have</span></span> hd_tl<span class="main">:</span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span> <span class="main">∈#</span> <span class="free">A</span> <span class="main">∧</span> tl <span class="skolem">xs</span> <span class="main">∈</span> permutations_of_multiset <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{#</span>hd <span class="skolem">xs</span><span class="main">#}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> permutations_of_multiset_Cons_iff<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?rhs</span> <span class="skolem">xs</span> <span class="main">=</span> 
      <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>set_mset <span class="free">A</span><span class="main">.</span> real <span class="main">(</span>count <span class="free">A</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">(#)</span> <span class="bound">x</span><span class="main">)</span> 
        <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">/</span> real <span class="main">(</span>size <span class="free">A</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?S</span> <span class="main">/</span> <span class="main">_</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> map_pmf_def <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_bind_pmf_of_multiset<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">=</span> 
      <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>set_mset <span class="free">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> hd <span class="skolem">xs</span> <span class="keyword1">then</span> real <span class="main">(</span>count <span class="free">A</span> <span class="main">(</span>hd <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">/</span> 
         real <span class="main">(</span>card <span class="main">(</span>permutations_of_multiset <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{#</span>hd <span class="skolem">xs</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> range_Cons hd_tl
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum.cong refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> pmf_map_inj_inv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">tl</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> real <span class="main">(</span>count <span class="free">A</span> <span class="main">(</span>hd <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">/</span> 
                      real <span class="main">(</span>card <span class="main">(</span>permutations_of_multiset <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{#</span>hd <span class="skolem">xs</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hd_tl <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.delta<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> hd_tl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> real <span class="main">(</span>size <span class="free">A</span><span class="main">)</span> <span class="main">/</span> real <span class="main">(</span>card <span class="main">(</span>permutations_of_multiset <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">divide_simps</span></span> real_card_permutations_of_multiset_remove<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"hd <span class="skolem">xs</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="main">…</span> <span class="main">/</span> real <span class="main">(</span>size <span class="free">A</span><span class="main">)</span> <span class="main">=</span> pmf <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="skolem">xs</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> assms True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Shuffling Lists›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define shuffling of a list as choosing from the set of all lists
  that correspond to the same multiset uniformly at random.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">shuffle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list pmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">shuffle</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="main">(</span>mset <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Fisher_Yates-shuffle_empty"><span class="command">lemma</span></span> shuffle_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shuffle <span class="main">[]</span> <span class="main">=</span> return_pmf <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shuffle_def pmf_of_set_singleton<span class="main">)</span>

<span class="keyword1" id="Fisher_Yates-shuffle_singleton"><span class="command">lemma</span></span> shuffle_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shuffle <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> return_pmf <span class="main">[</span><span class="free">x</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shuffle_def pmf_of_set_singleton<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The crucial ingredient of the Fisher--Yates shuffle is the following lemma,
  which decomposes a shuffle into swapping the first element of the list with 
  a random element of the remaining list and shuffling the new remaining list.

  With a random-access implementation of a list -- such as an array -- all of
  the required operations are cheap and the resulting algorithm runs in linear 
  time. 
›</span></span>
<span class="keyword1" id="Fisher_Yates-shuffle_fisher_yates_step"><span class="command">lemma</span></span> shuffle_fisher_yates_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xs_nonempty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"shuffle <span class="free">xs</span> <span class="main">=</span>  
           <span class="keyword1">do</span> <span class="main">{</span><span class="bound">i</span> <span class="main">←</span> pmf_of_set <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">;</span> 
               <span class="keyword1">let</span> <span class="bound">ys</span> <span class="main">=</span> swap <span class="free">xs</span> <span class="main">0</span> <span class="bound">i</span><span class="main">;</span> 
               <span class="bound">zs</span> <span class="main">←</span> shuffle <span class="main">(</span>tl <span class="bound">ys</span><span class="main">)</span><span class="main">;</span>
               return_pmf <span class="main">(</span>hd <span class="bound">ys</span> <span class="main">#</span> <span class="bound">zs</span><span class="main">)</span>
              <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"shuffle <span class="free">xs</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> pmf_of_multiset <span class="main">(</span>mset <span class="free">xs</span><span class="main">)</span><span class="main">;</span>
             <span class="bound">xs</span> <span class="main">←</span> pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="main">(</span>mset <span class="free">xs</span> <span class="main">-</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
             return_pmf <span class="main">(</span><span class="bound">x</span><span class="main">#</span><span class="bound">xs</span><span class="main">)</span>
            <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> shuffle_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_of_set_permutations_of_multiset_nonempty<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf_of_multiset <span class="main">(</span>mset <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
               pmf_of_multiset <span class="main">(</span>image_mset <span class="main">(</span><span class="main">(!)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>mset <span class="main">(</span>upt <span class="main">0</span> <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> mset_map <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_nth<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">(!)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_pmf_of_set<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_of_set atLeast0LessThan lessThan_empty_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span><span class="bound">x</span> <span class="main">←</span> map_pmf <span class="main">(</span><span class="main">(!)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                 <span class="bound">ys</span> <span class="main">←</span> pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="main">(</span>mset <span class="free">xs</span> <span class="main">-</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                 return_pmf <span class="main">(</span><span class="bound">x</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span>
                <span class="main">}</span> <span class="main">=</span> 
             <span class="keyword1">do</span> <span class="main">{</span><span class="bound">i</span> <span class="main">←</span> pmf_of_set <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">;</span>
                 <span class="bound">ys</span> <span class="main">←</span> pmf_of_set <span class="main">(</span>permutations_of_multiset <span class="main">(</span>mset <span class="free">xs</span> <span class="main">-</span> <span class="main">{#</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">#}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                 return_pmf <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span>
                <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_def bind_assoc_pmf bind_return_pmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">i</span> <span class="main">←</span> pmf_of_set <span class="main">{..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">;</span>
                      <span class="keyword1">let</span> <span class="bound">ys</span> <span class="main">=</span> swap <span class="free">xs</span> <span class="main">0</span> <span class="bound">i</span><span class="main">;</span> 
                      <span class="bound">zs</span> <span class="main">←</span> shuffle <span class="main">(</span>tl <span class="main">(</span>swap <span class="free">xs</span> <span class="main">0</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span>hd <span class="bound">ys</span> <span class="main">#</span> <span class="bound">zs</span><span class="main">)</span>
                     <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def shuffle_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_pmf_of_set<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lessThan_empty_iff mset_tl mset_swap hd_swap_0<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Forward Fisher-Yates Shuffle›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The actual Fisher--Yates shuffle is now merely a kind of tail-recursive version of
  decomposition described above. Note that unlike the traditional Fisher--Yates shuffle, 
  we shuffle the list from front to back, which is the more natural way to do it when 
  working with linked lists.
›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">fisher_yates_aux</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fisher_yates_aux</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">+</span> <span class="main">1</span> <span class="main">≥</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> return_pmf <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> 
     <span class="keyword1">do</span> <span class="main">{</span><span class="bound">j</span> <span class="main">←</span> pmf_of_set <span class="main">{</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">..&lt;</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">}</span><span class="main">;</span>
         <span class="free">fisher_yates_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>swap <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="bound">j</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"Wellfounded.measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">xs</span><span class="main">)</span><span class="main">.</span> length <span class="bound">xs</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">declare</span></span> fisher_yates_aux.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="Fisher_Yates-fisher_yates_aux_correct"><span class="command">lemma</span></span> fisher_yates_aux_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fisher_yates_aux <span class="free">i</span> <span class="free">xs</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> take <span class="free">i</span> <span class="free">xs</span> <span class="main">@</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>shuffle <span class="main">(</span>drop <span class="free">i</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fisher_yates_aux.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≥</span> length <span class="skolem">xs</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≥</span> length <span class="skolem">xs</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">=</span> Suc <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> length <span class="skolem">xs</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> butlast <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span>last <span class="skolem">xs</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> append_butlast_last_id <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"butlast <span class="skolem">xs</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> butlast_conv_take i<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"take <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span>last <span class="skolem">xs</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">@</span> drop <span class="skolem">i</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"take <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span>last <span class="skolem">xs</span><span class="main">]</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">@</span> drop <span class="skolem">i</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> trans<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"drop <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="main">[</span>last <span class="skolem">xs</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> same_append_eq<span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq fisher_yates_aux.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fisher_yates_aux.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> xs_nonempty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fisher_yates_aux <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">=</span> 
             pmf_of_set <span class="main">{</span><span class="skolem">i</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">}</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> fisher_yates_aux <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span>swap <span class="skolem">xs</span> <span class="skolem">i</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fisher_yates_aux.simps<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">i</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span>length <span class="skolem">xs</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessThan_atLeast0<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf_of_set <span class="main">…</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span>length <span class="skolem">xs</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_pmf_of_set_inj<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessThan_empty_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">-</span> <span class="skolem">i</span> <span class="main">=</span> length <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span>length <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">⤜</span>
                   <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> fisher_yates_aux <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>swap <span class="skolem">xs</span> <span class="skolem">i</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
               pmf_of_set <span class="main">{..&lt;</span>length <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">}</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> fisher_yates_aux <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>swap <span class="skolem">xs</span> <span class="skolem">i</span> <span class="main">(</span><span class="bound">j</span><span class="main">+</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_def bind_return_pmf bind_assoc_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">j</span> <span class="main">←</span> pmf_of_set <span class="main">{..&lt;</span>length <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
                        <span class="keyword1">let</span> <span class="bound">ys</span> <span class="main">=</span> swap <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">0</span> <span class="bound">j</span><span class="main">;</span>
                        <span class="bound">zs</span> <span class="main">←</span> shuffle <span class="main">(</span>tl <span class="bound">ys</span><span class="main">)</span><span class="main">;</span>
                        return_pmf <span class="main">(</span>take <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">@</span> hd <span class="bound">ys</span> <span class="main">#</span> <span class="bound">zs</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> bind_pmf <span class="main">_</span> <span class="var">?T</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> set_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span>length <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword1"><span class="command">have</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessThan_empty_iff<span class="main">)</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> swap <span class="skolem">xs</span> <span class="skolem">i</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fisher_yates_aux <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">(@)</span> <span class="main">(</span>take <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>shuffle <span class="main">(</span>drop <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> False j <span class="keyword1"><span class="command">unfolding</span></span> ys_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> <span class="quoted">"1.IH"</span><span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"take <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="skolem">ys</span> <span class="main">@</span> <span class="main">[</span>hd <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">]</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ys_def take_hd_drop<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"drop <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">=</span> tl <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ys_def tl_drop drop_Suc<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"drop <span class="skolem">i</span> <span class="skolem">ys</span> <span class="main">=</span> swap <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">0</span> <span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ys_def swap_def drop_update_swap add_ac<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False j <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"take <span class="skolem">i</span> <span class="skolem">ys</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="skolem">xs</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ys_def swap_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fisher_yates_aux <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="var">?T</span> <span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ys_def map_pmf_def Let_def bind_assoc_pmf bind_return_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">zs</span><span class="main">.</span> take <span class="skolem">i</span> <span class="skolem">xs</span> <span class="main">@</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">(</span>shuffle <span class="main">(</span>drop <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> shuffle_fisher_yates_step<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"drop <span class="skolem"><span class="skolem"><span class="skolem">i</span></span></span> <span class="skolem"><span class="skolem"><span class="skolem">xs</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_def Let_def bind_return_pmf bind_assoc_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fisher_yates</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fisher_yates</span> <span class="main">=</span> fisher_yates_aux <span class="main">0</span>"</span></span>

<span class="keyword1" id="Fisher_Yates-fisher_yates_correct"><span class="command">lemma</span></span> fisher_yates_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"fisher_yates <span class="free">xs</span> <span class="main">=</span> shuffle <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fisher_yates_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fisher_yates_aux_correct<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_def bind_return_pmf'<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Backwards Fisher-Yates Shuffle›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We can now easily derive the classical Fisher--Yates shuffle, which goes through 
  the list from back to front and show its equivalence to the forward Fisher--Yates
  shuffle.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">fisher_yates_alt_aux</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fisher_yates_alt_aux</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> return_pmf <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> 
     <span class="keyword1">do</span> <span class="main">{</span><span class="bound">j</span> <span class="main">←</span> pmf_of_set <span class="main">{..</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">}</span><span class="main">;</span>
         <span class="free">fisher_yates_alt_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>swap <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="bound">j</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> fisher_yates_alt_aux.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="Fisher_Yates-fisher_yates_alt_aux_altdef"><span class="command">lemma</span></span> fisher_yates_alt_aux_altdef<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> fisher_yates_alt_aux <span class="free">i</span> <span class="free">xs</span> <span class="main">=</span> 
     map_pmf rev <span class="main">(</span>fisher_yates_aux <span class="main">(</span>length <span class="free">xs</span> <span class="main">-</span> <span class="free">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fisher_yates_alt_aux.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">i</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted">"1.prems"</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf rev <span class="main">(</span>fisher_yates_aux <span class="main">(</span>length <span class="skolem">xs</span> <span class="main">-</span> <span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>rev <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
      pmf_of_set <span class="main">{</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">}</span> <span class="main">⤜</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fisher_yates_aux <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>swap <span class="main">(</span>rev <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⤜</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> return_pmf <span class="main">(</span>rev <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fisher_yates_aux.simps<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_pmf_def bind_return_pmf bind_assoc_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.prems"</span> False 
      <span class="keyword1"><span class="command">have</span></span> bij<span class="main">:</span> <span class="quoted"><span class="quoted">"bij_betw <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="bound">j</span><span class="main">)</span> <span class="main">{..</span><span class="skolem">i</span><span class="main">}</span> <span class="main">{</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bij_betwI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">j</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> length <span class="skolem"><span class="skolem"><span class="skolem">xs</span></span></span> <span class="main"><span class="main"><span class="main">-</span></span></span> Suc <span class="bound"><span class="bound"><span class="bound">j</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> bij <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">..&lt;</span>length <span class="skolem">xs</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="bound">j</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..</span><span class="skolem">i</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bij_betw_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> bij <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf_of_set <span class="main">…</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="bound">j</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..</span><span class="skolem">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_pmf_of_set_inj<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bij_betw_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="bound">j</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..</span><span class="skolem">i</span><span class="main">}</span><span class="main">)</span> <span class="main">⤜</span>
                 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fisher_yates_aux <span class="main">(</span>Suc <span class="main">(</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">(</span>swap <span class="main">(</span>rev <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>length <span class="skolem">xs</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> return_pmf <span class="main">(</span>rev <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
               pmf_of_set <span class="main">{..</span><span class="skolem">i</span><span class="main">}</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map_pmf rev <span class="main">(</span>
                 fisher_yates_aux <span class="main">(</span>length <span class="skolem">xs</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>rev <span class="main">(</span>swap <span class="skolem">xs</span> <span class="skolem">i</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.prems"</span> False
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_def bind_assoc_pmf bind_return_pmf Suc_diff_Suc
            swap_def rev_update rev_nth <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_pmf_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pmf_of_set <span class="main">{..</span><span class="skolem">i</span><span class="main">}</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> fisher_yates_alt_aux <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>swap <span class="skolem">xs</span> <span class="skolem">i</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.prems"</span> False <span class="quoted">"1.IH"</span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_pmf_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.prems"</span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fisher_yates_alt_aux <span class="skolem">i</span> <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fisher_yates_alt_aux.simps<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> <span class="quoted">"1.prems"</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fisher_yates_aux.simps fisher_yates_alt_aux.simps<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fisher_yates_alt</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fisher_yates_alt</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> fisher_yates_alt_aux <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Fisher_Yates-fisher_yates_alt_aux_correct"><span class="command">lemma</span></span> fisher_yates_alt_aux_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fisher_yates_alt <span class="free">xs</span> <span class="main">=</span> shuffle <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fisher_yates_alt_def fisher_yates_alt_aux.simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> fisher_yates_alt_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fisher_yates_alt_aux_altdef<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fisher_yates_aux_correct shuffle_def map_pmf_of_set_inj<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code generation test›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Isabelle's code generator allows us to produce executable code both for
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> shuffle<span class="antiquote"><span class="antiquote">}</span></span></span></span> and for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> fisher_yates<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> fisher_yates_alt<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  However, this code does not produce a random sample (i.e. a single randomly 
  permuted list) -- which is, in fact, the only purpose of the Fisher--Yates 
  algorithm -- but the entire probability distribution consisting of $n!$ 
  lists, each with probability $1/n!$.

  In the future, it would be nice if Isabelle also had some code generation 
  facility that supports generating sampling code.
›</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"shuffle <span class="inner_quoted">''abcd''</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"fisher_yates <span class="inner_quoted">''abcd''</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"fisher_yates_alt <span class="inner_quoted">''abcd''</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>