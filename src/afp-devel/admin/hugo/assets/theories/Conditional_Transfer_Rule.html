<div id="CTR_Tools">
<div class="head">
<h1>Theory CTR_Tools</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/CTR_Tools.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

A collection of basic Isabelle/ML functions for the CTR.
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Import›</span></span>
<span class="keyword1"><span class="command">theory</span></span> CTR_Tools 
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Standard library extension›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Library.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Binding.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Type.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Sort.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Term.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Variable.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Logic.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Thm.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Simplifier.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_HOLogic.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"More_Transfer.ML"</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Specialized functionality›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Utilities.ML"</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/More_Library.ML">
<div class="head">
<h1>File ‹More_Library.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Library.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Library from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">LIBRARY</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
    
  <span class="keyword1"><span class="keyword">include</span></span> LIBRARY
  
  <span class="comment1">(*pairs and triples*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> reroute_ps_sp <span class="main">:</span> <span class="main">(</span>'a * 'b<span class="main">)</span> * 'c <span class="main">-&gt;</span> 'a * <span class="main">(</span>'b * 'c<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> reroute_sp_ps <span class="main">:</span> 'a * <span class="main">(</span>'b * 'c<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> * 'c
  <span class="keyword1"><span class="keyword">val</span></span> reroute_ps_triple <span class="main">:</span> <span class="main">(</span>'a * 'b<span class="main">)</span> * 'c <span class="main">-&gt;</span> 'a * 'b * 'c  
  <span class="keyword1"><span class="keyword">val</span></span> reroute_sp_triple <span class="main">:</span> 'a * <span class="main">(</span>'b * 'c<span class="main">)</span> <span class="main">-&gt;</span> 'a * 'b * 'c
  <span class="keyword1"><span class="keyword">val</span></span> reroute_triple_ps <span class="main">:</span> 'a * 'b * 'c <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> * 'c  
  <span class="keyword1"><span class="keyword">val</span></span> reroute_triple_sp <span class="main">:</span> 'a * 'b * 'c <span class="main">-&gt;</span> 'a * <span class="main">(</span>'b * 'c<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> dup <span class="main">:</span> 'a <span class="main">-&gt;</span> 'a * 'a
  <span class="keyword1"><span class="keyword">val</span></span> apdupr <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'a * 'b
  <span class="keyword1"><span class="keyword">val</span></span> apdupl <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'b * 'a

  <span class="comment1">(*lists*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> map_slice_l <span class="main">:</span> <span class="main">(</span>'a list <span class="main">-&gt;</span> 'b list<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'a * 'c<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>'b * 'c<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> map_slice_r <span class="main">:</span> <span class="main">(</span>'a list <span class="main">-&gt;</span> 'b list<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'c * 'a<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>'c * 'b<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> map_slice_side_l <span class="main">:</span> 
    <span class="main">(</span>'a list <span class="main">-&gt;</span> 'b list * 'c<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'a * 'd<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>'b * 'd<span class="main">)</span> list * 'c
  <span class="keyword1"><span class="keyword">val</span></span> map_slice_side_r <span class="main">:</span> 
    <span class="main">(</span>'a list <span class="main">-&gt;</span> 'b list * 'c<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'d * 'a<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>'d * 'b<span class="main">)</span> list * 'c  
  <span class="keyword1"><span class="keyword">val</span></span> find_indices <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> int list

  <span class="comment1">(*strings*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> tabulate <span class="main">:</span> string <span class="main">-&gt;</span> string
  
  <span class="comment1">(*option*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_opt_id <span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b option<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'b

  <span class="comment1">(*keywords*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> kw_bo <span class="main">:</span> string parser
  <span class="keyword1"><span class="keyword">val</span></span> kw_bc <span class="main">:</span> string parser
  <span class="keyword1"><span class="keyword">val</span></span> kw_col <span class="main">:</span> string parser

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Library</span><span class="main">:</span> <span class="entity">LIBRARY</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Library<span class="main">;</span>


<span class="comment1">(** pairs and triples **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reroute_ps_sp</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reroute_sp_ps</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reroute_ps_triple</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reroute_sp_triple</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reroute_triple_ps</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reroute_triple_sp</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dup</span> <span class="entity">x</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apdupr</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">f</span> <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apdupl</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">=</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">;</span>


<span class="comment1">(** lists **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_slice_l</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">xs</span> 
  |&gt; split_list
  |&gt;&gt; <span class="entity">f</span>
  |&gt; <span class="keyword1"><span class="keyword">op</span></span>~~<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_slice_r</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">xs</span> 
  |&gt; split_list
  ||&gt; <span class="entity">f</span>
  |&gt; <span class="keyword1"><span class="keyword">op</span></span>~~<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_slice_side_l</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">xs</span> 
  |&gt; split_list
  |&gt;&gt; <span class="entity">f</span>
  |&gt; swap
  |&gt; <span class="entity">reroute_sp_ps</span>
  |&gt;&gt; swap  
  |&gt;&gt; <span class="keyword1"><span class="keyword">op</span></span>~~<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_slice_side_r</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span> <span class="entity">xs</span> 
  |&gt; split_list
  ||&gt; <span class="entity">f</span>
  |&gt; <span class="entity">reroute_sp_ps</span>
  |&gt;&gt; <span class="keyword1"><span class="keyword">op</span></span>~~<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_indices</span> <span class="entity">p</span> <span class="entity">xs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_indices_impl</span> <span class="main">_</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">find_indices_impl</span> <span class="entity">p</span> <span class="entity">i</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">p</span> <span class="entity">x</span> 
          <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">i</span>::<span class="entity">find_indices_impl</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">xs</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">find_indices_impl</span> <span class="entity">p</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">xs</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">find_indices_impl</span> <span class="entity">p</span> <span class="inner_numeral">0</span> <span class="entity">xs</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(** option **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_opt_id</span> <span class="entity">g</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">y</span> <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">g</span> <span class="entity">x</span><span class="main">;</span>


<span class="comment1">(** strings **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tabulate</span> <span class="main">=</span> split_lines #&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\t"</span> ^ <span class="entity">c</span><span class="main">)</span> #&gt; String.concatWith <span class="inner_quoted">"\n"</span>


<span class="comment1">(** shortcuts for common keywords **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">kw_bo</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">(</span>›</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">kw_bc</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">)</span>›</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">kw_col</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">:</span>›</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Library</span><span class="main">;</span></pre>
</div><div id="files/More_Binding.ML">
<div class="head">
<h1>File ‹More_Binding.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Binding.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Binding from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BINDING</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> BINDING
  <span class="keyword1"><span class="keyword">val</span></span> qualified_name_mandatory <span class="main">:</span> string <span class="main">-&gt;</span> binding
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Binding</span><span class="main">:</span> <span class="entity">BINDING</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Binding<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">qualified_name_mandatory</span> <span class="entity">c</span> <span class="main">=</span> fold
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">b</span> <span class="main">=&gt;</span> Binding.qualify_name true <span class="entity">b</span> <span class="entity">c</span><span class="main">)</span>
  <span class="main">(</span>Long_Name.explode <span class="entity">c</span><span class="main">)</span>
  Binding.empty<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Type.ML">
<div class="head">
<h1>File ‹More_Type.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Type.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Type from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TYPE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> TYPE
  <span class="keyword1"><span class="keyword">val</span></span> typ_matches <span class="main">:</span> tsig <span class="main">-&gt;</span> typ list * typ list <span class="main">-&gt;</span> tyenv <span class="main">-&gt;</span> tyenv
  <span class="keyword1"><span class="keyword">val</span></span> default_sorts_of_empty_sorts <span class="main">:</span> theory <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> default_sorts <span class="main">:</span> theory <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ
<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Type</span><span class="main">:</span> <span class="entity">TYPE</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Type<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_matches</span> <span class="entity">tsig</span> <span class="main">(</span><span class="entity">T</span> :: <span class="entity">Ts</span><span class="main">,</span> <span class="entity">U</span> :: <span class="entity">Us</span><span class="main">)</span> <span class="entity">subs</span> <span class="main">=</span> 
      <span class="entity">typ_matches</span> <span class="entity">tsig</span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">Us</span><span class="main">)</span> <span class="main">(</span>Type.typ_match <span class="entity">tsig</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="entity">subs</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">typ_matches</span> <span class="main">_</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">subs</span> <span class="main">=</span> <span class="entity">subs</span>
  <span class="main">|</span> <span class="entity">typ_matches</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Type.TYPE_MATCH<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">default_sorts_of_empty_sorts</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dS</span> <span class="main">=</span> Sign.defaultS <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map_atyps
      <span class="main">(</span>
        <span class="keyword1"><span class="keyword">fn</span></span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">dS</span><span class="main">)</span>
         <span class="main">|</span> TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">dS</span><span class="main">)</span>
         <span class="main">|</span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span>
         <span class="main">|</span> TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span> <span class="main">=&gt;</span> TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span>
      <span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">default_sorts</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dS</span> <span class="main">=</span> Sign.defaultS <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map_atyps
      <span class="main">(</span>
        <span class="keyword1"><span class="keyword">fn</span></span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> TFree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">dS</span><span class="main">)</span>
         <span class="main">|</span> TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> TVar <span class="main">(</span><span class="entity">xi</span><span class="main">,</span> <span class="entity">dS</span><span class="main">)</span>
      <span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Sort.ML">
<div class="head">
<h1>File ‹More_Sort.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Sort.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Sorts from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SORTS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> SORTS
  <span class="keyword1"><span class="keyword">val</span></span> params_of_super_classes <span class="main">:</span> theory <span class="main">-&gt;</span> class <span class="main">-&gt;</span> <span class="main">(</span>string * typ<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> params_of_sort <span class="main">:</span> theory <span class="main">-&gt;</span> class list <span class="main">-&gt;</span> <span class="main">(</span>string * typ<span class="main">)</span> list
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Sorts</span><span class="main">:</span> <span class="entity">SORTS</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Sorts<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">params_of_class</span> <span class="entity">thy</span> <span class="entity">class</span> <span class="main">=</span> 
  try <span class="main">(</span><span class="entity">Axclass.get_info</span> <span class="entity">thy</span> #&gt; <span class="main">#</span>params<span class="main">)</span> <span class="entity">class</span> |&gt; these<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">params_of_super_classes</span> <span class="entity">thy</span> <span class="entity">class</span> <span class="main">=</span>
  <span class="entity">class</span> :: Sorts.super_classes <span class="main">(</span>Sign.classes_of <span class="entity">thy</span><span class="main">)</span> <span class="entity">class</span> 
  |&gt; maps <span class="main">(</span><span class="entity">params_of_class</span> <span class="entity">thy</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">params_of_sort</span> <span class="entity">thy</span> <span class="entity">sort</span> <span class="main">=</span> maps <span class="main">(</span><span class="entity">params_of_super_classes</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">sort</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Term.ML">
<div class="head">
<h1>File ‹More_Term.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Term.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Term from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TERM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> TERM
  <span class="keyword1"><span class="keyword">val</span></span> map_sv <span class="main">:</span> <span class="main">(</span>indexname * typ <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> map_fv <span class="main">:</span> <span class="main">(</span>string * typ <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> map_const <span class="main">:</span> <span class="main">(</span>string * typ <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> map_tfree<span class="main">:</span> <span class="main">(</span>string * sort <span class="main">-&gt;</span> typ<span class="main">)</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> has_tfreesT <span class="main">:</span> typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_comb <span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> could_match_const <span class="main">:</span> <span class="main">(</span>''a * typ<span class="main">)</span> * <span class="main">(</span>''a * typ<span class="main">)</span> <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Term</span><span class="main">:</span> <span class="entity">TERM</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Term<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_sv</span> <span class="entity">f</span> <span class="main">(</span>Var <span class="entity">sv_spec</span><span class="main">)</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">sv_spec</span>
  <span class="main">|</span> <span class="entity">map_sv</span> <span class="entity">f</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">map_sv</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_sv</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">map_sv</span> <span class="entity">f</span> <span class="entity">t</span> $ <span class="entity">map_sv</span> <span class="entity">f</span> <span class="entity">u</span>
  <span class="main">|</span> <span class="entity">map_sv</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_fv</span> <span class="entity">f</span> <span class="main">(</span>Free <span class="entity">fv_spec</span><span class="main">)</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">fv_spec</span>
  <span class="main">|</span> <span class="entity">map_fv</span> <span class="entity">f</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">map_fv</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_fv</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">map_fv</span> <span class="entity">f</span> <span class="entity">t</span> $ <span class="entity">map_fv</span> <span class="entity">f</span> <span class="entity">u</span>
  <span class="main">|</span> <span class="entity">map_fv</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_const</span> <span class="entity">f</span> <span class="main">(</span>Const <span class="entity">const_spec</span><span class="main">)</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">const_spec</span>
  <span class="main">|</span> <span class="entity">map_const</span> <span class="entity">f</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">map_const</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_const</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">map_const</span> <span class="entity">f</span> <span class="entity">t</span> $ <span class="entity">map_const</span> <span class="entity">f</span> <span class="entity">u</span>
  <span class="main">|</span> <span class="entity">map_const</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map_type_tfree <span class="entity">f</span> <span class="entity">T</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map_type_tfree <span class="entity">f</span> <span class="entity">T</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Var <span class="main">(</span><span class="entity">v</span><span class="main">,</span> map_type_tfree <span class="entity">f</span> <span class="entity">T</span><span class="main">)</span> 
  <span class="main">|</span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> map_type_tfree <span class="entity">f</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="entity">t</span> $ <span class="entity">map_tfree</span> <span class="entity">f</span> <span class="entity">u</span>
  <span class="main">|</span> <span class="entity">map_tfree</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_tfreesT</span> <span class="main">(</span>TFree <span class="main">_</span><span class="main">)</span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">has_tfreesT</span> <span class="main">(</span>TVar <span class="main">_</span><span class="main">)</span> <span class="main">=</span> false
  <span class="main">|</span> <span class="entity">has_tfreesT</span> <span class="main">(</span>Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">has_tfreesT_list</span> <span class="entity">Ts</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">has_tfreesT_list</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> false
  <span class="main">|</span> <span class="entity">has_tfreesT_list</span> <span class="main">(</span><span class="entity">T</span>::<span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">has_tfreesT</span> <span class="entity">T</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">has_tfreesT_list</span> <span class="entity">Ts</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_comb</span> <span class="main">(</span><span class="main">_</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">is_comb</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">could_match_const</span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">c'</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
  <span class="entity">c</span> <span class="main">=</span> <span class="entity">c'</span> <span class="keyword1"><span class="keyword">andalso</span></span> Type.could_match <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Variable.ML">
<div class="head">
<h1>File ‹More_Variable.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Variable.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Variable from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">VARIABLE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> VARIABLE
  <span class="keyword1"><span class="keyword">val</span></span> fix_new_vars <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> variant_name_const <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> string list
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Variable</span><span class="main">:</span> <span class="entity">VARIABLE</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Variable<span class="main">;</span>

<span class="comment1">(*fix new variables*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fix_new_vars</span> <span class="entity">ctxt</span> <span class="entity">cs</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fix_new_vars_select</span> <span class="entity">c</span> <span class="entity">ctxt</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">if</span></span> Variable.is_fixed <span class="entity">ctxt</span> <span class="entity">c</span> 
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; Variable.add_fixes <span class="main">(</span>single <span class="entity">c</span><span class="main">)</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
  <span class="keyword2"><span class="keyword">in</span></span> fold_rev <span class="entity">fix_new_vars_select</span> <span class="entity">cs</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*invent new name variants with respect to the base names of constants*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">variant_name_const</span> <span class="entity">ctxt</span> <span class="entity">names</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>constants<span class="main">=</span><span class="entity">constants</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Consts.dest <span class="main">(</span>Proof_Context.consts_of <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_names</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; Long_Name.base_name<span class="main">)</span> <span class="entity">constants</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name_ctxt</span> <span class="main">=</span> <span class="entity">ctxt</span>
      |&gt; Variable.names_of
      |&gt; fold Name.declare <span class="entity">const_names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">folder</span> <span class="entity">name</span> <span class="main">(</span><span class="entity">names</span><span class="main">,</span> <span class="entity">name_ctxt</span><span class="main">)</span> <span class="main">=</span> 
          Name.variant <span class="entity">name</span> <span class="entity">name_ctxt</span> |&gt;&gt; curry <span class="main">(</span>swap #&gt; <span class="keyword1"><span class="keyword">op</span></span>::<span class="main">)</span> <span class="entity">names</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">name_ctxt</span><span class="main">)</span> |&gt; fold <span class="entity">folder</span> <span class="entity">names</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">names</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/More_Logic.ML">
<div class="head">
<h1>File ‹More_Logic.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Logic.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Logic from the standard library of Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">LOGIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> LOGIC
  <span class="keyword1"><span class="keyword">val</span></span> unvarify_types_local_term <span class="main">:</span> 
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> unvarify_local_term <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> varifyT_mixed_global <span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> varify_mixed_global <span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> unoverload_types_term <span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_equals <span class="main">:</span> term <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Logic</span> <span class="main">:</span> <span class="entity">LOGIC</span>  <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Logic<span class="main">;</span>

<span class="comment1">(*unvarify types in a local context*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_types_local_factt</span> <span class="entity">ctxt</span> <span class="entity">ts</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stv_specs</span> <span class="main">=</span> <span class="entity">ts</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thmt</span> <span class="main">=&gt;</span> Term.add_tvars <span class="entity">thmt</span> <span class="main">[</span><span class="main">]</span> |&gt; rev<span class="main">)</span>
      |&gt; flat
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> fold Proof_Context.augment <span class="entity">ts</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ftv_specs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Variable.invent_types <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">stv_specs</span><span class="main">)</span> <span class="entity">ctxt'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt''</span> <span class="main">=</span> fold Variable.declare_typ <span class="main">(</span>map TFree <span class="entity">ftv_specs</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stv_to_ftv</span> <span class="main">=</span> <span class="entity">stv_specs</span> ~~ <span class="entity">ftv_specs</span>
      |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> 
      #&gt; the
      #&gt; TFree
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span>map_types <span class="main">(</span>map_type_tvar <span class="entity">stv_to_ftv</span><span class="main">)</span><span class="main">)</span> <span class="entity">ts</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*unvarify types in a single term in a local context*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_types_local_term</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>
  |&gt; single
  |&gt; <span class="entity">unvarify_types_local_factt</span> <span class="entity">ctxt</span>
  |&gt;&gt; the_single<span class="main">;</span>

<span class="comment1">(*unvarify terms in a local context*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_local_factt</span> <span class="entity">ctxt</span> <span class="entity">ts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">unvarify_types_local_factt</span> <span class="entity">ctxt</span> <span class="entity">ts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sv_specs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thmt</span> <span class="main">=&gt;</span> Term.add_vars <span class="entity">thmt</span> <span class="main">[</span><span class="main">]</span> |&gt; rev<span class="main">)</span> <span class="entity">ts</span>
      |&gt; flat 
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stvcs</span> <span class="main">=</span> <span class="entity">sv_specs</span> |&gt; <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; map<span class="main">)</span>
      |&gt; <span class="entity">Variable.variant_name_const</span> <span class="entity">ctxt'</span>
      |&gt; rev
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ftvcs</span> <span class="main">=</span> Variable.variant_fixes <span class="entity">stvcs</span> <span class="entity">ctxt'</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt''</span> <span class="main">=</span> <span class="entity">ctxt'</span> |&gt; Variable.add_fixes <span class="entity">ftvcs</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stvc_to_ftvc</span> <span class="main">=</span> <span class="main">(</span><span class="entity">sv_specs</span> ~~ <span class="main">(</span><span class="entity">ftvcs</span> ~~ map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">sv_specs</span><span class="main">)</span><span class="main">)</span>
      |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>  
      #&gt; the
      #&gt; Free
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Term.map_sv</span> <span class="entity">stvc_to_ftvc</span><span class="main">)</span> <span class="entity">ts</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*unvarify a single term in a local context*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_local_term</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span>
  |&gt; single
  |&gt; <span class="entity">unvarify_local_factt</span> <span class="entity">ctxt</span>
  |&gt;&gt; the_single<span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ftvs_stvs_map</span> <span class="entity">svtcs</span> <span class="entity">stvs</span> <span class="main">=</span> <span class="entity">stvs</span>
  |&gt; map <span class="main">(</span><span class="entity">apdupr</span> <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span>
  |&gt; <span class="entity">map_slice_r</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">cs</span> <span class="main">=&gt;</span> Name.variant_list <span class="entity">svtcs</span> <span class="entity">cs</span><span class="main">)</span> 
  |&gt; map <span class="main">(</span>K <span class="inner_numeral">0</span> |&gt; <span class="entity">apdupr</span> |&gt; apsnd<span class="main">)</span>
  |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
  |&gt; map <span class="main">(</span>apsnd TVar<span class="main">)</span>
  |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> #&gt; the
 
<span class="keyword2"><span class="keyword">in</span></span>
 
<span class="comment1">(*varify a type that may have occurrences of both schematic and fixed 
type variables*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">varifyT_mixed_global</span> <span class="entity">T</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">svtcs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>Term.add_tvarsT <span class="entity">T</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ftvs_stvs_map</span> <span class="main">=</span> <span class="entity">ftvs_stvs_map</span> <span class="entity">svtcs</span> <span class="main">(</span>Term.add_tfreesT <span class="entity">T</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> Term.map_type_tfree <span class="entity">ftvs_stvs_map</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* varify a term that may have occurrences of both schematic and fixed 
variables and, also, both schematic and fixed type variables *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">varify_mixed_global</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">svtcs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>Term.add_tvars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ftvs_stvs_map</span> <span class="main">=</span> <span class="entity">ftvs_stvs_map</span> <span class="entity">svtcs</span> <span class="main">(</span>Term.add_tfrees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Term.map_tfree</span> <span class="entity">ftvs_stvs_map</span> <span class="entity">t</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">svcs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fvs_svs_map</span> <span class="main">=</span> Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span>
      |&gt; map <span class="main">(</span><span class="entity">apdupr</span> <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; <span class="entity">map_slice_r</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">cs</span> <span class="main">=&gt;</span> Name.variant_list <span class="entity">svcs</span> <span class="entity">cs</span><span class="main">)</span> 
      |&gt; map <span class="main">(</span>K <span class="inner_numeral">0</span> |&gt; <span class="entity">apdupr</span> |&gt; apsnd<span class="main">)</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>apsnd Var<span class="main">)</span>
      |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> #&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Term.map_fv</span> <span class="entity">fvs_svs_map</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*unoverload all types in a term*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unoverload_types_term</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort_consts</span> <span class="main">=</span> Term.add_tvars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span>
      |&gt; map <span class="main">#</span><span class="inner_numeral">2</span>
      |&gt; map <span class="main">(</span><span class="entity">Sorts.params_of_sort</span> <span class="entity">thy</span><span class="main">)</span>
      |&gt; flat
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_map</span> <span class="main">=</span> Term.add_consts <span class="entity">t</span> <span class="main">[</span><span class="main">]</span>
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
      |&gt; filter <span class="main">(</span>member <span class="entity">Term.could_match_const</span> <span class="entity">sort_consts</span><span class="main">)</span>
      |&gt; <span class="entity">dup</span>
      ||&gt; map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; Long_Name.base_name<span class="main">)</span>
      ||&gt; Name.variant_list <span class="main">(</span>Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span> |&gt; map <span class="main">#</span><span class="inner_numeral">1</span> |&gt; map <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span>
      |&gt; <span class="keyword1"><span class="keyword">op</span></span>~~
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">d</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">const_map_opt</span> <span class="entity">const_spec</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">const_map</span> <span class="entity">const_spec</span> <span class="keyword2"><span class="keyword">of</span></span> 
      SOME <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span> <span class="main">|</span> 
      NONE <span class="main">=&gt;</span> Const <span class="entity">const_spec</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">Term.map_const</span> <span class="entity">const_map_opt</span> <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t''</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>                     
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uctxt</span> <span class="main">=</span> Logic.unconstrainT <span class="main">[</span><span class="main">]</span> <span class="entity">t'</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
        <span class="comment1">(*Ported from Pure/Logic.ML with amendments*)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_atyps</span> <span class="main">=</span> 
          Term.map_atyps <span class="main">(</span><span class="entity">Type.default_sorts</span> <span class="entity">thy</span> o <span class="main">(</span><span class="main">#</span>atyp_map <span class="entity">uctxt</span><span class="main">)</span><span class="main">)</span>
        <span class="comment1">(*Ported from Pure/Logic.ML with amendments*)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t''</span> <span class="main">=</span> <span class="entity">t'</span>
          |&gt; Term.map_types <span class="entity">map_atyps</span>
          |&gt; curry Logic.list_implies <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="main">(</span><span class="main">#</span>constraints <span class="entity">uctxt</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> Logic.strip_imp_prems <span class="entity">t'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> drop <span class="main">(</span>length <span class="entity">prems</span> - Logic.count_prems <span class="entity">t'</span><span class="main">)</span> <span class="entity">prems</span>
      <span class="keyword2"><span class="keyword">in</span></span> Logic.list_implies <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> Logic.strip_imp_concl <span class="entity">t''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">t''</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(*equality*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_equals</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹Pure.eq›</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">is_equals</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Thm.ML">
<div class="head">
<h1>File ‹More_Thm.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Thm.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Thm from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">THM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> THM
  <span class="keyword1"><span class="keyword">val</span></span> unvarify_local_fact <span class="main">:</span> 
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> unvarify_local_thm <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> unvarify_local_thms <span class="main">:</span> 
    <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> tags_rule <span class="main">:</span> <span class="main">(</span>string * string<span class="main">)</span> list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> apply_attributes<span class="main">:</span> 
    attribute list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> Context.generic <span class="main">-&gt;</span> thm list * Context.generic 
  <span class="keyword1"><span class="keyword">val</span></span> forall_intr_var_order <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> pure_unfold <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Thm</span><span class="main">:</span> <span class="entity">THM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Thm<span class="main">;</span>

<span class="comment1">(* 
unvarify a fact in a local context (new (type) variables are 
fixed and declared in the context).
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_local_fact</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmts</span> <span class="main">=</span> map Thm.full_prop_of <span class="entity">thms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stv_specs</span> <span class="main">=</span> <span class="entity">thmts</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thmt</span> <span class="main">=&gt;</span> Term.add_tvars <span class="entity">thmt</span> <span class="main">[</span><span class="main">]</span> |&gt; rev<span class="main">)</span> 
      |&gt; flat
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> fold Proof_Context.augment <span class="entity">thmts</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ftv_specs</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> Variable.invent_types <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">stv_specs</span><span class="main">)</span> <span class="entity">ctxt'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'''</span> <span class="main">=</span> fold Variable.declare_typ <span class="main">(</span>map TFree <span class="entity">ftv_specs</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stv_to_ftv</span> <span class="main">=</span> <span class="entity">stv_specs</span> ~~ <span class="entity">ftv_specs</span> |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> #&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">instT</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">v</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">v</span> |&gt; <span class="entity">stv_to_ftv</span> |&gt; TFree<span class="main">)</span><span class="main">)</span> <span class="entity">stv_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sv_specs</span> <span class="main">=</span> <span class="entity">thmts</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thmt</span> <span class="main">=&gt;</span> Term.add_vars <span class="entity">thmt</span> <span class="main">[</span><span class="main">]</span> |&gt; rev<span class="main">)</span> 
      |&gt; flat 
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ftvcs</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stvcs</span> <span class="main">=</span> <span class="entity">sv_specs</span> 
          |&gt; map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span>
          |&gt; <span class="entity">Variable.variant_name_const</span> <span class="entity">ctxt''</span>
          |&gt; rev
      <span class="keyword2"><span class="keyword">in</span></span> Variable.variant_fixes <span class="entity">stvcs</span> <span class="entity">ctxt''</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt''''</span> <span class="main">=</span> Variable.add_fixes <span class="entity">ftvcs</span> <span class="entity">ctxt'''</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stvc_to_ftvc</span> <span class="main">=</span> AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="main">(</span><span class="entity">sv_specs</span> ~~ <span class="entity">ftvcs</span><span class="main">)</span> #&gt; the
      <span class="keyword2"><span class="keyword">in</span></span>
        map 
          <span class="main">(</span>
            <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">v</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T'</span> <span class="main">=</span> Term_Subst.instantiateT <span class="entity">instT</span> <span class="entity">T</span>
              <span class="keyword2"><span class="keyword">in</span></span> 
                <span class="main">(</span>
                  <span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span><span class="main">,</span> 
                  <span class="main">(</span><span class="main">(</span><span class="entity">stvc_to_ftvc</span> <span class="entity">v</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span> |&gt; Free |&gt; Thm.cterm_of <span class="entity">ctxt''''</span><span class="main">)</span>
                <span class="main">)</span> 
              <span class="keyword2"><span class="keyword">end</span></span>
          <span class="main">)</span>
          <span class="entity">sv_specs</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'''''</span> <span class="main">=</span> <span class="entity">ctxt''''</span>
      |&gt; fold Variable.declare_term <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> #&gt; Thm.term_of<span class="main">)</span> <span class="entity">insts</span><span class="main">)</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms'</span> <span class="main">=</span> 
      map 
        <span class="main">(</span>
          Drule.instantiate_normalize 
            <span class="main">(</span>map <span class="main">(</span>apsnd <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">instT</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span>
        <span class="main">)</span> 
        <span class="entity">thms</span>     
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">thms'</span><span class="main">,</span> <span class="entity">ctxt'''''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*unvarify a single theorem in a local context*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_local_thm</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span>
  |&gt; single
  |&gt; <span class="entity">unvarify_local_fact</span> <span class="entity">ctxt</span>
  |&gt;&gt; the_single<span class="main">;</span>

<span class="comment1">(*unvarify a list of theorems in a local context*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unvarify_local_thms</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">folder</span> <span class="entity">thm</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thm</span>
      |&gt; single
      |&gt; <span class="entity">unvarify_local_fact</span> <span class="entity">ctxt</span> 
      |&gt;&gt; the_single
      |&gt;&gt; curry <span class="main">(</span>swap #&gt; <span class="keyword1"><span class="keyword">op</span></span>::<span class="main">)</span> <span class="entity">thms</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> fold_rev <span class="entity">folder</span> <span class="entity">thms</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*add multiple tags*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tags_rule</span> <span class="entity">tgs</span> <span class="entity">thm</span> <span class="main">=</span> fold Thm.tag_rule <span class="entity">tgs</span> <span class="entity">thm</span><span class="main">;</span>

<span class="comment1">(*apply a list of attributes to a fact*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_attributes</span> <span class="entity">attrs</span> <span class="entity">thms</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_attributes_single</span> <span class="entity">attrs</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span> 
      fold 
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">attr</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">context</span><span class="main">)</span> <span class="main">=&gt;</span> Thm.apply_attribute <span class="entity">attr</span> <span class="entity">thm</span> <span class="entity">context</span><span class="main">)</span> 
      <span class="entity">attrs</span> 
      <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">context</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">folder</span> <span class="entity">thm</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">context</span><span class="main">)</span> <span class="main">=</span> <span class="entity">context</span>
      |&gt; <span class="entity">apply_attributes_single</span> <span class="entity">attrs</span> <span class="entity">thm</span> 
      |&gt;&gt; curry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span>:: o swap<span class="main">)</span> <span class="entity">thms</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> fold <span class="entity">folder</span> <span class="entity">thms</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">context</span><span class="main">)</span> |&gt;&gt; rev <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*introduction of the universally quantified variables with respect to a 
pre-defined order on the stvs*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forall_intr_var_order</span> <span class="entity">ctxt</span> <span class="entity">order</span> <span class="entity">thm'</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stvs</span> <span class="main">=</span> <span class="entity">thm'</span>
      |&gt; Thm.full_prop_of
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      |&gt; rev
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stv_cts</span> <span class="main">=</span> map <span class="main">(</span>nth <span class="entity">stvs</span> #&gt; Var #&gt; Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">order</span> 
  <span class="keyword2"><span class="keyword">in</span></span> fold Thm.forall_intr <span class="main">(</span>rev <span class="entity">stv_cts</span><span class="main">)</span> <span class="entity">thm'</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*low level unfold*)</span>
<span class="comment1">(*Designed based on an algorithm from HOL-Types_To_Sets/unoverload_def.ML*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pure_unfold</span> <span class="entity">ctxt</span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">ctxt</span>
  |&gt; 
    <span class="main">(</span>
      <span class="entity">thms</span>
      |&gt; Conv.rewrs_conv 
      |&gt; Conv.try_conv 
      |&gt; K
      |&gt; Conv.top_conv
    <span class="main">)</span>
  |&gt; Conv.fconv_rule<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Simplifier.ML">
<div class="head">
<h1>File ‹More_Simplifier.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Simplifier.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the functionality of the simplifier provided as part of
the standard library of Isabelle/Pure.

Notes:
  - The structure More_Simplifier was copied from the file 
  HOL/Types_To_Sets/Examples/Prerequisites.thy (with amendments)
*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">More_Simplifier</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">asm_full_var_simplify</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import false <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Simplifier.full_simplify</span> <span class="entity">ctxt'</span> <span class="entity">thm'</span>
    |&gt; singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
    |&gt; Drule.zero_var_indexes
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">var_simplify_only</span> <span class="entity">ctxt</span> <span class="entity">ths</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">asm_full_var_simplify</span> <span class="main">(</span>Raw_Simplifier.clear_simpset <span class="entity">ctxt</span> addsimps <span class="entity">ths</span><span class="main">)</span> <span class="entity">thm</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_simplified</span> <span class="main">=</span> <span class="entity">Attrib.thms</span> &gt;&gt;
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ths</span> <span class="main">=&gt;</span> Thm.rule_attribute <span class="entity">ths</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">context</span> <span class="main">=&gt;</span> <span class="entity">var_simplify_only</span> <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="entity">ths</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_simp_opt</span> <span class="entity">ctxt</span> <span class="entity">simp_spec_opt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">simp_spec_opt</span> <span class="keyword2"><span class="keyword">of</span></span> 
    SOME <span class="entity">simp_spec</span> <span class="main">=&gt;</span> <span class="entity">var_simplify_only</span> <span class="entity">ctxt</span> <span class="entity">simp_spec</span> 
  <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">Simplifier.full_simplify</span> <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_HOLogic.ML">
<div class="head">
<h1>File ‹More_HOLogic.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_HOLogic.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure HOLogic from the standard library of Isabelle/HOL.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">HOLOGIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">HOLOGIC</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_binrelT <span class="main">:</span> typ * typ <span class="main">-&gt;</span> typ 
  <span class="keyword1"><span class="keyword">val</span></span> is_binrelT <span class="main">:</span> typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> dest_binrelT <span class="main">:</span> typ <span class="main">-&gt;</span> typ * typ
  <span class="keyword1"><span class="keyword">val</span></span> mk_rel <span class="main">:</span> string * <span class="main">(</span>typ * typ<span class="main">)</span> <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_conj <span class="main">:</span> term <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">HOLogic</span><span class="main">:</span> <span class="entity">HOLOGIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> HOLogic<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binrelT</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">U</span> --&gt; <span class="entity">HOLogic.boolT</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_binrelT</span> <span class="main">(</span>
  Type <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹fun›</span><span class="main">,</span> <span class="main">[</span><span class="main">_</span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹fun›</span><span class="main">,</span> <span class="main">[</span><span class="main">_</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹bool›</span></span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
  <span class="main">)</span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">is_binrelT</span> <span class="main">_</span> <span class="main">=</span> false
 
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_binrelT</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹fun›</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span></span>‹fun›</span><span class="main">,</span> <span class="main">[</span><span class="entity">U</span><span class="main">,</span> <span class="main">_</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
      <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_binrelT</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE<span class="main">(</span><span class="inner_quoted">"dest_binrelT"</span><span class="main">,</span> single <span class="entity">T</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span> 

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rel</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">mk_binrelT</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_conj</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹conj›</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">is_conj</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/More_Transfer.ML">
<div class="head">
<h1>File ‹More_Transfer.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/More_Transfer.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

An extension of the structure Transfer from the standard library of 
Isabelle/Pure.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TRANSFER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">TRANSFER</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_is_equality <span class="main">:</span> term <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transfer</span><span class="main">:</span> <span class="entity">TRANSFER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Transfer<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_is_equality</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹is_equality›</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=</span> true
  <span class="main">|</span> <span class="entity">is_is_equality</span> <span class="main">_</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_Utilities.ML">
<div class="head">
<h1>File ‹CTR_Utilities.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Tools/CTR_Utilities.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

A collection of Isabelle/ML utilities for the CTR.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_UTILITIES</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">val</span></span> thm_printer <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> unit
<span class="keyword1"><span class="keyword">val</span></span> qualified_name_of_const_name <span class="main">:</span> string <span class="main">-&gt;</span> string
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Utilities</span> <span class="main">:</span> <span class="entity">CTR_UTILITIES</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_printer</span> <span class="entity">ctxt</span> <span class="entity">print</span> <span class="entity">name</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="entity">Proof_Display.print_results</span>
    <span class="entity">print</span>
    <span class="main">(</span>Position.thread_data <span class="main">(</span><span class="main">)</span><span class="main">)</span>
    <span class="entity">ctxt</span>
    <span class="main">(</span><span class="main">(</span>Thm.theoremK<span class="main">,</span> <span class="inner_quoted">""</span><span class="main">)</span><span class="main">,</span> single <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">qualified_name_of_const_name</span> <span class="entity">c</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">if</span></span> Long_Name.qualification <span class="entity">c</span> <span class="main">=</span> <span class="inner_numeral">0</span>
  <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"qualified_name_of_const_name: invalid constant name"</span>
  <span class="keyword2"><span class="keyword">else</span></span> 
    <span class="keyword2"><span class="keyword">if</span></span> Long_Name.qualification <span class="entity">c</span> <span class="main">=</span> <span class="inner_numeral">1</span> 
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">c</span> 
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">c</span> |&gt; Long_Name.explode |&gt; tl |&gt; Long_Name.implode

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="IML_UT">
<div class="head">
<h1>Theory IML_UT</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IML_UT/IML_UT.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>IML_UT›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">theory</span></span> IML_UT
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#CTR_Tools">../CTR_Tools/CTR_Tools</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹UT_Test_Suite.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/UT_Test_Suite.ML">
<div class="head">
<h1>File ‹UT_Test_Suite.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IML_UT/UT_Test_Suite.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

The implementation of a lightweight unit test framework IML_UT 
for Isabelle/ML code.

Notes:
 - The framework IML_UT was developed before the official release of SpecCheck
that serves a similar purpose (https://www.isa-afp.org/entries/SpecCheck.html).
Nonetheless, it is not unlikely that the author would be willing to make
the framework IML_UT obsolete, using SpecCheck in its place, in the future. 
 - To a certain extent, this work was inspired by xUnit (https://xunit.net/). 
*)</span>


<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UT_TEST_SUITE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_results_suite</span>
<span class="keyword1"><span class="keyword">val</span></span> init <span class="main">:</span> 
  string <span class="main">-&gt;</span> 
  <span class="main">(</span>'x <span class="main">-&gt;</span> 'y<span class="main">)</span> <span class="main">-&gt;</span> 
  <span class="main">(</span>'x <span class="main">-&gt;</span> string<span class="main">)</span> <span class="main">-&gt;</span> 
  <span class="main">(</span>'y <span class="main">-&gt;</span> string<span class="main">)</span> <span class="main">-&gt;</span> 
  <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span>
<span class="keyword1"><span class="keyword">val</span></span> assert_brel <span class="main">:</span> 
  string <span class="main">-&gt;</span> 
  <span class="main">(</span>'y * 'y <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 
  'y <span class="main">-&gt;</span> 'x <span class="main">-&gt;</span> 
  <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span> <span class="main">-&gt;</span> 
  <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span>
<span class="keyword1"><span class="keyword">val</span></span> assert_exception <span class="main">:</span> 
  string <span class="main">-&gt;</span> 'x <span class="main">-&gt;</span> exn <span class="main">-&gt;</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span> <span class="main">-&gt;</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span>
<span class="keyword1"><span class="keyword">val</span></span> execute <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span> <span class="main">-&gt;</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_results_suite</span>
<span class="keyword1"><span class="keyword">val</span></span> output_test_results <span class="main">:</span> bool <span class="main">-&gt;</span> <span class="main">(</span>'a<span class="main">,</span> 'b<span class="main">)</span> <span class="entity">test_results_suite</span> <span class="main">-&gt;</span> unit
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UT_Test_Suite</span><span class="main">:</span> <span class="entity">UT_TEST_SUITE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">exception</span></span> <span class="entity">BLANK</span><span class="main">;</span>



<span class="comment1">(**** Types ****)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> 'y <span class="entity">test_output</span> <span class="main">=</span> <span class="entity">Exception</span> <span class="keyword2"><span class="keyword">of</span></span> exn <span class="main">|</span> <span class="entity">Result</span> <span class="keyword2"><span class="keyword">of</span></span> 'y<span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> 'y <span class="entity">assertion_output</span> <span class="main">=</span>
  <span class="main">{</span>
    expected_output <span class="main">:</span> string<span class="main">,</span>
    output <span class="main">:</span> 'y <span class="entity">test_output</span><span class="main">,</span>
    status <span class="main">:</span> bool
  <span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_result</span> <span class="main">=</span>
  <span class="main">{</span>
    test_id <span class="main">:</span> int<span class="main">,</span> 
    name <span class="main">:</span> string<span class="main">,</span> 
    input <span class="main">:</span> 'x<span class="main">,</span> 
    assertion_output <span class="main">:</span> 'y <span class="entity">assertion_output</span>
  <span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">unit_test</span> <span class="main">=</span>
  <span class="main">{</span>
    test_id <span class="main">:</span> int<span class="main">,</span>
    name <span class="main">:</span> string<span class="main">,</span>
    input <span class="main">:</span> 'x<span class="main">,</span>
    assertion <span class="main">:</span> 'x <span class="main">-&gt;</span> 'y <span class="entity">assertion_output</span>
  <span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_results_suite</span> <span class="main">=</span> 
  <span class="main">{</span>
    id <span class="main">:</span> string<span class="main">,</span>
    function <span class="main">:</span> 'x <span class="main">-&gt;</span> 'y<span class="main">,</span>
    string_of_input <span class="main">:</span> 'x <span class="main">-&gt;</span> string<span class="main">,</span>
    string_of_output <span class="main">:</span> 'y <span class="main">-&gt;</span> string<span class="main">,</span>
    test_results <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_result</span> Queue.T
  <span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span> <span class="main">=</span> 
  <span class="main">{</span>
    id <span class="main">:</span> string<span class="main">,</span>
    function <span class="main">:</span> 'x <span class="main">-&gt;</span> 'y<span class="main">,</span>
    string_of_input <span class="main">:</span> 'x <span class="main">-&gt;</span> string<span class="main">,</span>
    string_of_output <span class="main">:</span> 'y <span class="main">-&gt;</span> string<span class="main">,</span>
    tests <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">unit_test</span> Queue.T
  <span class="main">}</span><span class="main">;</span>



<span class="comment1">(**** Initialization ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="entity">id</span> <span class="entity">f</span> <span class="entity">string_of_input</span> <span class="entity">string_of_output</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span> <span class="main">=</span> 
  <span class="main">{</span>
    id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span>
    function <span class="main">=</span> <span class="entity">f</span><span class="main">,</span>
    string_of_input <span class="main">=</span> <span class="entity">string_of_input</span><span class="main">,</span>
    string_of_output <span class="main">=</span> <span class="entity">string_of_output</span><span class="main">,</span>
    tests <span class="main">=</span> Queue.empty
  <span class="main">}</span><span class="main">;</span>



<span class="comment1">(**** Miscellaneous utilities ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_num_tests</span> <span class="entity">tests</span> <span class="main">=</span> length <span class="main">(</span>Queue.content <span class="entity">tests</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_empty_test_suite</span> <span class="entity">test_suite</span> <span class="main">=</span> Queue.is_empty <span class="main">(</span><span class="main">#</span>tests <span class="entity">test_suite</span><span class="main">)</span><span class="main">;</span>



<span class="comment1">(**** Evaluation ****)</span>

<span class="comment1">(* The following function evolved from the function try from 
Pure/General/basics.ML of Isabelle2021 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y_opt</span> <span class="main">=</span> try <span class="entity">f</span> <span class="entity">x</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">y_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">Result</span> <span class="entity">y</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">Exception</span>
          <span class="main">(</span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">BLANK</span> <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword3"><span class="keyword">handle</span></span> <span class="entity">exn</span> <span class="main">=&gt;</span> 
                <span class="keyword2"><span class="keyword">if</span></span> Exn.is_interrupt <span class="entity">exn</span> <span class="keyword2"><span class="keyword">then</span></span> Exn.reraise <span class="entity">exn</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">exn</span>
          <span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(**** Assertion of a binary relation ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_brel_impl</span> 
  <span class="entity">string_of_output</span> <span class="entity">brel</span> <span class="entity">test_id</span> <span class="entity">name</span> <span class="entity">y</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">unit_test</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assertion</span> <span class="entity">x</span> <span class="main">:</span> 'y <span class="entity">assertion_output</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">output</span> <span class="main">=</span> <span class="entity">eval</span> <span class="entity">f</span> <span class="entity">x</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">status</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">output</span> <span class="keyword2"><span class="keyword">of</span></span>
            <span class="entity">Exception</span> <span class="main">_</span> <span class="main">=&gt;</span> false
          <span class="main">|</span> <span class="entity">Result</span> <span class="entity">y'</span> <span class="main">=&gt;</span> <span class="entity">brel</span> <span class="main">(</span><span class="entity">y'</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
       <span class="main">{</span>
         expected_output <span class="main">=</span> <span class="entity">string_of_output</span> <span class="entity">y</span><span class="main">,</span>
         output <span class="main">=</span> <span class="entity">output</span><span class="main">,</span> 
         status <span class="main">=</span> <span class="entity">status</span>
       <span class="main">}</span> 
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">{</span>test_id <span class="main">=</span> <span class="entity">test_id</span><span class="main">,</span> name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> input <span class="main">=</span> <span class="entity">x</span><span class="main">,</span> assertion <span class="main">=</span> <span class="entity">assertion</span><span class="main">}</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_brel</span> <span class="entity">name</span> <span class="entity">brel</span> <span class="entity">y</span> <span class="entity">x</span> <span class="main">(</span><span class="entity">test_suite</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> <span class="main">#</span>function <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_input</span> <span class="main">=</span> <span class="main">#</span>string_of_input <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_output</span> <span class="main">=</span> <span class="main">#</span>string_of_output <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tests</span> <span class="main">=</span> <span class="main">#</span>tests <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_id</span> <span class="main">=</span> <span class="entity">get_num_tests</span> <span class="entity">tests</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test</span> <span class="main">=</span> <span class="entity">assert_brel_impl</span> <span class="entity">string_of_output</span> <span class="entity">brel</span> <span class="entity">test_id</span> <span class="entity">name</span> <span class="entity">y</span> <span class="entity">f</span> <span class="entity">x</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">{</span>
      id <span class="main">=</span> <span class="main">#</span>id <span class="entity">test_suite</span><span class="main">,</span>
      function <span class="main">=</span> <span class="entity">f</span><span class="main">,</span>
      string_of_input <span class="main">=</span> <span class="entity">string_of_input</span><span class="main">,</span>
      string_of_output <span class="main">=</span> <span class="entity">string_of_output</span><span class="main">,</span>
      tests <span class="main">=</span> Queue.enqueue <span class="entity">test</span> <span class="entity">tests</span>
    <span class="main">}</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(**** Assertion of an exception ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_exception_impl</span> <span class="entity">test_id</span> <span class="entity">name</span> <span class="main">(</span><span class="entity">exn</span> <span class="main">:</span> exn<span class="main">)</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">unit_test</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assertion</span> <span class="entity">x</span> <span class="main">:</span> 'y <span class="entity">assertion_output</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">output</span> <span class="main">=</span> <span class="entity">eval</span> <span class="entity">f</span> <span class="entity">x</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">status</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">output</span> <span class="keyword2"><span class="keyword">of</span></span> 
            <span class="entity">Exception</span> <span class="entity">exn'</span> <span class="main">=&gt;</span>
              exnName <span class="entity">exn'</span> <span class="main">=</span> exnName <span class="entity">exn</span> 
              <span class="keyword1"><span class="keyword">andalso</span></span> exnMessage <span class="entity">exn'</span> <span class="main">=</span> exnMessage <span class="entity">exn</span>
          <span class="main">|</span> <span class="entity">Result</span> <span class="main">_</span> <span class="main">=&gt;</span> false
     <span class="keyword2"><span class="keyword">in</span></span> 
       <span class="main">{</span>
         expected_output <span class="main">=</span> <span class="inner_quoted">"exception '"</span> ^ exnMessage <span class="entity">exn</span> ^ <span class="inner_quoted">"'"</span><span class="main">,</span>
         output <span class="main">=</span> <span class="entity">output</span><span class="main">,</span>
         status <span class="main">=</span> <span class="entity">status</span>
       <span class="main">}</span> 
     <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">{</span>test_id <span class="main">=</span> <span class="entity">test_id</span><span class="main">,</span> name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> input <span class="main">=</span> <span class="entity">x</span><span class="main">,</span> assertion <span class="main">=</span> <span class="entity">assertion</span><span class="main">}</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_exception</span> <span class="entity">name</span> <span class="entity">x</span> <span class="main">(</span><span class="entity">exn</span> <span class="main">:</span> exn<span class="main">)</span> <span class="main">(</span><span class="entity">test_suite</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> <span class="main">#</span>function <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_input</span> <span class="main">=</span> <span class="main">#</span>string_of_input <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_output</span> <span class="main">=</span> <span class="main">#</span>string_of_output <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tests</span> <span class="main">=</span> <span class="main">#</span>tests <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_id</span> <span class="main">=</span> <span class="entity">get_num_tests</span> <span class="entity">tests</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test</span> <span class="main">=</span> <span class="entity">assert_exception_impl</span> <span class="entity">test_id</span> <span class="entity">name</span> <span class="entity">exn</span> <span class="entity">f</span> <span class="entity">x</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="main">{</span>
      id <span class="main">=</span> <span class="main">#</span>id <span class="entity">test_suite</span><span class="main">,</span>
      function <span class="main">=</span> <span class="entity">f</span><span class="main">,</span>
      string_of_input <span class="main">=</span> <span class="entity">string_of_input</span><span class="main">,</span>
      string_of_output <span class="main">=</span> <span class="entity">string_of_output</span><span class="main">,</span>
      tests <span class="main">=</span> Queue.enqueue <span class="entity">test</span> <span class="entity">tests</span>
    <span class="main">}</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(**** Test execution ****)</span>

<span class="keyword2"><span class="keyword">local</span></span> 

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">execute_test</span> <span class="main">(</span><span class="entity">test_suite</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span><span class="main">)</span> <span class="main">:</span> 
  <span class="main">(</span><span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_result</span> * <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">function</span><span class="main">,</span> <span class="entity">string_of_input</span><span class="main">,</span> <span class="entity">string_of_output</span><span class="main">,</span> <span class="entity">tests</span><span class="main">}</span> <span class="main">=</span> <span class="entity">test_suite</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">test_id</span><span class="main">,</span> <span class="entity">name</span><span class="main">,</span> <span class="entity">input</span><span class="main">,</span> <span class="entity">assertion</span><span class="main">}</span><span class="main">,</span> <span class="entity">tests'</span><span class="main">)</span> <span class="main">=</span> Queue.dequeue <span class="entity">tests</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assertion_output</span> <span class="main">=</span> <span class="entity">assertion</span> <span class="entity">input</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_result</span> <span class="main">=</span> 
      <span class="main">{</span>
        test_id <span class="main">=</span> <span class="entity">test_id</span><span class="main">,</span> 
        name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> 
        input <span class="main">=</span> <span class="entity">input</span><span class="main">,</span>
        assertion_output <span class="main">=</span> <span class="entity">assertion_output</span>
      <span class="main">}</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_suite'</span> <span class="main">=</span> 
      <span class="main">{</span>
        id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> 
        function <span class="main">=</span> <span class="entity">function</span><span class="main">,</span> 
        string_of_input <span class="main">=</span> <span class="entity">string_of_input</span><span class="main">,</span> 
        string_of_output <span class="main">=</span> <span class="entity">string_of_output</span><span class="main">,</span> 
        tests <span class="main">=</span> <span class="entity">tests'</span>
      <span class="main">}</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">test_result</span><span class="main">,</span> <span class="entity">test_suite'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">execute</span> <span class="main">(</span><span class="entity">test_suite</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_suite</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">execute_impl</span> <span class="entity">test_results</span> <span class="entity">test_suite</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">test_result</span><span class="main">,</span> <span class="entity">test_suite'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">execute_test</span> <span class="entity">test_suite</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_results'</span> <span class="main">=</span> Queue.enqueue <span class="entity">test_result</span> <span class="entity">test_results</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_empty_test_suite</span> <span class="entity">test_suite'</span>
        <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">test_results'</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">execute_impl</span> <span class="entity">test_results'</span> <span class="entity">test_suite'</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_results</span> <span class="main">=</span> 
      <span class="main">{</span>
        id <span class="main">=</span> <span class="main">#</span>id <span class="entity">test_suite</span><span class="main">,</span>
        function <span class="main">=</span> <span class="main">#</span>function <span class="entity">test_suite</span><span class="main">,</span>
        string_of_input <span class="main">=</span> <span class="main">#</span>string_of_input <span class="entity">test_suite</span><span class="main">,</span>
        string_of_output <span class="main">=</span> <span class="main">#</span>string_of_output <span class="entity">test_suite</span><span class="main">,</span>
        test_results <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_empty_test_suite</span> <span class="entity">test_suite</span> 
          <span class="keyword2"><span class="keyword">then</span></span> Queue.empty 
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">execute_impl</span> Queue.empty <span class="entity">test_suite</span>
      <span class="main">}</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">test_results</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_results_suite</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(**** Output ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_message</span> 
  <span class="entity">string_of_input</span> <span class="entity">string_of_output</span> <span class="main">(</span><span class="entity">test_result</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_result</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_output'</span> <span class="main">(</span><span class="entity">Exception</span> <span class="entity">exn</span><span class="main">)</span> <span class="main">=</span>
        <span class="inner_quoted">"execution failed with the exception '"</span> ^ exnMessage <span class="entity">exn</span> ^ <span class="inner_quoted">"'"</span>
      <span class="main">|</span> <span class="entity">string_of_output'</span> <span class="main">(</span><span class="entity">Result</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="entity">string_of_output</span> <span class="entity">y</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test</span> <span class="main">=</span> <span class="inner_quoted">"Test "</span> ^ Int.toString <span class="main">(</span><span class="main">#</span>test_id <span class="entity">test_result</span><span class="main">)</span> ^ <span class="inner_quoted">"\n"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">function</span> <span class="main">=</span> <span class="inner_quoted">"Name: "</span> ^ <span class="main">#</span>name <span class="entity">test_result</span> ^ <span class="inner_quoted">"\n"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">input</span> <span class="main">=</span> 
      <span class="inner_quoted">"Input data:\n"</span> ^ 
      <span class="entity">tabulate</span> <span class="main">(</span><span class="entity">string_of_input</span> <span class="main">(</span><span class="main">#</span>input <span class="entity">test_result</span><span class="main">)</span><span class="main">)</span> ^ 
      <span class="inner_quoted">"\n"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">output</span> <span class="main">=</span> 
      <span class="inner_quoted">"Outcome:\n"</span> ^ 
      <span class="entity">tabulate</span> <span class="main">(</span><span class="entity">string_of_output'</span> <span class="main">(</span><span class="main">#</span>output <span class="main">(</span><span class="main">#</span>assertion_output <span class="entity">test_result</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> ^
      <span class="inner_quoted">"\n"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expected_output</span> <span class="main">=</span> 
      <span class="inner_quoted">"Expected outcome:\n"</span> ^ 
      <span class="entity">tabulate</span> <span class="main">(</span><span class="main">#</span>expected_output <span class="main">(</span><span class="main">#</span>assertion_output <span class="entity">test_result</span><span class="main">)</span><span class="main">)</span> ^ 
      <span class="inner_quoted">"\n"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_pass_flag</span> <span class="main">=</span> <span class="main">#</span>status <span class="main">(</span><span class="main">#</span>assertion_output <span class="entity">test_result</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">status</span> <span class="main">=</span> <span class="inner_quoted">"Test result: "</span> ^ <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">test_pass_flag</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"pass"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"fail"</span><span class="main">)</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> String.concatWith 
      <span class="inner_quoted">" "</span> <span class="main">[</span><span class="entity">test</span><span class="main">,</span> <span class="entity">function</span><span class="main">,</span> <span class="entity">input</span><span class="main">,</span> <span class="entity">output</span><span class="main">,</span> <span class="entity">expected_output</span><span class="main">,</span> <span class="entity">status</span><span class="main">]</span> 
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">test_pass_flag</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">output_test_results</span> 
  <span class="entity">error_flag</span> <span class="main">(</span><span class="entity">test_results_suite</span> <span class="main">:</span> <span class="main">(</span>'x<span class="main">,</span> 'y<span class="main">)</span> <span class="entity">test_results_suite</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="keyword1"><span class="keyword">val</span></span>
      <span class="main">{</span>
        id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span>
        string_of_input <span class="main">=</span> <span class="entity">string_of_input</span><span class="main">,</span>
        string_of_output <span class="main">=</span> <span class="entity">string_of_output</span><span class="main">,</span>
        test_results <span class="main">=</span> <span class="entity">test_results</span><span class="main">,</span>
        <span class="main">...</span>
      <span class="main">}</span> <span class="main">=</span> <span class="entity">test_results_suite</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_messages</span> <span class="entity">cs</span> <span class="entity">test_results</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> Queue.is_empty <span class="entity">test_results</span>
      <span class="keyword2"><span class="keyword">then</span></span> rev <span class="entity">cs</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">test_result</span><span class="main">,</span> <span class="entity">test_results'</span><span class="main">)</span> <span class="main">=</span> Queue.dequeue <span class="entity">test_results</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">test_pass_flag</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span> 
            <span class="entity">mk_message</span> <span class="entity">string_of_input</span> <span class="entity">string_of_output</span> <span class="entity">test_result</span>        
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_messages</span> <span class="main">(</span><span class="main">(</span><span class="entity">test_pass_flag</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span>::<span class="entity">cs</span><span class="main">)</span> <span class="entity">test_results'</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_results</span> <span class="main">=</span> <span class="entity">mk_messages</span> <span class="main">[</span><span class="main">]</span> <span class="entity">test_results</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heading_c</span> <span class="main">=</span> <span class="inner_quoted">"Test results for the test suite: "</span> ^ <span class="entity">id</span> ^ <span class="inner_quoted">"\n"</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_cs</span> <span class="main">=</span> map snd <span class="entity">test_results</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_tests</span> <span class="main">=</span> length <span class="entity">test_cs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_cs</span> <span class="main">=</span> <span class="entity">test_cs</span>
      |&gt; String.concatWith <span class="inner_quoted">"\n\n"</span>
      |&gt; single

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tests_failed</span> <span class="main">=</span> <span class="entity">test_results</span> 
      |&gt; map fst
      |&gt; map not
      |&gt; <span class="entity">find_indices</span> I
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_tests_failed</span> <span class="main">=</span> length <span class="entity">tests_failed</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_tests_passed</span> <span class="main">=</span> <span class="entity">num_tests</span> - <span class="entity">num_tests_failed</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">success_flag</span> <span class="main">=</span> <span class="entity">num_tests_failed</span> <span class="main">=</span> <span class="inner_numeral">0</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_tests_c</span> <span class="main">=</span> <span class="inner_quoted">"Number of tests: "</span> ^ Int.toString <span class="entity">num_tests</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_tests_passed_c</span> <span class="main">=</span> 
      <span class="inner_quoted">"Number of tests passed: "</span> ^ Int.toString <span class="entity">num_tests_passed</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_tests_failed_c</span> <span class="main">=</span> 
      <span class="inner_quoted">"Number of tests failed: "</span> ^ Int.toString <span class="entity">num_tests_failed</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">summary_c</span> <span class="main">=</span> 
      <span class="inner_quoted">"Test outcome: "</span> ^ 
      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">success_flag</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"success"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"failure"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">failed_tests_c</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">success_flag</span> 
      <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"\n"</span>
      <span class="keyword2"><span class="keyword">else</span></span> 
        <span class="main">(</span>
          <span class="inner_quoted">"Failed tests: "</span> ^
          ML_Syntax.print_list Int.toString <span class="entity">tests_failed</span> ^ 
          <span class="inner_quoted">"\n"</span>
        <span class="main">)</span> 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="main">(</span>
        <span class="entity">heading_c</span> :: 
        <span class="entity">num_tests_c</span> :: 
        <span class="entity">num_tests_passed_c</span> :: 
        <span class="entity">num_tests_failed_c</span> ::
        <span class="entity">summary_c</span> :: 
        <span class="entity">failed_tests_c</span> ::
        <span class="entity">test_cs</span>
      <span class="main">)</span>         
      |&gt; map Pretty.str
      |&gt; Pretty.chunks
      |&gt; Pretty.writeln

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span>not <span class="entity">error_flag</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">success_flag</span><span class="main">)</span> 
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"at least one of the "</span> ^ <span class="entity">id</span> ^ <span class="inner_quoted">" tests failed"</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="UD">
<div class="head">
<h1>Theory UD</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/UD.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Infrastructure for unoverloading definitions.
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹UD›</span></span>
<span class="keyword1"><span class="command">theory</span></span> UD
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#CTR_Tools">../CTR_Tools/CTR_Tools</a>"</span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"ud"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Import›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span><span class="quoted">‹UD_With.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span><span class="quoted">‹UD_Consts.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span><span class="quoted">‹UD.ML›</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ud_with›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">setup</span></span><span class="quoted">‹<span class="entity">UD_With.UDWithData.setup</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/UD_With.ML">
<div class="head">
<h1>File ‹UD_With.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/UD_With.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Database for the storage of the theorems that provide a relationship 
between the overloaded constants and the unoverloaded constants. 
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UD_WITH</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> UDWithData<span class="main">:</span> <span class="entity">NAMED_THMS</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UD_With</span> <span class="main">:</span> <span class="entity">UD_WITH</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UDWithData</span> <span class="main">=</span> <span class="entity">Named_Thms</span>
  <span class="main">(</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹ud_with›</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"Unoverloaded definitions"</span>
  <span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/UD_Consts.ML">
<div class="head">
<h1>File ‹UD_Consts.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/UD_Consts.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

The following infrastructure allows for the exclusion of arbitrary 
constants from being unoverloaded during the invocation of the
algorithm associated with the UD.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UD_CONSTS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> ConstsData <span class="main">:</span> THEORY_DATA
<span class="keyword1"><span class="keyword">val</span></span> const_of_key <span class="main">:</span> theory <span class="main">-&gt;</span> Symtab.key <span class="main">-&gt;</span> term option
<span class="keyword1"><span class="keyword">val</span></span> update_const <span class="main">:</span> Symtab.key <span class="main">-&gt;</span> term <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword1"><span class="keyword">val</span></span> remove_const <span class="main">:</span> Symtab.key <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword1"><span class="keyword">val</span></span> get_keys <span class="main">:</span> theory <span class="main">-&gt;</span> Symtab.key list

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UD_Consts</span> <span class="main">:</span> <span class="entity">UD_CONSTS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ConstsData</span> <span class="main">=</span> Theory_Data 
  <span class="main">(</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> term Symtab.table
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span>
  <span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_of_key</span> <span class="main">=</span> Symtab.lookup o ConstsData.get
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_const</span> <span class="entity">k</span> <span class="entity">v</span> <span class="main">=</span> ConstsData.map <span class="main">(</span>Symtab.update <span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_const</span> <span class="entity">k</span> <span class="main">=</span> ConstsData.map <span class="main">(</span>Symtab.delete <span class="entity">k</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_keys</span> <span class="main">=</span> Symtab.keys o ConstsData.get

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/UD.ML">
<div class="head">
<h1>File ‹UD.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/UD.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

The following file provides an implementation of the command ud.

The algorithm associated with the command ud draws inspiration and builds
upon the ideas associated with/expressed in 
  - The function Unoverload_Def.unoverload_def that was written by 
Fabian Immler and is available in the file HOL-Types_To_Sets/unoverload_def.ML 
in Isabelle2020. 
  - The conference proceedings article titled "A Mechanized Translation from 
Higher-Order Logic to Set Theory" written by Alexander Krauss and 
Andreas Schropp [1].

[1] Krauss A, Schropp A. A Mechanized Translation from Higher-Order Logic
to Set Theory. In: Kaufmann M, Paulson LC, editors. Interactive Theorem
Proving. Berlin: Springer; 2010. p. 323–38. 
(Lecture Notes in Computer Science; vol. 6172).
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ud_thm_out_type</span> <span class="main">=</span> <span class="entity">trivial</span> <span class="keyword2"><span class="keyword">of</span></span> thm <span class="main">|</span> <span class="entity">nontrivial</span> <span class="keyword2"><span class="keyword">of</span></span> thm * thm
<span class="keyword1"><span class="keyword">val</span></span> axioms_of_ci <span class="main">:</span> 
  theory <span class="main">-&gt;</span> Defs.T <span class="main">-&gt;</span> string * typ <span class="main">-&gt;</span> <span class="main">(</span>string option * string<span class="main">)</span> list
<span class="keyword1"><span class="keyword">val</span></span> das_of_ci <span class="main">:</span> theory <span class="main">-&gt;</span> Defs.T <span class="main">-&gt;</span> string * typ <span class="main">-&gt;</span> thm list
<span class="keyword1"><span class="keyword">val</span></span> unoverload_definition <span class="main">:</span> 
  binding * mixfix <span class="main">-&gt;</span> string * typ <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> <span class="entity">ud_thm_out_type</span> * theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UD</span> <span class="main">:</span> <span class="entity">UD</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>



<span class="comment1">(**** Auxiliary ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_unoverload_definition</span> <span class="entity">msg</span> <span class="main">=</span> <span class="inner_quoted">"ud: "</span> ^ <span class="entity">msg</span><span class="main">;</span>



<span class="comment1">(**** Data ****)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ud_thm_out_type</span> <span class="main">=</span> <span class="entity">trivial</span> <span class="keyword2"><span class="keyword">of</span></span> thm <span class="main">|</span> <span class="entity">nontrivial</span> <span class="keyword2"><span class="keyword">of</span></span> thm * thm



<span class="comment1">(**** Definitional Axioms ****)</span>

<span class="comment1">(*the implementation of axioms_of_ci and da_of_ci are based on elements of 
the code HOL/Types_To_Sets/unoverloading.ML*)</span>
<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_args</span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">Us</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> Type.could_matches <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">Us</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">then</span></span> 
    Option.map Envir.subst_type 
      <span class="main">(</span>
        SOME <span class="main">(</span>Type.raw_matches <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">Us</span><span class="main">)</span> Vartab.empty<span class="main">)</span> 
          <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> NONE
      <span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">axioms_of_ci</span> <span class="entity">thy</span> <span class="entity">defs</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_entry</span> <span class="main">=</span> Theory.const_dep <span class="entity">thy</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Uss</span> <span class="main">=</span> Defs.specifications_of <span class="entity">defs</span> <span class="main">(</span>fst <span class="entity">const_entry</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Uss</span>
    |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">spec</span> <span class="main">=&gt;</span> is_some <span class="main">(</span><span class="entity">match_args</span> <span class="main">(</span><span class="main">#</span>lhs <span class="entity">spec</span><span class="main">,</span> snd <span class="entity">const_entry</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Us</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">#</span>def <span class="entity">Us</span><span class="main">,</span> <span class="main">#</span>description <span class="entity">Us</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">das_of_ci</span> <span class="entity">thy</span> <span class="entity">defs</span> <span class="main">=</span> <span class="entity">axioms_of_ci</span> <span class="entity">thy</span> <span class="entity">defs</span>
  #&gt; map <span class="main">#</span><span class="inner_numeral">1</span>
  #&gt; filter is_some
  #&gt; map <span class="main">(</span>the #&gt; try <span class="main">(</span>Thm.axiom <span class="entity">thy</span><span class="main">)</span><span class="main">)</span>
  #&gt; filter is_some
  #&gt; map <span class="main">(</span>the #&gt; Drule.abs_def<span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(**** Main ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_no_cids</span> <span class="main">=</span> 
  <span class="entity">mk_msg_unoverload_definition</span> <span class="inner_quoted">"no suitable constant-instance definitions"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_ud_ex</span> <span class="main">=</span> 
  <span class="entity">mk_msg_unoverload_definition</span> <span class="inner_quoted">"unoverloaded constant already exists"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_multiple_cids</span> <span class="main">=</span> 
  <span class="entity">mk_msg_unoverload_definition</span> <span class="inner_quoted">"multiple constant-instance definitions"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_extra_type_variables</span> <span class="main">=</span> 
  <span class="entity">mk_msg_unoverload_definition</span> <span class="inner_quoted">"specification depends on extra type variables"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_sorts</span> <span class="entity">ctxt</span> <span class="entity">map_sortsT</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="entity">thm</span>
      |&gt; Thm.full_prop_of
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.add_tvars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">instTs</span> <span class="main">=</span> <span class="entity">Ts</span>
      |&gt; map TVar
      |&gt; map <span class="main">(</span>Term.map_atyps <span class="main">(</span><span class="entity">map_sortsT</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; map <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span><span class="main">)</span>
      |&gt; curry <span class="keyword1"><span class="keyword">op</span></span>~~ <span class="entity">Ts</span>
  <span class="keyword2"><span class="keyword">in</span></span> Drule.instantiate_normalize <span class="main">(</span><span class="entity">instTs</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trivial_ud</span> <span class="entity">thy</span> <span class="entity">b</span> <span class="entity">cid'</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">with_thm</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b'</span> <span class="main">=</span> Binding.qualify_name true <span class="entity">b</span> <span class="inner_quoted">"with"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">attr</span> <span class="main">=</span> single <span class="entity">UD_With.UDWithData.add</span>
      <span class="keyword2"><span class="keyword">in</span></span> Global_Theory.add_thm <span class="main">(</span><span class="main">(</span><span class="entity">b'</span><span class="main">,</span> <span class="entity">cid'</span><span class="main">)</span><span class="main">,</span> <span class="entity">attr</span><span class="main">)</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Thm.derivation_name <span class="entity">with_thm</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">with_thm</span>
        |&gt; single
        |&gt; <span class="entity">CTR_Utilities.thm_printer</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy'</span><span class="main">)</span> true <span class="entity">c</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">trivial</span> <span class="entity">with_thm</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nontrivial_ud</span> <span class="entity">thy</span> <span class="entity">defs</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="entity">cid</span> <span class="entity">T</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_with_thm</span> <span class="entity">thm_rhs_ct</span> <span class="entity">with_def_thm</span> <span class="entity">cid</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">with_def_thm_rhs_ct</span> <span class="main">=</span> <span class="entity">with_def_thm</span>
          |&gt; Thm.cprop_of
          |&gt; Thm.dest_equals_rhs
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Thm.match <span class="main">(</span><span class="entity">with_def_thm_rhs_ct</span><span class="main">,</span> <span class="entity">thm_rhs_ct</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_with_def</span> <span class="main">=</span> <span class="entity">with_def_thm</span>
          |&gt; Drule.instantiate_normalize <span class="entity">inst</span>
          |&gt; Thm.symmetric
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">with_thm</span> <span class="main">=</span> Thm.transitive <span class="entity">cid</span> <span class="entity">const_with_def</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">with_thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cid'</span> <span class="main">=</span> Thm.unvarify_global <span class="entity">thy</span> <span class="entity">cid</span> 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cid_rhs_ct</span> <span class="main">=</span> <span class="entity">cid'</span> |&gt; Thm.cprop_of |&gt; Thm.dest_equals_rhs

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cid_rhs_t</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">cid_rhs_ct</span>
      |&gt; Thm.term_of 
      |&gt; <span class="entity">Logic.unoverload_types_term</span> <span class="entity">thy</span>
      |&gt; <span class="entity">Logic.unvarify_types_local_term</span> <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_consts</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort_const_cs</span> <span class="main">=</span> Term.add_tvarsT <span class="entity">T</span> <span class="main">[</span><span class="main">]</span>
          |&gt; map <span class="main">#</span><span class="inner_numeral">2</span>
          |&gt; map <span class="main">(</span><span class="entity">Sorts.params_of_sort</span> <span class="entity">thy</span><span class="main">)</span>
          |&gt; flat
          |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
          |&gt; map <span class="main">#</span><span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consts</span> <span class="main">=</span> Term.add_consts <span class="entity">cid_rhs_t</span> <span class="main">[</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consts_no_cids</span> <span class="main">=</span> <span class="entity">consts</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">const</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">const</span><span class="main">,</span> <span class="entity">axioms_of_ci</span> <span class="entity">thy</span> <span class="entity">defs</span> <span class="entity">const</span><span class="main">)</span><span class="main">)</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">cid_opt</span><span class="main">)</span> <span class="main">=&gt;</span> null <span class="entity">cid_opt</span><span class="main">)</span>
          |&gt; map fst
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consts_in_sort</span> <span class="main">=</span> <span class="entity">consts</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Term.has_tfreesT</span> <span class="entity">T</span><span class="main">)</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> member <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">sort_const_cs</span> <span class="entity">c</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elim_consts</span> <span class="main">=</span> <span class="entity">thy</span>
          |&gt; <span class="entity">UD_Consts.get_keys</span>
          |&gt; map <span class="main">(</span><span class="entity">UD_Consts.const_of_key</span> <span class="entity">thy</span> #&gt; the #&gt; dest_Const<span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consts_out</span> <span class="main">=</span> <span class="entity">consts_no_cids</span> @ <span class="entity">consts_in_sort</span> 
          |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
          |&gt; filter_out <span class="main">(</span>member <span class="main">(</span>swap #&gt; <span class="entity">Term.could_match_const</span><span class="main">)</span> <span class="entity">elim_consts</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">consts_out</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cs</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt'</span>
      |&gt; Variable.variant_fixes <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; Long_Name.base_name<span class="main">)</span> <span class="entity">rhs_consts</span><span class="main">)</span> 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fv_of_const</span> <span class="main">=</span> 
      <span class="main">(</span>map Const <span class="entity">rhs_consts</span> ~~ map Free <span class="main">(</span><span class="entity">cs</span> ~~ map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">rhs_consts</span><span class="main">)</span><span class="main">)</span>
      |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
      |&gt; <span class="entity">mk_opt_id</span> I

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_const_ts</span> <span class="main">=</span> map Const <span class="entity">rhs_consts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_ts</span> <span class="main">=</span> map <span class="entity">fv_of_const</span> <span class="entity">rhs_const_ts</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cid_rhs_t'</span> <span class="main">=</span> map_aterms <span class="entity">fv_of_const</span> <span class="entity">cid_rhs_t</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_const_with</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> map type_of <span class="entity">arg_ts</span> ---&gt; type_of <span class="entity">cid_rhs_t'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b'</span> <span class="main">=</span> Binding.qualify_name true <span class="entity">b</span> <span class="inner_quoted">"with"</span>
      <span class="keyword2"><span class="keyword">in</span></span> Sign.declare_const_global <span class="main">(</span><span class="main">(</span><span class="entity">b'</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhst</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">declare_const_with</span> <span class="entity">thy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhst'</span> <span class="main">=</span> Term.list_comb <span class="main">(</span><span class="entity">lhst</span><span class="main">,</span> <span class="entity">arg_ts</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">with_def_thm</span><span class="main">,</span> <span class="entity">thy''</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b'</span> <span class="main">=</span> Binding.qualify_name true <span class="entity">b</span> <span class="inner_quoted">"with_def"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_t</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span><span class="entity">lhst'</span><span class="main">,</span> <span class="entity">cid_rhs_t'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        Global_Theory.add_defs false <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">b'</span><span class="main">,</span> <span class="entity">def_t</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span> <span class="entity">thy'</span> |&gt;&gt; the_single
          <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="entity">c</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_match</span> <span class="main">=</span> <span class="inner_quoted">"Specification depends on extra type variables"</span>
            <span class="keyword2"><span class="keyword">in</span></span> 
              <span class="keyword2"><span class="keyword">if</span></span> String.isSubstring <span class="entity">msg_match</span> <span class="entity">c</span>
              <span class="keyword2"><span class="keyword">then</span></span> error <span class="entity">msg_extra_type_variables</span> 
              <span class="keyword2"><span class="keyword">else</span></span> error <span class="entity">c</span> 
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Thm.derivation_name <span class="entity">with_def_thm</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">with_def_thm</span>
        |&gt; single
        |&gt; <span class="entity">CTR_Utilities.thm_printer</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy''</span><span class="main">)</span> true <span class="entity">c</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">with_thm</span><span class="main">,</span> <span class="entity">thy'''</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b'</span> <span class="main">=</span> Binding.qualify_name true <span class="entity">b</span> <span class="inner_quoted">"with"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">with_thm</span> <span class="main">=</span> <span class="entity">cid'</span> 
          |&gt; <span class="entity">mk_with_thm</span> <span class="entity">cid_rhs_ct</span> <span class="entity">with_def_thm</span>
          |&gt; singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt''</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">attr</span> <span class="main">=</span> single <span class="entity">UD_With.UDWithData.add</span>
      <span class="keyword2"><span class="keyword">in</span></span> Global_Theory.add_thm <span class="main">(</span><span class="main">(</span><span class="entity">b'</span><span class="main">,</span> <span class="entity">with_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">attr</span><span class="main">)</span> <span class="entity">thy''</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> Thm.derivation_name <span class="entity">with_thm</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="entity">with_thm</span>
        |&gt; single
        |&gt; <span class="entity">CTR_Utilities.thm_printer</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy'''</span><span class="main">)</span> true <span class="entity">c</span>
      <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">nontrivial</span> <span class="main">(</span><span class="entity">with_def_thm</span><span class="main">,</span> <span class="entity">with_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy'''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unoverload_definition</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>


    <span class="comment1">(*auxiliary*)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ud_const</span> <span class="entity">lr</span> <span class="entity">ud_thms</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_ud_const_impl</span> <span class="main">=</span> Thm.cprop_of
          #&gt; <span class="entity">lr</span>
          #&gt; Thm.term_of
          #&gt; strip_abs_body
          #&gt; head_of
          #&gt; dest_Const
      <span class="keyword2"><span class="keyword">in</span></span> map <span class="entity">get_ud_const_impl</span> <span class="entity">ud_thms</span> <span class="keyword2"><span class="keyword">end</span></span>


    <span class="comment1">(*main*)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defs</span> <span class="main">=</span> Theory.defs_of <span class="entity">thy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_thms</span> <span class="main">=</span> <span class="entity">ctxt</span>
      |&gt; <span class="entity">UD_With.UDWithData.get</span>
      |&gt; map <span class="main">(</span>Local_Defs.meta_rewrite_rule <span class="entity">ctxt</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T'</span> <span class="main">=</span> <span class="entity">T</span>
      |&gt; <span class="entity">Type.default_sorts_of_empty_sorts</span> <span class="entity">thy</span>
      |&gt; <span class="entity">Logic.varifyT_mixed_global</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_lhs_consts</span> <span class="main">=</span> <span class="entity">get_ud_const</span> Thm.dest_equals_lhs <span class="entity">ud_thms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex</span> <span class="main">=</span> member <span class="main">(</span>swap #&gt; <span class="entity">Term.could_match_const</span><span class="main">)</span> <span class="entity">ud_lhs_consts</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> not <span class="entity">ex</span> <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="entity">msg_ud_ex</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cids</span> <span class="main">=</span> <span class="entity">das_of_ci</span> <span class="entity">thy</span> <span class="entity">defs</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cid</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">cids</span> 
      <span class="keyword2"><span class="keyword">then</span></span> error <span class="entity">msg_no_cids</span>
      <span class="keyword2"><span class="keyword">else</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">cids</span> <span class="main">=</span> <span class="inner_numeral">1</span> 
        <span class="keyword2"><span class="keyword">then</span></span> the_single <span class="entity">cids</span> 
        <span class="keyword2"><span class="keyword">else</span></span> error <span class="entity">msg_multiple_cids</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cid'</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_const</span> <span class="main">=</span> <span class="entity">cid</span>
          |&gt; Thm.cprop_of
          |&gt; Thm.dest_equals_lhs
          |&gt; Thm.term_of
          |&gt; head_of
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">lhs_const</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T'</span><span class="main">)</span><span class="main">)</span>
          |&gt; apply2 <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span>
          |&gt; Thm.first_order_match
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="entity">cid</span>
        |&gt; Drule.instantiate_normalize <span class="entity">insts</span>
        |&gt; <span class="entity">map_sorts</span> <span class="entity">ctxt</span> <span class="entity">Type.default_sorts_of_empty_sorts</span>
        |&gt; Local_Defs.unfold <span class="entity">ctxt</span> <span class="entity">ud_thms</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cid_rhs_t</span> <span class="main">=</span> <span class="entity">cid'</span> 
      |&gt; Thm.cprop_of 
      |&gt; Thm.dest_equals_rhs
      |&gt; Thm.term_of 

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trivial_flag</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_rhs_consts</span> <span class="main">=</span> <span class="entity">get_ud_const</span> Thm.dest_equals_rhs <span class="entity">ud_thms</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">Term.is_comb</span> <span class="entity">cid_rhs_t</span>
        <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">cid_rhs_t</span> |&gt; head_of |&gt; is_Const
        <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">cid_rhs_t</span>
          |&gt; head_of
          |&gt; dest_Const
          |&gt; member <span class="main">(</span>swap #&gt; <span class="entity">Term.could_match_const</span><span class="main">)</span> <span class="entity">ud_rhs_consts</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ud_thm_out</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">trivial_flag</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">trivial_ud</span> <span class="entity">thy</span> <span class="entity">b</span> <span class="entity">cid'</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">nontrivial_ud</span> <span class="entity">thy</span> <span class="entity">defs</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="entity">cid'</span> <span class="entity">T'</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ud_thm_out</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(**** Interface ****)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_not_constant</span> <span class="main">=</span> 
  <span class="entity">mk_msg_unoverload_definition</span> <span class="inner_quoted">"the input term is not a constant"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ud</span> <span class="main">(</span><span class="main">(</span><span class="entity">b_opt</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">t'</span>
      <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> error <span class="entity">msg_not_constant</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">b_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">b</span> <span class="main">=&gt;</span> <span class="entity">b</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> Binding.name <span class="main">(</span>Long_Name.base_name <span class="entity">c</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">unoverload_definition</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">thy</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_ud</span> <span class="main">=</span> Scan.option Parse.binding -- Parse.const -- Parse.opt_mixfix'<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Outer_Syntax.command</span>
  <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">ud</span>›</span></span> 
  <span class="inner_quoted">"unoverloading of constant-instance definitions"</span>
  <span class="main">(</span><span class="entity">parse_ud</span> &gt;&gt; <span class="main">(</span><span class="entity">process_ud</span> #&gt; <span class="entity">Toplevel.theory</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="CTR">
<div class="head">
<h1>Theory CTR</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Infrastructure for the synthesis of the transfer rules and relativized 
constants.
*)</span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CTR›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">theory</span></span> CTR
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <span class="quoted">"<a href="#UD">../UD/UD</a>"</span>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Conditional_Parametricity.html">HOL-Library.Conditional_Parametricity</a>"</span>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"ctr_relator"</span> <span class="main">::</span> thy_defn
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"ctr"</span> <span class="main">::</span> thy_defn
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"trp"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"synthesis"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"relativization"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"hybrid"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"parametricity"</span>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Import›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Relators.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Foundations.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Algorithm.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Conversions.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Relativization.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Parametricity.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR_Postprocessing.ML"</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"CTR.ML"</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Rewriting›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> ctr_blank
<span class="keyword1"><span class="command">named_theorems</span></span> ctr_simps

<span class="keyword1" id="CTR-ctr_simps_pred_fun_top_eq_range"><span class="command">lemma</span></span> ctr_simps_pred_fun_top_eq_range<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pred_fun top <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="main">(</span>range <span class="free">f</span> <span class="main">⊆</span> <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_pred_prod_eq_cart"><span class="command">lemma</span></span> ctr_simps_pred_prod_eq_cart<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pred_prod <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">×</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_pred_fun_eq_image"><span class="command">lemma</span></span> ctr_simps_pred_fun_eq_image<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pred_fun <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">D</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">D</span> <span class="main">⊆</span> <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_in_iff"><span class="command">lemma</span></span> ctr_simps_in_iff<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">U</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_subset_pow_iff"><span class="command">lemma</span></span> ctr_simps_subset_pow_iff<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">A</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊆</span> <span class="free">U</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">S</span> <span class="main">⊆</span> Pow <span class="free">U</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_subset_pow_iff'"><span class="command">lemma</span></span> ctr_simps_subset_pow_iff'<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟶</span> <span class="bound">A</span> <span class="main">⊆</span> <span class="free">U</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">S</span> <span class="main">⊆</span> Pow <span class="free">U</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_subset_pow_iff''"><span class="command">lemma</span></span> ctr_simps_subset_pow_iff''<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">S</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="free">U</span><span class="main">}</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">S</span> <span class="main">⊆</span> Pow <span class="free">U</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span>
<span class="keyword1" id="CTR-ctr_simps_range_ss_iff"><span class="command">lemma</span></span> ctr_simps_range_ss_iff<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">U</span><span class="main">)</span> <span class="main">⟷</span> range <span class="free">f</span> <span class="main">⊆</span> <span class="free">U</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_range_pow_ss_iff"><span class="command">lemma</span></span> ctr_simps_range_pow_ss_iff<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">⊆</span> <span class="free">U</span><span class="main">)</span> <span class="main">⟷</span> range <span class="free">f</span> <span class="main">⊆</span> Pow <span class="free">U</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_Ball_def'"><span class="command">lemma</span></span> ctr_simps_Ball_def'<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_True_imp"><span class="command">lemma</span></span> ctr_simps_True_imp<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>True <span class="main">⟶</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_True_conj"><span class="command">lemma</span></span> ctr_simps_True_conj<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>True <span class="main">∧</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_conj_True"><span class="command">lemma</span></span> ctr_simps_conj_True<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">∧</span> True<span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_top_True"><span class="command">lemma</span></span> ctr_simps_top_True<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"top <span class="free">A</span> <span class="main">⟷</span> True"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_Ball_True"><span class="command">lemma</span></span> ctr_simps_Ball_True<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">U</span><span class="main">.</span> True<span class="main">)</span> <span class="main">⟷</span> True"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_Ball_UNIV"><span class="command">lemma</span></span> ctr_simps_Ball_UNIV<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">n</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free">A</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="free">A</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_Bex_UNIV"><span class="command">lemma</span></span> ctr_simps_Bex_UNIV<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free">A</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="free">A</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_subset_Pow"><span class="command">lemma</span></span> ctr_simps_subset_Pow<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊆</span> <span class="free">U</span><span class="main">}</span> <span class="main">=</span> Pow <span class="free">U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1" id="CTR-ctr_simps_mem_Collect_eq"><span class="command">lemma</span></span> ctr_simps_mem_Collect_eq<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">∈</span> Collect <span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mem_Collect_eq<span class="main">)</span>
<span class="keyword1" id="CTR-ctr_simps_relation_top_empty_eq"><span class="command">lemma</span></span> ctr_simps_relation_top_empty_eq<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> UNIV<span class="main">)</span> <span class="main">=</span> top"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_pred_fun_eq"><span class="command">lemma</span></span> ctr_simps_pred_fun_eq<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pred_fun <span class="free">A</span> <span class="free">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">B</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_subset_eq_sym"><span class="command">lemma</span></span> ctr_simps_subset_eq_sym<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_UNIV_I"><span class="command">lemma</span></span> ctr_simps_UNIV_I<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_UNIV_def"><span class="command">lemma</span></span> ctr_simps_UNIV_def<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">.</span> True<span class="main">}</span> <span class="main">=</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_conj_commute"><span class="command">lemma</span></span> ctr_simps_conj_commute<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="main">∧</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">Q</span> <span class="main">∧</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="CTR-ctr_simps_conj_absorb"><span class="command">lemma</span></span> ctr_simps_conj_absorb<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">∧</span> <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_conj_left_absorb"><span class="command">lemma</span></span> ctr_simps_conj_left_absorb<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">∧</span> <span class="free">A</span> <span class="main">∧</span> <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">A</span> <span class="main">∧</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_inf_idem"><span class="command">lemma</span></span> ctr_simps_inf_idem<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inf <span class="free">a</span> <span class="free">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>semilattice_inf<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_sup_idem"><span class="command">lemma</span></span> ctr_simps_sup_idem<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sup <span class="free">a</span> <span class="free">a</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>semilattice_sup<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1" id="CTR-ctr_simps_inf_assoc"><span class="command">lemma</span></span> ctr_simps_inf_assoc<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"inf <span class="main">(</span>inf <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">c</span> <span class="main">=</span> inf <span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>semilattice_inf<span class="main">)</span> <span class="main">(</span>inf <span class="free">b</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> semilattice_inf_class.inf.assoc<span class="main">)</span>
<span class="keyword1" id="CTR-ctr_simps_sup_assoc"><span class="command">lemma</span></span> ctr_simps_sup_assoc<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sup <span class="main">(</span>sup <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="free">c</span> <span class="main">=</span> sup <span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>semilattice_sup<span class="main">)</span> <span class="main">(</span>sup <span class="free">b</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> semilattice_sup_class.sup.assoc<span class="main">)</span>
<span class="keyword1" id="CTR-ctr_simps_Collect_mem_eq"><span class="command">lemma</span></span> ctr_simps_Collect_mem_eq<span class="main">[</span><span class="operator">ctr_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">U</span><span class="main">}</span> <span class="main">=</span> <span class="free">U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹tts relators›</span></span>

<span class="keyword1"><span class="command">ctr_relator</span></span> <span class="quoted">rel_set</span>
<span class="keyword1"><span class="command">ctr_relator</span></span> <span class="quoted">rel_filter</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/CTR_Relators.ML">
<div class="head">
<h1>File ‹CTR_Relators.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Relators.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Implementation of the functionality associated with the ctr relators,
including the command ctr_relator for registering the ctr relators. 
*)</span>


<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_RELATORS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">structure</span></span> RelatorData<span class="main">:</span> GENERIC_DATA
<span class="keyword1"><span class="keyword">val</span></span> get_relator_data_generic <span class="main">:</span> Context.generic <span class="main">-&gt;</span> RelatorData.T
<span class="keyword1"><span class="keyword">val</span></span> get_relator_data_proof <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> RelatorData.T
<span class="keyword1"><span class="keyword">val</span></span> get_relator_data_global <span class="main">:</span> theory <span class="main">-&gt;</span> RelatorData.T
<span class="keyword1"><span class="keyword">val</span></span> relator_of_generic <span class="main">:</span> Context.generic <span class="main">-&gt;</span> Symtab.key <span class="main">-&gt;</span> term option
<span class="keyword1"><span class="keyword">val</span></span> relator_of_proof <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> Symtab.key <span class="main">-&gt;</span> term option
<span class="keyword1"><span class="keyword">val</span></span> relator_of_global <span class="main">:</span> theory <span class="main">-&gt;</span> Symtab.key <span class="main">-&gt;</span> term option
<span class="keyword1"><span class="keyword">val</span></span> update_relator <span class="main">:</span> Symtab.key <span class="main">-&gt;</span> term <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory
<span class="keyword1"><span class="keyword">val</span></span> process_ctr_relator <span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> local_theory
<span class="keyword1"><span class="keyword">val</span></span> pr_of_typ <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span>string * sort<span class="main">)</span> * term<span class="main">)</span> list <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term
<span class="keyword1"><span class="keyword">val</span></span> bnf_relator_of_type_name <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term option
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Relators</span> <span class="main">:</span> <span class="entity">CTR_RELATORS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>




<span class="comment1">(**** Data ****)</span>



<span class="comment1">(*** Data container ***)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">RelatorData</span> <span class="main">=</span> Generic_Data
  <span class="main">(</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> term Symtab.table
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span>
  <span class="main">)</span><span class="main">;</span>
 

<span class="comment1">(*** Generic operations on the relator data ***)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_relator_data_generic</span> <span class="main">=</span> RelatorData.get<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_relator_data_proof</span> <span class="main">=</span> Context.Proof #&gt; <span class="entity">get_relator_data_generic</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_relator_data_global</span> <span class="main">=</span> Context.Theory #&gt; <span class="entity">get_relator_data_generic</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">relator_of_generic</span> <span class="entity">context</span> <span class="main">=</span> <span class="entity">context</span> 
  |&gt; <span class="entity">get_relator_data_generic</span> 
  |&gt; Symtab.lookup
  #&gt; 
    <span class="main">(</span>
      <span class="entity">context</span> 
      |&gt; Context.theory_of 
      |&gt; <span class="main">(</span>Morphism.transfer_morphism #&gt; Morphism.term<span class="main">)</span> 
      |&gt; Option.map
    <span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relator_of_proof</span> <span class="main">=</span> Context.Proof #&gt; <span class="entity">relator_of_generic</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relator_of_global</span> <span class="main">=</span> Context.Theory #&gt; <span class="entity">relator_of_generic</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_relator</span> <span class="entity">k</span> <span class="entity">rel</span> <span class="main">=</span> Local_Theory.declaration
  <span class="main">{</span>pervasive<span class="main">=</span>true<span class="main">,</span> syntax<span class="main">=</span>false<span class="main">}</span> 
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">k</span><span class="main">,</span> Morphism.term <span class="entity">phi</span> <span class="entity">rel</span><span class="main">)</span> |&gt; Symtab.update |&gt; RelatorData.map<span class="main">)</span><span class="main">;</span>




<span class="comment1">(**** User input analysis ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_ctr_relator</span> <span class="entity">msg</span> <span class="main">=</span> <span class="inner_quoted">"ctr_relator: "</span> ^ <span class="entity">msg</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_const</span> <span class="main">=</span> <span class="inner_quoted">"the input must be a constant term"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_body_bool</span> <span class="main">=</span> <span class="inner_quoted">"the body of the type of the input must be bool"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_binders_2</span> <span class="main">=</span> 
  <span class="inner_quoted">"the type of the input must have more than two binders"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_binders_binrelT</span> <span class="main">=</span> 
  <span class="inner_quoted">"all of the binders associated with the type of the input"</span> ^
  <span class="inner_quoted">"except the last two must be the binary relation types"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_no_dup_binrelT</span> <span class="main">=</span> 
  <span class="inner_quoted">"the types of the binders of the binary relations associated "</span> ^
  <span class="inner_quoted">"with the type of the input must have no duplicates"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_binders_binrelT_ftv_stv</span> <span class="main">=</span> 
  <span class="inner_quoted">"the types of the binders of the binary relation types associated "</span> ^
  <span class="inner_quoted">"with the input type must be either free type variables or "</span> ^
  <span class="inner_quoted">"schematic type variables"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_type_constructor</span> <span class="main">=</span> 
  <span class="inner_quoted">"the last two binders of the input type must be "</span> ^
  <span class="inner_quoted">"the results of an application of a type constructor"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_identical_type_constructors</span> <span class="main">=</span>
  <span class="inner_quoted">"the type constructors that are associated with the last two binders "</span> ^
  <span class="inner_quoted">"of the input type must be identical"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_msg_not_identical_input_types</span> <span class="main">=</span>
  <span class="inner_quoted">"the sequences of the input types to the type constructors that are "</span> ^
  <span class="inner_quoted">"associated with the last two binders of the input type must be "</span> ^
  <span class="inner_quoted">"identical to the sequences of the types formed by concatenating the "</span> ^
  <span class="inner_quoted">"type variables associated with the left hand side and the right "</span> ^
  <span class="inner_quoted">"hand side of the binary relation types, respectively"</span><span class="main">;</span>



<span class="comment1">(**** Command for the registration of ctr relators ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">relator_type_name_of_type</span> <span class="entity">T</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
  
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">T</span> |&gt; body_type |&gt; curry <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">HOLogic.boolT</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_body_bool</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders</span> <span class="main">=</span> binder_types <span class="entity">T</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="entity">binders</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">n</span> |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="entity">n</span> &gt; <span class="inner_numeral">2</span><span class="main">)</span> 
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_binders_2</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">relTs</span><span class="main">,</span> <span class="main">(</span><span class="entity">mainT_lhs</span><span class="main">,</span> <span class="entity">mainT_rhs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">binders</span>
      |&gt; chop <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">2</span><span class="main">)</span>
      ||&gt; chop <span class="inner_numeral">1</span>
      ||&gt; apfst the_single
      ||&gt; apsnd the_single

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">relTs</span> |&gt; map <span class="entity">HOLogic.is_binrelT</span> |&gt; List.all I
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_binders_binrelT</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs_tvars</span><span class="main">,</span> <span class="entity">rhs_tvars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">relTs</span> 
      |&gt; map <span class="entity">HOLogic.dest_binrelT</span>
      |&gt; split_list
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvars</span> <span class="main">=</span> <span class="entity">lhs_tvars</span> @ <span class="entity">rhs_tvars</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">tvars</span> |&gt; has_duplicates <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> |&gt; not
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_no_dup_binrelT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">tvars</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> is_TVar <span class="entity">T</span> <span class="keyword1"><span class="keyword">orelse</span></span> is_TFree <span class="entity">T</span><span class="main">)</span> |&gt; List.all I
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_binders_binrelT_ftv_stv</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_Type <span class="entity">mainT_lhs</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_type_constructor</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_Type <span class="entity">mainT_rhs</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_type_constructor</span><span class="main">)</span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mainT_lhs</span> <span class="main">=</span> dest_Type <span class="entity">mainT_lhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mainT_rhs</span> <span class="main">=</span> dest_Type <span class="entity">mainT_rhs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="main">(</span>apply2 <span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">mainT_lhs</span><span class="main">,</span> <span class="entity">mainT_rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_identical_type_constructors</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">lhs_tvars</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">mainT_lhs</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_identical_input_types</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">rhs_tvars</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">mainT_rhs</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_identical_input_types</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">mainT_lhs</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctr_relator</span> <span class="entity">args</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_Const <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_ctr_relator</span> <span class="entity">mk_msg_not_const</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">relator_type_name_of_type</span> <span class="main">(</span>type_of <span class="entity">t</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">update_relator</span> <span class="entity">c</span> <span class="entity">t</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Outer_Syntax.local_theory</span> 
  <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">ctr_relator</span>›</span></span> 
  <span class="inner_quoted">"registration of the ctr relators"</span>
  <span class="main">(</span>Parse.const &gt;&gt; <span class="entity">process_ctr_relator</span><span class="main">)</span><span class="main">;</span>




<span class="comment1">(**** ctr relators combined with the bnf relators ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bnf_relator_of_type_name</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bnf_relator_of_type_name</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relator_of_bnf</span> <span class="main">=</span> <span class="entity">BNF_Def.rel_of_bnf</span> 
          #&gt; strip_comb 
          #&gt; <span class="main">#</span><span class="inner_numeral">1</span>
          #&gt; dest_Const
          #&gt; <span class="main">#</span><span class="inner_numeral">1</span>
          #&gt; Syntax.read_term <span class="entity">ctxt</span>
          #&gt; Logic.varify_global
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">c</span> |&gt; <span class="entity">BNF_Def.bnf_of</span> <span class="entity">ctxt</span> |&gt; Option.map <span class="entity">relator_of_bnf</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">relator_of_proof</span> <span class="entity">ctxt</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">t</span> <span class="main">=&gt;</span> SOME <span class="entity">t</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">bnf_relator_of_type_name</span> <span class="entity">ctxt</span> <span class="entity">c</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Conversion of a type to a parametricity relation ****)</span>

<span class="comment1">(* 
The algorithm follows an outline of an algorithm for a similar purpose 
suggested in section 4.1 of the Ph.D. thesis of Ondřej Kunčar titled 
"Types, Abstraction and Parametric Polymorphism in Higher-Order Logic". 
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pr_of_typ</span> <span class="entity">ctxt</span> <span class="entity">ftv_spec_relt</span> <span class="entity">T</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pr_of_typ</span> <span class="main">_</span> <span class="entity">trel</span> <span class="main">(</span>TFree <span class="entity">ftv_spec</span><span class="main">)</span> <span class="main">=</span> <span class="entity">trel</span> <span class="entity">ftv_spec</span>
      <span class="main">|</span> <span class="entity">pr_of_typ</span> <span class="main">_</span> <span class="main">_</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
          Const 
            <span class="main">(</span>
              <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹HOL.eq›</span><span class="main">,</span> 
              <span class="entity">HOLogic.mk_binrelT</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
            <span class="main">)</span>
      <span class="main">|</span> <span class="entity">pr_of_typ</span> <span class="entity">relator_of_type_name</span> <span class="entity">trel</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constt</span> <span class="main">=</span> <span class="entity">relator_of_type_name</span> <span class="entity">c</span>
              <span class="keyword3"><span class="keyword">handle</span></span> Option <span class="main">=&gt;</span> 
                <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"pr_of_typ: no relator"</span><span class="main">,</span> <span class="main">[</span>Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> 
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constT</span> <span class="main">=</span> type_of <span class="entity">constt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binders</span> <span class="main">=</span> <span class="entity">constT</span> |&gt; binder_types |&gt; take <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argts</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">pr_of_typ</span> <span class="entity">relator_of_type_name</span> <span class="entity">trel</span><span class="main">)</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argTs</span> <span class="main">=</span> map type_of <span class="entity">argts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyenv_match</span> <span class="main">=</span> <span class="entity">Type.typ_matches</span> 
              <span class="main">(</span>Proof_Context.tsig_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">binders</span><span class="main">,</span> <span class="entity">argTs</span><span class="main">)</span> Vartab.empty
              <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> 
                <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"pr_of_typ: invalid relator"</span><span class="main">,</span> <span class="main">[</span>Type <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constt</span> <span class="main">=</span> <span class="entity">constt</span>
              |&gt; dest_Const
              ||&gt; K <span class="main">(</span>Envir.subst_type <span class="entity">tyenv_match</span> <span class="entity">constT</span><span class="main">)</span>
              |&gt; Const
          <span class="keyword2"><span class="keyword">in</span></span> list_comb <span class="main">(</span><span class="entity">constt</span><span class="main">,</span> <span class="entity">argts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">pr_of_typ</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"pr_of_typ: type"</span><span class="main">,</span> single <span class="entity">T</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trel</span> <span class="main">=</span> AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">ftv_spec_relt</span> #&gt; the
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">pr_of_typ</span> <span class="main">(</span><span class="entity">bnf_relator_of_type_name</span> <span class="entity">ctxt</span> #&gt; the<span class="main">)</span> <span class="entity">trel</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_Foundations.ML">
<div class="head">
<h1>File ‹CTR_Foundations.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Foundations.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Basic data types for CTR.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_FOUNDATIONS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctr_algorithm</span> <span class="main">=</span> <span class="entity">relativization</span> <span class="main">|</span> <span class="entity">parametricity</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctr_alg_out</span> <span class="main">=</span> 
  <span class="entity">ALGRelativization</span> <span class="keyword2"><span class="keyword">of</span></span> thm <span class="main">|</span> <span class="entity">ALGParametricity</span> <span class="keyword2"><span class="keyword">of</span></span> thm <span class="main">|</span> <span class="entity">ALGFailure</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctr_pp_out</span> <span class="main">=</span> 
    <span class="entity">PPRelativization</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>thm * thm<span class="main">)</span> * local_theory 
  <span class="main">|</span> <span class="entity">PPParametricity</span> <span class="keyword2"><span class="keyword">of</span></span> thm * local_theory
  <span class="main">|</span> <span class="entity">PPFailure</span> <span class="keyword2"><span class="keyword">of</span></span> local_theory<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> apply_alg_out <span class="main">:</span> <span class="main">(</span>thm <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">ctr_alg_out</span> <span class="main">-&gt;</span> <span class="entity">ctr_alg_out</span>
<span class="keyword1"><span class="keyword">val</span></span> lthy_of_pp_out <span class="main">:</span> <span class="entity">ctr_pp_out</span> <span class="main">-&gt;</span> local_theory 
<span class="keyword1"><span class="keyword">val</span></span> string_of_pp_out <span class="main">:</span>  <span class="entity">ctr_pp_out</span> <span class="main">-&gt;</span> string
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Foundations</span> <span class="main">:</span> <span class="entity">CTR_FOUNDATIONS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctr_algorithm</span> <span class="main">=</span> <span class="entity">relativization</span> <span class="main">|</span> <span class="entity">parametricity</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctr_alg_out</span> <span class="main">=</span> 
  <span class="entity">ALGRelativization</span> <span class="keyword2"><span class="keyword">of</span></span> thm <span class="main">|</span> <span class="entity">ALGParametricity</span> <span class="keyword2"><span class="keyword">of</span></span> thm <span class="main">|</span> <span class="entity">ALGFailure</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctr_pp_out</span> <span class="main">=</span> 
    <span class="entity">PPRelativization</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>thm * thm<span class="main">)</span> * local_theory 
  <span class="main">|</span> <span class="entity">PPParametricity</span> <span class="keyword2"><span class="keyword">of</span></span> thm * local_theory
  <span class="main">|</span> <span class="entity">PPFailure</span> <span class="keyword2"><span class="keyword">of</span></span> local_theory<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_alg_out</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">ALGRelativization</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ALGRelativization</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">thm</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">apply_alg_out</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">ALGParametricity</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ALGParametricity</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">thm</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">apply_alg_out</span> <span class="main">_</span> <span class="entity">ALGFailure</span> <span class="main">=</span> <span class="entity">ALGFailure</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lthy_of_pp_out</span> <span class="main">(</span><span class="entity">PPRelativization</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthy</span>
  <span class="main">|</span> <span class="entity">lthy_of_pp_out</span> <span class="main">(</span><span class="entity">PPParametricity</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthy</span>
  <span class="main">|</span> <span class="entity">lthy_of_pp_out</span> <span class="main">(</span><span class="entity">PPFailure</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthy</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_pp_out</span> <span class="main">(</span><span class="entity">PPRelativization</span> <span class="main">(</span><span class="main">(</span><span class="entity">ow_def_thm</span><span class="main">,</span> <span class="entity">tr_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">preamble_c</span> <span class="main">=</span> 
          <span class="inner_quoted">"PPRelativization ((ow_def_thm, tr_thm), lthy), where"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ow_def_thm_c</span> <span class="main">=</span> <span class="inner_quoted">"ow_def_thm: "</span> ^ Thm.string_of_thm <span class="entity">lthy</span> <span class="entity">ow_def_thm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tr_thm_c</span> <span class="main">=</span> <span class="inner_quoted">"tr_thm: "</span> ^ Thm.string_of_thm <span class="entity">lthy</span> <span class="entity">tr_thm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_c</span> <span class="main">=</span> <span class="inner_quoted">"lthy: unknown local theory"</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out_c</span> <span class="main">=</span> <span class="main">[</span><span class="entity">preamble_c</span><span class="main">,</span> <span class="entity">ow_def_thm_c</span><span class="main">,</span> <span class="entity">tr_thm_c</span><span class="main">,</span> <span class="entity">lthy_c</span><span class="main">]</span> 
          |&gt; String.concatWith <span class="inner_quoted">"\n"</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out_c</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">string_of_pp_out</span> <span class="main">(</span><span class="entity">PPParametricity</span> <span class="main">(</span><span class="entity">tr_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">preamble_c</span> <span class="main">=</span> <span class="inner_quoted">"PPParametricity (tr_thm, lthy), where"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tr_thm_c</span> <span class="main">=</span> <span class="inner_quoted">"tr_thm"</span> ^ Thm.string_of_thm <span class="entity">lthy</span> <span class="entity">tr_thm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_c</span> <span class="main">=</span> <span class="inner_quoted">"lthy: unknown local theory"</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out_c</span> <span class="main">=</span> <span class="main">[</span><span class="entity">preamble_c</span><span class="main">,</span> <span class="entity">tr_thm_c</span><span class="main">,</span> <span class="entity">lthy_c</span><span class="main">]</span> 
          |&gt; String.concatWith <span class="inner_quoted">"\n"</span>    
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out_c</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">string_of_pp_out</span> <span class="main">(</span><span class="entity">PPFailure</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"Failure"</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword3"><span class="keyword">open</span></span> CTR_Foundations<span class="main">;</span></pre>
</div><div id="files/CTR_Algorithm.ML">
<div class="head">
<h1>File ‹CTR_Algorithm.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Algorithm.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Abstract interface for the definition of an algorithm for the synthesis
of transfer rules and relativized definitions.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_ALGORITHM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">val</span></span> apply <span class="main">:</span> 
  <span class="entity">Proof.context</span> <span class="main">-&gt;</span>
  bool * thm list option <span class="main">-&gt;</span>
  thm list <span class="main">-&gt;</span>
  <span class="main">(</span><span class="main">(</span>indexname * sort<span class="main">)</span> * term<span class="main">)</span> list <span class="main">-&gt;</span>
  thm <span class="main">-&gt;</span> 
  <span class="entity">ctr_alg_out</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_Conversions.ML">
<div class="head">
<h1>File ‹CTR_Conversions.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Conversions.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Conversion of a transfer rule goal to a parametricity property goal.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_CONVERSIONS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">val</span></span> const_of_def <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> string * typ
<span class="keyword1"><span class="keyword">val</span></span> trt_of_const <span class="main">:</span> 
  <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="main">(</span>indexname * sort<span class="main">)</span> * term<span class="main">)</span> list <span class="main">-&gt;</span> string * typ <span class="main">-&gt;</span> term
<span class="keyword1"><span class="keyword">val</span></span> dest_trt <span class="main">:</span> term <span class="main">-&gt;</span> term * term * term
<span class="keyword1"><span class="keyword">val</span></span> prt_of_trt <span class="main">:</span> term <span class="main">-&gt;</span> term

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Conversions</span> <span class="main">:</span> <span class="entity">CTR_CONVERSIONS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(*conversion of stvs to ftvs based on type_specs: rhs*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">type_specs_rhs_ftv_of_stv</span> <span class="entity">type_specs</span> <span class="main">=</span> <span class="entity">type_specs</span> 
  |&gt; map <span class="main">(</span>apsnd <span class="main">(</span>type_of #&gt; <span class="entity">HOLogic.dest_binrelT</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span>  
  |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> #&gt; the<span class="main">;</span>

<span class="comment1">(*conversion of stvs to ftvs based on type_specs: lhs*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">type_specs_lhs_ftv_of_stv</span> <span class="entity">type_specs</span> <span class="main">=</span> <span class="entity">type_specs</span>
  |&gt; map <span class="main">(</span>apsnd <span class="main">(</span>type_of #&gt; <span class="entity">HOLogic.dest_binrelT</span> #&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>  
  |&gt; AList.lookup <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> #&gt; the<span class="main">;</span>

<span class="comment1">(*extraction of a constant from a definition*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">const_of_def</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm</span> 
  |&gt; Local_Defs.meta_rewrite_rule <span class="entity">ctxt</span>
  |&gt; Thm.full_prop_of
  |&gt; Logic.dest_equals
  |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
  |&gt; strip_comb
  |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
  |&gt; dest_Const<span class="main">;</span>

<span class="comment1">(*transfer rule goal from a constant*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trt_of_const</span> <span class="entity">ctxt</span> <span class="entity">type_specs</span> <span class="entity">const_spec</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_lhs_stv</span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_ftv_of_stv</span> <span class="main">=</span> <span class="entity">type_specs_rhs_ftv_of_stv</span> <span class="entity">type_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_ftv_of_stv</span> <span class="main">=</span> <span class="entity">type_specs_lhs_ftv_of_stv</span> <span class="entity">type_specs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_const_spec</span> <span class="main">=</span> apsnd <span class="main">(</span>map_type_tvar <span class="entity">rhs_ftv_of_stv</span><span class="main">)</span> <span class="entity">const_spec</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_var_spec</span> <span class="main">=</span> <span class="entity">const_spec</span> 
      |&gt; <span class="main">#</span><span class="inner_numeral">2</span> 
      |&gt; <span class="entity">mk_lhs_stv</span> 
      ||&gt; map_type_tvar <span class="entity">lhs_ftv_of_stv</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prt</span> <span class="main">=</span>                               
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_specs</span> <span class="main">=</span> map <span class="main">(</span>apfst <span class="main">(</span><span class="entity">rhs_ftv_of_stv</span> #&gt; dest_TFree<span class="main">)</span><span class="main">)</span> <span class="entity">type_specs</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rhs_const_spec</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span> |&gt; <span class="entity">CTR_Relators.pr_of_typ</span> <span class="entity">ctxt</span> <span class="entity">type_specs</span> <span class="keyword2"><span class="keyword">end</span></span>
    
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">prt</span> $ <span class="main">(</span>Var <span class="entity">lhs_var_spec</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="entity">rhs_const_spec</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*transfer rule destruction*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_trt</span> <span class="main">(</span><span class="entity">pr</span> $ <span class="entity">lhst</span> $ <span class="entity">rhst</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">pr</span><span class="main">,</span> <span class="entity">lhst</span><span class="main">,</span> <span class="entity">rhst</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_trt</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"dest_trt"</span><span class="main">,</span> single <span class="entity">t</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*conversion of a transfer rule goal to a parametricity property goal*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prt_of_trt</span> <span class="entity">trt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pr</span><span class="main">,</span> <span class="entity">lhst</span><span class="main">,</span> <span class="entity">rhst</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_trt</span> <span class="entity">trt</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">pr</span> $ Const <span class="main">(</span><span class="entity">rhst</span> |&gt; dest_Const |&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">,</span> type_of <span class="entity">lhst</span><span class="main">)</span> $ <span class="entity">rhst</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_Relativization.ML">
<div class="head">
<h1>File ‹CTR_Relativization.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Relativization.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Implementation of the algorithm CTR II: Relativization.
*)</span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Relativization</span> <span class="main">:</span> <span class="entity">CTR_ALGORITHM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> More_Simplifier<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pp_tac</span> <span class="entity">ctxt</span> <span class="entity">unfld_thms</span> <span class="entity">def_thm</span> <span class="entity">i</span> <span class="main">=</span> 
  SELECT_GOAL <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">def_thm</span> :: <span class="entity">unfld_thms</span><span class="main">)</span><span class="main">)</span> <span class="entity">i</span>
  THEN CONVERSION <span class="main">(</span>Thm.beta_conversion true<span class="main">)</span> <span class="entity">i</span>
  THEN CONVERSION Thm.eta_conversion <span class="entity">i</span>
  THEN <span class="entity">Transfer.transfer_prover_start_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span>
  THEN <span class="main">(</span>TRYALL <span class="main">(</span><span class="entity">Transfer.transfer_step_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
  THEN <span class="main">(</span><span class="entity">Transfer.transfer_prover_end_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_prove</span> <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="entity">asms</span> <span class="entity">prop</span> <span class="entity">tac</span> <span class="main">=</span> SOME <span class="main">(</span>Goal.prove <span class="entity">ctxt</span> <span class="entity">xs</span> <span class="entity">asms</span> <span class="entity">prop</span> <span class="entity">tac</span><span class="main">)</span>
  <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span>  <span class="main">=&gt;</span> NONE<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_relativization</span> <span class="entity">ctxt</span> <span class="entity">simp_spec_opt</span> <span class="entity">trt</span> <span class="entity">unfld_thms</span> <span class="entity">def_thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tr_thm_opt</span> <span class="main">=</span> <span class="entity">pp_tac</span> <span class="entity">ctxt</span> <span class="entity">unfld_thms</span> <span class="entity">def_thm</span> <span class="inner_numeral">1</span>
      |&gt; K
      |&gt; <span class="entity">try_prove</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">trt</span><span class="main">)</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tr_thm_opt</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">rewrite_simp_opt</span> <span class="entity">ctxt</span> <span class="entity">simp_spec_opt</span><span class="main">)</span> <span class="entity">tr_thm_opt</span> 
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">tr_thm_opt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">simp_spec_opt</span><span class="main">)</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">def_thm</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_equality_assms</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_is_equality_thm</span> <span class="main">=</span> 
        Thm.full_prop_of 
        #&gt; <span class="entity">HOLogic.dest_Trueprop</span> 
        #&gt; <span class="entity">Transfer.is_is_equality</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">assms</span>
        |&gt; filter <span class="entity">is_is_equality_thm</span>
        |&gt; map <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> is_equality_def<span class="antiquote">}</span></span></span> |&gt; single |&gt; Local_Defs.unfold <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trt</span> <span class="main">=</span> <span class="entity">def_thm</span> 
      |&gt; <span class="entity">CTR_Conversions.const_of_def</span> <span class="entity">ctxt</span>
      |&gt; <span class="entity">CTR_Conversions.trt_of_const</span> <span class="entity">ctxt</span> <span class="entity">type_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pp_thm_opt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ppt</span> <span class="main">=</span> <span class="entity">CTR_Conversions.prt_of_trt</span> <span class="entity">trt</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">pp_tac</span> <span class="entity">ctxt</span> <span class="entity">is_equality_assms</span> <span class="entity">def_thm</span> <span class="inner_numeral">1</span>
        |&gt; K
        |&gt; <span class="entity">try_prove</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">ppt</span><span class="main">)</span> 
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tr_thm_opt</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">pp_thm_opt</span> |&gt; Option.isSome |&gt; not <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">synthesis</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">try_relativization</span> <span class="entity">ctxt</span> <span class="entity">simp_spec_opt</span> <span class="entity">trt</span> <span class="entity">is_equality_assms</span> <span class="entity">def_thm</span>
      <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">output</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">if</span></span> Option.isSome <span class="entity">tr_thm_opt</span> 
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ALGRelativization</span> <span class="main">(</span>the <span class="entity">tr_thm_opt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> Option.isSome <span class="entity">pp_thm_opt</span>
        <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ALGParametricity</span> <span class="main">(</span>the <span class="entity">pp_thm_opt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ALGFailure</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">output</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_Parametricity.ML">
<div class="head">
<h1>File ‹CTR_Parametricity.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Parametricity.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Implementation of the invocation of the algorithm CTR I: Parametricity.
*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Parametricity</span> <span class="main">:</span> <span class="entity">CTR_ALGORITHM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">theorem_format_error</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg_main</span> <span class="main">=</span> <span class="inner_quoted">"Unexpected format for the definition."</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">msg</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span>Pretty.para <span class="entity">msg_main</span><span class="main">)</span><span class="main">,</span> Thm.pretty_thm <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">]</span>
      |&gt; Pretty.chunks 
      |&gt; Pretty.string_of<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> error <span class="entity">msg</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_parametric_constant</span> <span class="entity">settings</span> <span class="entity">lthy</span> <span class="entity">def_thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Ctr_Sugar_Util.mk_abs_def</span> <span class="entity">def_thm</span> 
      <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">theorem_format_error</span> <span class="entity">lthy</span> <span class="entity">def_thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goalt</span> <span class="main">=</span> <span class="entity">Conditional_Parametricity.mk_param_goal_from_eq_def</span> <span class="entity">lthy</span> <span class="entity">eq</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">Conditional_Parametricity.prove_goal</span> <span class="entity">settings</span> <span class="entity">lthy</span> <span class="main">(</span>SOME <span class="entity">eq</span><span class="main">)</span> <span class="entity">goalt</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">def_thm</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">def_thm</span>
      |&gt; <span class="entity">gen_parametric_constant</span> <span class="entity">Conditional_Parametricity.quiet_settings</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ALGParametricity</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_Postprocessing.ML">
<div class="head">
<h1>File ‹CTR_Postprocessing.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Postprocessing.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Postprocessing of the output of the algorithms associated with the CTR.
*)</span>


<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_POSTPROCESSING</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">val</span></span> postprocess_parametricity <span class="main">:</span> 
  binding <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">ctr_pp_out</span>
<span class="keyword1"><span class="keyword">val</span></span> postprocess_relativization <span class="main">:</span> 
  binding <span class="main">-&gt;</span> mixfix <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ctr_pp_out</span>
<span class="keyword1"><span class="keyword">val</span></span> postprocess_failure <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ctr_pp_out</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR_Postprocessing</span> <span class="main">:</span> <span class="entity">CTR_POSTPROCESSING</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> CTR_Utilities<span class="main">;</span>

<span class="comment1">(*post-processing of an arbitrary transfer rule*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">postprocess_transfer_rule</span> <span class="entity">b</span> <span class="entity">thm</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span> |&gt; Binding.path_of |&gt; map fst<span class="main">)</span> @ <span class="main">[</span>Binding.name_of <span class="entity">b</span><span class="main">,</span> <span class="inner_quoted">"transfer"</span><span class="main">]</span><span class="main">)</span>
      |&gt; Long_Name.implode
      |&gt; <span class="entity">Binding.qualified_name_mandatory</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">ctxt</span>
      |&gt; Local_Theory.note 
        <span class="main">(</span>
          <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">Transfer.transfer_add</span> |&gt; K |&gt; <span class="entity">Attrib.internal</span> |&gt; single<span class="main">)</span><span class="main">,</span> 
          single <span class="entity">thm</span>
        <span class="main">)</span>
      |&gt;&gt; <span class="main">#</span><span class="inner_numeral">2</span>
      |&gt;&gt; the_single
      |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_print</span> <span class="main">=</span> 
          <span class="main">(</span><span class="inner_quoted">"Transfer.lifting_syntax"</span> |&gt; single |&gt; <span class="entity">Bundle.includes</span><span class="main">)</span> <span class="entity">lthy</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">thm</span> 
        |&gt; single
        |&gt; <span class="main">(</span>Local_Theory.full_name <span class="entity">lthy_print</span> <span class="entity">b</span> |&gt; <span class="entity">thm_printer</span> <span class="entity">lthy_print</span> true<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*post-processing of a parametricity property*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">postprocess_parametricity</span> <span class="entity">b</span> <span class="entity">thm</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="entity">PPParametricity</span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">postprocess_transfer_rule</span> <span class="entity">b</span> <span class="entity">thm</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*post-processing of a relativization*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">postprocess_relativization</span> <span class="entity">b</span> <span class="entity">mf</span> <span class="entity">thm</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">rhst</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thm</span> 
      |&gt; Thm.concl_of
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span> 
      |&gt; <span class="entity">CTR_Conversions.dest_trt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhst</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Logic.unvarify_local_term</span> <span class="entity">ctxt</span> <span class="entity">rhst</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">absts</span><span class="main">,</span> <span class="entity">rhst</span><span class="main">)</span> <span class="main">=</span> <span class="entity">rhst</span>
      |&gt; Term.strip_abs_eta <span class="main">(</span><span class="entity">rhst</span> |&gt; strip_abs_vars |&gt; length<span class="main">)</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argts</span> <span class="main">=</span> <span class="entity">rhst</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      |&gt; rev
      |&gt; subtract <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="entity">absts</span>
      |&gt; curry <span class="main">(</span>swap #&gt; <span class="keyword1"><span class="keyword">op</span></span>@<span class="main">)</span> <span class="entity">absts</span>  
      |&gt; map Free
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhst</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> 
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_const_with</span> <span class="entity">thy</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> map type_of <span class="entity">argts</span> ---&gt; type_of <span class="entity">rhst</span> 
          <span class="keyword2"><span class="keyword">in</span></span> Sign.declare_const_global <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">mf</span><span class="main">)</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span> Local_Theory.raw_theory_result <span class="entity">declare_const_with</span> <span class="entity">ctxt'</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhst</span> <span class="main">=</span> Term.list_comb <span class="main">(</span><span class="entity">lhst</span><span class="main">,</span> <span class="entity">argts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_with_def</span> <span class="entity">thy</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span>
          <span class="main">(</span><span class="main">(</span><span class="entity">b</span> |&gt; Binding.path_of |&gt; map fst<span class="main">)</span> @ <span class="main">[</span>Binding.name_of <span class="entity">b</span> ^ <span class="inner_quoted">"_def"</span><span class="main">]</span><span class="main">)</span>
          |&gt; Long_Name.implode
          |&gt; <span class="entity">Binding.qualified_name_mandatory</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Global_Theory.add_defs 
          false <span class="main">(</span>single <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> Logic.mk_equals <span class="main">(</span><span class="entity">lhst</span><span class="main">,</span> <span class="entity">rhst</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
        |&gt;&gt; the_single
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ow_def_thm</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> Local_Theory.raw_theory_result <span class="entity">make_with_def</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">ow_def_thm</span> 
      |&gt; single
      |&gt; <span class="main">(</span><span class="entity">ow_def_thm</span> |&gt; Thm.derivation_name |&gt; <span class="entity">thm_printer</span> <span class="entity">lthy'</span> true<span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">Thm.pure_unfold</span> <span class="entity">lthy'</span> <span class="main">(</span><span class="entity">ow_def_thm</span> |&gt; Thm.symmetric |&gt; single<span class="main">)</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">PPRelativization</span> <span class="main">(</span><span class="main">(</span><span class="entity">ow_def_thm</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">postprocess_transfer_rule</span> <span class="entity">b</span> <span class="entity">thm</span> <span class="entity">lthy'</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*post-processing of a failed attempt to perform relativization*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">postprocess_failure</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">PPFailure</span> <span class="entity">lthy</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR.ML">
<div class="head">
<h1>File ‹CTR.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

The implementation of the command ctr.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">alg_input</span> <span class="main">=</span> 
    <span class="entity">ALG_PP</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span><span class="main">(</span>binding option * <span class="main">(</span>Facts.ref * Token.src list<span class="main">)</span><span class="main">)</span> * mixfix<span class="main">)</span> list 
  <span class="main">|</span> <span class="entity">ALG_RP</span> <span class="keyword2"><span class="keyword">of</span></span>
     <span class="main">(</span>
       <span class="main">(</span>
         <span class="main">(</span>
           <span class="main">(</span>string * <span class="main">(</span>Facts.ref * Token.src list<span class="main">)</span> option<span class="main">)</span> option *
           <span class="main">(</span>string<span class="main">,</span> string<span class="main">,</span> Facts.ref<span class="main">)</span> Element.ctxt list
         <span class="main">)</span> *
         <span class="main">(</span>string * string<span class="main">)</span> list
       <span class="main">)</span> * <span class="main">(</span><span class="main">(</span>binding option * <span class="main">(</span>Facts.ref * Token.src list<span class="main">)</span><span class="main">)</span> * mixfix<span class="main">)</span> list
     <span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> ctr_parser <span class="main">:</span> <span class="entity">alg_input</span> parser
<span class="keyword1"><span class="keyword">val</span></span> process_parametricity <span class="main">:</span>
  <span class="main">(</span>binding option * thm<span class="main">)</span> * mixfix <span class="main">-&gt;</span>
  <span class="entity">Proof.context</span> <span class="main">-&gt;</span> 
  <span class="entity">ctr_pp_out</span>
<span class="keyword1"><span class="keyword">val</span></span> process_relativization <span class="main">:</span> 
  <span class="main">(</span>string * thm list option<span class="main">)</span> option <span class="main">-&gt;</span>
  <span class="entity">Element.context</span> list <span class="main">-&gt;</span>
  <span class="main">(</span>string * string<span class="main">)</span> list <span class="main">-&gt;</span>
  <span class="main">(</span>binding option * thm<span class="main">)</span> * mixfix <span class="main">-&gt;</span>
  <span class="entity">Proof.context</span> <span class="main">-&gt;</span> 
  <span class="entity">ctr_pp_out</span>
<span class="keyword1"><span class="keyword">val</span></span> process_ctrs <span class="main">:</span> <span class="entity">alg_input</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTR</span> <span class="main">:</span> <span class="entity">CTR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>



<span class="comment1">(**** Data ****)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">alg_input</span> <span class="main">=</span> 
    <span class="entity">ALG_PP</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span><span class="main">(</span>binding option * <span class="main">(</span>Facts.ref * Token.src list<span class="main">)</span><span class="main">)</span> * mixfix<span class="main">)</span> list 
  <span class="main">|</span> <span class="entity">ALG_RP</span> <span class="keyword2"><span class="keyword">of</span></span>
     <span class="main">(</span>
       <span class="main">(</span>
         <span class="main">(</span>
           <span class="main">(</span>string * <span class="main">(</span>Facts.ref * Token.src list<span class="main">)</span> option<span class="main">)</span> option *
           <span class="main">(</span>string<span class="main">,</span> string<span class="main">,</span> Facts.ref<span class="main">)</span> Element.ctxt list
         <span class="main">)</span> * <span class="main">(</span>string * string<span class="main">)</span> list
       <span class="main">)</span> * <span class="main">(</span><span class="main">(</span>binding option * <span class="main">(</span>Facts.ref * Token.src list<span class="main">)</span><span class="main">)</span> * mixfix<span class="main">)</span> list
     <span class="main">)</span><span class="main">;</span>



<span class="comment1">(**** Parser ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">algorithm_parser</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">relativization</span>›</span></span> || <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">parametricity</span>›</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">synthesis_parser</span> <span class="main">=</span> 
  Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">synthesis</span>›</span></span> -- Scan.option Parse.thm<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_specs_parser</span> <span class="main">=</span> 
  Scan.optional
    <span class="main">(</span>
      <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">trp</span>›</span></span> |-- 
      Parse.and_list <span class="main">(</span><span class="entity">kw_bo</span> |-- Parse.type_var -- Parse.term --| <span class="entity">kw_bc</span><span class="main">)</span>
    <span class="main">)</span> 
    <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_specs_parser</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">in</span>›</span></span> |-- 
  Parse.and_list 
    <span class="main">(</span>
      <span class="main">(</span>Scan.option <span class="main">(</span>Parse.binding --| <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">:</span>›</span></span><span class="main">)</span><span class="main">)</span> -- 
      Parse.thm -- 
      Parse.opt_mixfix'
    <span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rel_opt_thm_name</span> <span class="entity">s</span> <span class="main">=</span>
  Scan.optional
    <span class="main">(</span>
      <span class="main">(</span>
        Parse.binding -- Parse.opt_attribs || Parse.attribs &gt;&gt; 
          pair Binding.empty
      <span class="main">)</span> --| Parse.$$$ <span class="entity">s</span>
    <span class="main">)</span>
    Binding.empty_atts<span class="main">;</span>

<span class="comment1">(* 
The function was ported with amendments from the file Parse_Spec.ML in the main 
distribution of Isabelle 2021.
*)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_loc_element</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">fixes</span>›</span></span> |-- Parse.!!! <span class="entity">Parse_Spec.locale_fixes</span> &gt;&gt; <span class="entity">Element.Fixes</span> ||
  <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">assumes</span>›</span></span> |-- 
    Parse.!!! <span class="main">(</span>Parse.and_list1 <span class="main">(</span><span class="entity">rel_opt_thm_name</span> <span class="inner_quoted">":"</span> -- Scan.repeat1 Parse.propp<span class="main">)</span><span class="main">)</span>
    &gt;&gt; <span class="entity">Element.Assumes</span><span class="main">;</span>

<span class="comment1">(* 
The function was ported with amendments from the file Parse_Spec.ML in the main 
distribution of Isabelle 2021.
*)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_context_element</span> <span class="main">=</span> 
  Parse.group <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"context element"</span><span class="main">)</span> <span class="entity">rel_loc_element</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parametricity_parser</span> <span class="entity">tokens</span> <span class="main">=</span> <span class="entity">thm_specs_parser</span> <span class="entity">tokens</span> |&gt;&gt; <span class="entity">ALG_PP</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">relativization_parser</span> <span class="entity">tokens</span> <span class="main">=</span> <span class="entity">tokens</span>
  |&gt; 
    <span class="main">(</span>
      <span class="entity">synthesis_parser</span> -- 
      Scan.repeat <span class="entity">rel_context_element</span> -- 
      <span class="entity">type_specs_parser</span> --
      <span class="entity">thm_specs_parser</span>
    <span class="main">)</span> 
  |&gt;&gt; <span class="entity">ALG_RP</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_parser</span> <span class="main">=</span> 
  <span class="entity">algorithm_parser</span> :|-- 
  <span class="main">(</span>           
    <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="inner_quoted">"relativization"</span> <span class="main">=&gt;</span> <span class="entity">relativization_parser</span>
      <span class="main">|</span> <span class="inner_quoted">"parametricity"</span> <span class="main">=&gt;</span> <span class="entity">parametricity_parser</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"relativization or parametricity expected"</span>
  <span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** User input analysis ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_ctr</span> <span class="entity">msg</span> <span class="main">=</span> <span class="inner_quoted">"ctr: "</span> ^ <span class="entity">msg</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_binrel</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">c</span> ^ <span class="inner_quoted">": trp must consist of (stv, binary relation) pairs"</span> <span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_binrel_ftv</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">c</span> ^ 
  <span class="inner_quoted">": the user-specified binary relations must be defined over type variables"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_no_dup_stvs</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">c</span> ^ <span class="inner_quoted">": duplicate stvs"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_no_dup_binrel_ftvs</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">c</span> ^ 
  <span class="inner_quoted">": duplicate ftvs in the specification of the binary relations"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_def</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span> Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span> ^ <span class="inner_quoted">" is not a definition"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_def</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.full_prop_of <span class="entity">thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span> |&gt; <span class="entity">Logic.is_equals</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="entity">mk_msg_def</span> <span class="entity">ctxt</span> <span class="entity">t</span> |&gt; <span class="entity">mk_msg_ctr</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_no_relator</span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"no relator found for the type constructor "</span> ^ <span class="entity">c</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_invalid_relator</span> <span class="entity">c</span> <span class="main">=</span> 
  <span class="inner_quoted">"the relator found for the type constructor "</span> ^ <span class="entity">c</span> ^
  <span class="inner_quoted">" is not suitable (is there is a mismatch of type variables?)"</span>



<span class="comment1">(**** Preprocessing ****)</span>



<span class="comment1">(*** Preprocessing of the type-relation pairs ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_type_specs</span> <span class="entity">ctxt</span> <span class="entity">type_specs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_entry</span> <span class="entity">ctxt</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">relt</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">v</span> <span class="main">=</span> <span class="entity">T</span> |&gt; Syntax.parse_typ <span class="entity">ctxt'</span> |&gt; dest_TVar |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relt</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">relt</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> type_of <span class="entity">relt</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">T</span> |&gt; <span class="entity">HOLogic.is_binrelT</span> 
          <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"trp"</span> |&gt; <span class="entity">mk_msg_binrel</span> |&gt; <span class="entity">mk_msg_ctr</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">U</span><span class="main">,</span> <span class="entity">V</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.dest_binrelT</span> <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> is_TFree <span class="entity">U</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_TFree <span class="entity">V</span> 
          <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"trp"</span> |&gt; <span class="entity">mk_msg_binrel_ftv</span> |&gt; <span class="entity">mk_msg_ctr</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">S</span> <span class="main">=</span> <span class="entity">V</span> |&gt; dest_TFree |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span><span class="main">,</span> <span class="entity">relt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_specs</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span><span class="entity">preprocess_entry</span> <span class="entity">ctxt</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">type_specs</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">type_specs</span> |&gt; map <span class="main">#</span><span class="inner_numeral">1</span> |&gt; has_duplicates <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> |&gt; not
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"trp"</span> |&gt; <span class="entity">mk_msg_no_dup_stvs</span> |&gt; <span class="entity">mk_msg_ctr</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">type_specs</span> 
      |&gt; map <span class="main">#</span><span class="inner_numeral">2</span> 
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Term.add_tfrees <span class="entity">T</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      |&gt; flat
      |&gt; has_duplicates <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
      |&gt; not
      <span class="keyword1"><span class="keyword">orelse</span></span> error <span class="main">(</span><span class="inner_quoted">"trp"</span> |&gt; <span class="entity">mk_msg_no_dup_binrel_ftvs</span> |&gt; <span class="entity">mk_msg_ctr</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">type_specs</span>
      |&gt; map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> #&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      |&gt; flat 
      |&gt; map <span class="main">#</span><span class="inner_numeral">1</span>
      |&gt; <span class="entity">Variable.fix_new_vars</span> <span class="entity">ctxt</span>
      |&gt; fold <span class="main">(</span>Variable.declare_term<span class="main">)</span> <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">type_specs</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">type_specs</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(*** Preprocessing of the context elements ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_declaration</span> <span class="entity">elems</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy'</span> <span class="main">=</span> <span class="entity">Expression.read_statement</span> <span class="entity">elems</span> <span class="main">(</span><span class="entity">Element.Shows</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assms</span> <span class="main">=</span> Assumption.local_prems_of <span class="entity">lthy'</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">assms'</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Thm.unvarify_local_fact</span> <span class="entity">lthy'</span> <span class="entity">assms</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">assms'</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_definition</span> <span class="entity">ctxt</span> <span class="entity">thm_spec</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_spec'</span> <span class="main">=</span> apfst <span class="main">(</span>apsnd <span class="main">(</span>Local_Defs.meta_rewrite_rule <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">thm_spec</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">thm_spec'</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">check_def</span> <span class="entity">ctxt</span> <span class="entity">thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">thm_spec'</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">b</span> <span class="main">=&gt;</span> <span class="entity">b</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">thm</span> 
              |&gt; Thm.cprop_of 
              |&gt; Thm.dest_equals_lhs 
              |&gt; Thm.term_of
              |&gt; head_of
              |&gt; dest_Const
              |&gt; fst
          <span class="keyword2"><span class="keyword">in</span></span> 
            <span class="entity">Binding.qualified_name_mandatory</span> 
              <span class="main">(</span><span class="entity">CTR_Utilities.qualified_name_of_const_name</span> <span class="entity">c</span> ^ <span class="inner_quoted">".transferred"</span><span class="main">)</span> 
          <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">thm_spec'</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm_spec'</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span>  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(*** Preprocessing of the theorem specification ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_thm_spec</span> <span class="entity">ctxt</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="comment1">(*auxiliary*)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_indexed_rel_names</span> <span class="entity">n</span> <span class="entity">c</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>replicate <span class="entity">n</span> <span class="entity">c</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">n</span><span class="main">)</span><span class="main">)</span>
      ||&gt; map Int.toString
      |&gt; <span class="keyword1"><span class="keyword">op</span></span>~~
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span>^<span class="main">)</span>

    <span class="comment1">(*theorems*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_spec</span> <span class="main">=</span> <span class="entity">preprocess_definition</span> <span class="entity">ctxt</span> <span class="entity">thm_spec</span>

    <span class="comment1">(*invent a new brel for each ftv not previously associated with a brel*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ftvs</span> <span class="main">=</span> <span class="entity">thm_spec</span>
      |&gt; <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span> #&gt; Thm.full_prop_of #&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.add_tvars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      |&gt; distinct <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span>
      |&gt; subtract <span class="keyword1"><span class="keyword">op</span></span><span class="main">=</span> <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">type_specs</span><span class="main">)</span>    
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cs</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      Variable.variant_fixes <span class="main">(</span><span class="entity">gen_indexed_rel_names</span> <span class="main">(</span>length <span class="entity">ftvs</span><span class="main">)</span> <span class="inner_quoted">"A"</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ss</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">ftvs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhsTs</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> Variable.invent_types <span class="entity">Ss</span> <span class="entity">ctxt'</span> |&gt;&gt; map TFree
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhsTs</span><span class="main">,</span> <span class="entity">ctxt'''</span><span class="main">)</span> <span class="main">=</span> Variable.invent_types <span class="entity">Ss</span> <span class="entity">ctxt''</span> |&gt;&gt; map TFree
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map Free <span class="main">(</span><span class="entity">cs</span> ~~ map <span class="entity">HOLogic.mk_binrelT</span> <span class="main">(</span><span class="entity">lhsTs</span> ~~ <span class="entity">rhsTs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt''''</span> <span class="main">=</span> fold Variable.declare_term <span class="entity">ts</span> <span class="entity">ctxt'''</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_specs</span> <span class="main">=</span> <span class="entity">type_specs</span> @ <span class="main">(</span><span class="entity">ftvs</span> ~~ <span class="entity">ts</span><span class="main">)</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">thm_spec</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt''''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(*** Preprocessing of the keyword synthesis ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_synthesis</span> <span class="main">(</span><span class="entity">synthesis</span> <span class="main">:</span> <span class="main">(</span>string * thm list option<span class="main">)</span> option<span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">synthesis</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thm_opt</span><span class="main">)</span> <span class="main">=&gt;</span> 
        <span class="main">(</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">thm_opt</span> <span class="keyword2"><span class="keyword">of</span></span> 
              SOME <span class="entity">simp_spec</span> <span class="main">=&gt;</span> <span class="main">(</span>true<span class="main">,</span> SOME <span class="entity">simp_spec</span><span class="main">)</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span>true<span class="main">,</span> NONE<span class="main">)</span>
        <span class="main">)</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span>false<span class="main">,</span> NONE<span class="main">)</span><span class="main">;</span>



<span class="comment1">(**** Evaluation ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_algorithm</span> <span class="entity">ctxt'</span> <span class="entity">alg</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_relator</span> <span class="entity">f</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span>
      |&gt; dest_Type
      |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
      |&gt; <span class="entity">f</span> 
      |&gt; <span class="entity">mk_msg_ctr</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_error_no_relator</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">mk_msg_relator</span> <span class="entity">mk_msg_no_relator</span> <span class="entity">T</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_error_invalid_relator</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">mk_msg_relator</span> <span class="entity">mk_msg_invalid_relator</span> <span class="entity">T</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alg_out</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">alg</span> <span class="keyword2"><span class="keyword">of</span></span> 
        <span class="entity">relativization</span> <span class="main">=&gt;</span> 
          <span class="main">(</span>
            <span class="entity">CTR_Relativization.apply</span> <span class="entity">ctxt'</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span>
            <span class="keyword3"><span class="keyword">handle</span></span> 
                TYPE <span class="main">(</span><span class="inner_quoted">"pr_of_typ: no relator"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> 
                  error <span class="main">(</span><span class="entity">mk_error_no_relator</span> <span class="entity">T</span><span class="main">)</span> 
              <span class="main">|</span> TYPE <span class="main">(</span><span class="inner_quoted">"pr_of_typ: invalid relator"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> 
                  error <span class="main">(</span><span class="entity">mk_error_invalid_relator</span> <span class="entity">T</span><span class="main">)</span> 
          <span class="main">)</span>
      <span class="main">|</span> <span class="entity">parametricity</span> <span class="main">=&gt;</span> <span class="entity">CTR_Parametricity.apply</span> 
          <span class="entity">ctxt'</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">alg_out</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">postprocess_alg_out</span> <span class="entity">b</span> <span class="entity">mf</span> <span class="entity">alg_out</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">alg_out</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">ALGRelativization</span> <span class="entity">thm</span> <span class="main">=&gt;</span> 
      <span class="entity">CTR_Postprocessing.postprocess_relativization</span> <span class="entity">b</span> <span class="entity">mf</span> <span class="entity">thm</span> <span class="entity">ctxt</span>
  <span class="main">|</span> <span class="entity">ALGParametricity</span> <span class="entity">thm</span> <span class="main">=&gt;</span> 
      <span class="entity">CTR_Postprocessing.postprocess_parametricity</span> <span class="entity">b</span> <span class="entity">thm</span> <span class="entity">ctxt</span>
  <span class="main">|</span> <span class="entity">ALGFailure</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"ctr: a transfer rule could not be established."</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_definition</span> <span class="entity">ctxt'</span> <span class="entity">alg</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alg_out</span> <span class="main">=</span> <span class="entity">thm_spec</span> 
      |&gt; <span class="main">#</span><span class="inner_numeral">1</span> 
      |&gt; <span class="main">#</span><span class="inner_numeral">2</span> 
      |&gt; <span class="entity">apply_algorithm</span> <span class="entity">ctxt'</span> <span class="entity">alg</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span>
      |&gt; <span class="entity">apply_alg_out</span> <span class="main">(</span>singleton <span class="main">(</span>Proof_Context.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">postprocess_alg_out</span> <span class="main">(</span><span class="entity">thm_spec</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">thm_spec</span><span class="main">)</span> <span class="entity">alg_out</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(*** Parametricity ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_parametricity</span> <span class="entity">thm_spec</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_spec'</span> <span class="main">=</span> <span class="entity">preprocess_definition</span> <span class="entity">lthy</span> <span class="entity">thm_spec</span> 
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">process_definition</span> <span class="entity">lthy</span> <span class="entity">parametricity</span> <span class="main">(</span>false<span class="main">,</span> NONE<span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">thm_spec'</span> <span class="entity">lthy</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(*** Relativization ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_relativization</span> <span class="entity">lthy</span> <span class="entity">synthesis</span> <span class="entity">elems</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">synthesis'</span> <span class="main">=</span> <span class="entity">preprocess_synthesis</span> <span class="entity">synthesis</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">assms</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">preprocess_declaration</span> <span class="entity">elems</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">type_specs'</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">preprocess_type_specs</span> <span class="entity">lthy'</span> <span class="entity">type_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">thm_spec'</span><span class="main">,</span> <span class="entity">type_specs''</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'''</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">preprocess_thm_spec</span> <span class="entity">lthy''</span> <span class="entity">type_specs'</span> <span class="entity">thm_spec</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis'</span><span class="main">,</span> <span class="entity">assms</span><span class="main">,</span> <span class="entity">type_specs''</span><span class="main">,</span> <span class="entity">thm_spec'</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_relativization</span> <span class="entity">synthesis</span> <span class="entity">elems</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">assms</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_spec</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">preprocess_relativization</span> <span class="entity">lthy</span> <span class="entity">synthesis</span> <span class="entity">elems</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy''</span> <span class="main">=</span> <span class="entity">process_definition</span>
      <span class="entity">lthy'</span> <span class="entity">relativization</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">lthy''</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Interface ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_parametricities</span> <span class="entity">thm_specs</span> <span class="entity">lthy</span> <span class="main">=</span> fold
  <span class="main">(</span>
    <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm_spec</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> 
      <span class="entity">process_parametricity</span> <span class="entity">thm_spec</span> <span class="entity">ctxt</span> |&gt; <span class="entity">lthy_of_pp_out</span>
  <span class="main">)</span> 
  <span class="entity">thm_specs</span>
  <span class="entity">lthy</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_relativizations</span> <span class="entity">synthesis</span> <span class="entity">elems</span> <span class="entity">type_specs</span> <span class="entity">thm_specs</span> <span class="entity">lthy</span> <span class="main">=</span>  
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_relativization'</span> <span class="entity">thm_spec</span> <span class="entity">ctxt</span> <span class="main">=</span>  
      <span class="entity">process_relativization</span> <span class="entity">synthesis</span> <span class="entity">elems</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="entity">ctxt</span> 
      |&gt; <span class="entity">lthy_of_pp_out</span>
  <span class="keyword2"><span class="keyword">in</span></span> fold <span class="entity">process_relativization'</span> <span class="entity">thm_specs</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctrs</span> <span class="entity">args</span> <span class="entity">lthy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_thm_specs</span> <span class="entity">lthy</span> <span class="main">=</span> 
      map <span class="main">(</span>apfst <span class="main">(</span>apsnd <span class="main">(</span>singleton <span class="main">(</span><span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctrs_impl</span> <span class="main">(</span><span class="entity">ALG_PP</span> <span class="entity">thm_specs</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span> 
          <span class="entity">process_parametricities</span> <span class="main">(</span><span class="entity">preprocess_thm_specs</span> <span class="entity">lthy</span> <span class="entity">thm_specs</span><span class="main">)</span> <span class="entity">lthy</span>
      <span class="main">|</span> <span class="entity">process_ctrs_impl</span> 
          <span class="main">(</span><span class="entity">ALG_RP</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">)</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_specs'</span> <span class="main">=</span> <span class="entity">preprocess_thm_specs</span> <span class="entity">lthy</span> <span class="entity">thm_specs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">synthesis'</span> <span class="main">=</span> Option.map 
              <span class="main">(</span>apsnd <span class="main">(</span>Option.map <span class="main">(</span><span class="main">(</span>single #&gt; <span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
              <span class="entity">synthesis</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">process_relativizations</span> <span class="entity">synthesis'</span> <span class="entity">elems</span> <span class="entity">type_specs</span> <span class="entity">thm_specs'</span> <span class="entity">lthy</span> 
          <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">process_ctrs_impl</span> <span class="entity">args</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span> 
    <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">ctr</span>›</span></span> 
    <span class="inner_quoted">"automated synthesis of transfer rules and relativization of definitions"</span>
    <span class="main">(</span><span class="entity">ctr_parser</span> &gt;&gt; <span class="entity">process_ctrs</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="UD_Tests">
<div class="head">
<h1>Theory UD_Tests</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/Tests/UD_Tests.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

A test suite for the framework UD.
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Test suite for UD›</span></span>
<span class="keyword1"><span class="command">theory</span></span> UD_Tests
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#UD">../UD</a>"</span>
    <span class="quoted">"<a href="#IML_UT">../../IML_UT/IML_UT</a>"</span>
    <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Complex_Main.html">Complex_Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Background›</span></span>

<span class="comment1">(* 
The following two definitions were copied from 
HOL-Analysis.Elementary_Topology with minor amendments
to avoid unnecessary dependencies
*)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> topological_space<span class="main">)</span> <span class="entity">islimpt</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">islimpt</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">T</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">∈</span><span class="bound">T</span> <span class="main">⟶</span> open <span class="bound">T</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">.</span> <span class="bound">y</span><span class="main">∈</span><span class="bound">T</span> <span class="main">∧</span> <span class="bound">y</span><span class="main">≠</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">closure</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>topological_space<span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">closure</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> islimpt <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">ud</span></span> <span class="quoted"><span class="quoted">‹topological_space.closed›</span></span>
<span class="keyword1"><span class="command">ud</span></span> <span class="quoted"><span class="quoted">‹islimpt›</span></span>

<span class="keyword1" id="UD_Tests-closed_with"><span class="command">lemma</span></span> closed_with<span class="main">:</span> <span class="quoted"><span class="quoted">"closed <span class="main">≡</span> closed.with open"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closed_def closed.with_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">closure_with</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> set <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">closure_with</span> <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> islimpt.with <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="bound">x</span> <span class="bound">S</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="UD_Tests-closure_with"><span class="command">lemma</span></span> closure_with<span class="main">:</span> <span class="quoted"><span class="quoted">"closure <span class="main">≡</span> closure_with open"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> closure_def islimpt.with closure_with_def <span class="keyword1"><span class="command">.</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Tests›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span><span class="quoted">‹UD_TEST_UNOVERLOAD_DEFINITION.ML›</span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_test_unoverload_definition_test_results</span> <span class="main">=</span>
  <span class="entity">ud_test_unoverload_definition.execute_test_suite_unoverload_definition</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>
›</span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">ud_test_unoverload_definition_test_results</span>
  |&gt; <span class="entity">UT_Test_Suite.output_test_results</span> true
›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/UD_TEST_UNOVERLOAD_DEFINITION.ML">
<div class="head">
<h1>File ‹UD_TEST_UNOVERLOAD_DEFINITION.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/Tests/UD_TEST_UNOVERLOAD_DEFINITION.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UD_TEST_UNOVERLOAD_DEFINITION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">unoverload_definition_in_type</span>
<span class="keyword1"><span class="keyword">val</span></span> execute_test_suite_unoverload_definition <span class="main">:</span> 
  theory <span class="main">-&gt;</span>
  <span class="main">(</span><span class="entity">unoverload_definition_in_type</span><span class="main">,</span> <span class="entity">UD.ud_thm_out_type</span> * theory<span class="main">)</span>
    <span class="entity">UT_Test_Suite.test_results_suite</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ud_test_unoverload_definition</span> <span class="main">:</span> <span class="entity">UD_TEST_UNOVERLOAD_DEFINITION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>




<span class="comment1">(**** Auxiliary ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_unoverload_definition_error</span> <span class="entity">msg</span> <span class="main">=</span> <span class="inner_quoted">"ud: "</span> ^ <span class="entity">msg</span>



<span class="comment1">(*** Data ***)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">unoverload_definition_in_type</span> <span class="main">=</span> 
  <span class="main">(</span>binding * mixfix<span class="main">)</span> * <span class="main">(</span>string * typ<span class="main">)</span> * theory<span class="main">;</span>



<span class="comment1">(*** Relation ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ud_test_eq_thm</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">act_c</span><span class="main">,</span> <span class="entity">exp_c</span><span class="main">)</span> <span class="main">(</span><span class="entity">act_ud_out</span><span class="main">,</span> <span class="entity">exp_ud_out</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rel</span> <span class="main">(</span><span class="entity">act_thm</span><span class="main">,</span> <span class="entity">exp_thm</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_const</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">exp_c</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="entity">act_c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
          <span class="main">|</span> <span class="entity">replace_const</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">replace_const</span> <span class="entity">t</span> $ <span class="entity">replace_const</span> <span class="entity">u</span>
          <span class="main">|</span> <span class="entity">replace_const</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">replace_const</span> <span class="entity">t</span><span class="main">)</span>
          <span class="main">|</span> <span class="entity">replace_const</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">x</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_t</span> <span class="main">=</span> Thm.full_prop_of <span class="entity">act_thm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exp_t</span> <span class="main">=</span> <span class="entity">exp_thm</span> |&gt; Thm.full_prop_of |&gt; <span class="entity">replace_const</span>
      <span class="keyword2"><span class="keyword">in</span></span> Pattern.equiv <span class="entity">thy</span> <span class="main">(</span><span class="entity">act_t</span><span class="main">,</span> <span class="entity">exp_t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ud_test_eq_thm_impl</span> <span class="main">(</span><span class="main">(</span><span class="entity">UD.trivial</span> <span class="entity">act_thm</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">UD.trivial</span> <span class="entity">exp_thm</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">rel</span> <span class="main">(</span><span class="entity">act_thm</span><span class="main">,</span> <span class="entity">exp_thm</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">ud_test_eq_thm_impl</span> <span class="main">(</span><span class="main">(</span><span class="entity">UD.nontrivial</span> <span class="entity">act_thms</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">UD.nontrivial</span> <span class="entity">exp_thms</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">act_with_def_thm</span><span class="main">,</span> <span class="entity">act_with_thm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">act_thms</span> 
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">exp_with_def_thm</span><span class="main">,</span> <span class="entity">exp_with_thm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">exp_thms</span>
          <span class="keyword2"><span class="keyword">in</span></span> 
            <span class="entity">rel</span> <span class="main">(</span><span class="entity">act_with_def_thm</span><span class="main">,</span> <span class="entity">exp_with_def_thm</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">rel</span> <span class="main">(</span><span class="entity">act_with_thm</span><span class="main">,</span> <span class="entity">exp_with_thm</span><span class="main">)</span> 
          <span class="keyword2"><span class="keyword">end</span></span>
     <span class="main">|</span> <span class="entity">ud_test_eq_thm_impl</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> false

  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ud_test_eq_thm_impl</span> <span class="main">(</span>fst <span class="entity">act_ud_out</span><span class="main">,</span> fst <span class="entity">exp_ud_out</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Tests ****)</span>



<span class="comment1">(*** Valid inputs ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_eq_trivial</span> <span class="entity">thy</span>  <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    
    <span class="comment1">(*input*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_c</span> <span class="main">=</span> <span class="inner_quoted">"UD_Tests.closed'.with"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exp_c</span> <span class="main">=</span> <span class="inner_quoted">""</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> Binding.name <span class="inner_quoted">"closed'"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aT</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹topological_space›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span> --&gt; <span class="entity">HOLogic.boolT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">closed_c</span> <span class="main">=</span> <span class="inner_quoted">"Topological_Spaces.topological_space_class.closed"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_in</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">closed_c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
    
    <span class="comment1">(*output*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_out</span> <span class="main">=</span> <span class="main">(</span><span class="entity">UD.trivial</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> closed_with<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
    
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">UT_Test_Suite.assert_brel</span> 
      <span class="inner_quoted">"nontrivial output equivalence"</span>
      <span class="main">(</span><span class="entity">ud_test_eq_thm</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">act_c</span><span class="main">,</span> <span class="entity">exp_c</span><span class="main">)</span><span class="main">)</span> 
      <span class="entity">ud_out</span>
      <span class="entity">ud_in</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_eq_nontrivial</span> <span class="entity">thy</span>  <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    
    <span class="comment1">(*input*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_c</span> <span class="main">=</span> <span class="inner_quoted">"UD_Tests.closure.with"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exp_c</span> <span class="main">=</span> <span class="inner_quoted">"UD_Tests.closure_with"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> Binding.name <span class="inner_quoted">"closure"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aT</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹topological_space›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span><span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span> --&gt; <span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">closure_c</span> <span class="main">=</span> <span class="inner_quoted">"UD_Tests.closure"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_in</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">closure_c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
    
    <span class="comment1">(*output*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_out</span> <span class="main">=</span> 
      <span class="main">(</span><span class="entity">UD.nontrivial</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> closure_with_def<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> closure_with<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
    
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">UT_Test_Suite.assert_brel</span> 
      <span class="inner_quoted">"nontrivial output equivalence"</span>
      <span class="main">(</span><span class="entity">ud_test_eq_thm</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">act_c</span><span class="main">,</span> <span class="entity">exp_c</span><span class="main">)</span><span class="main">)</span> 
      <span class="entity">ud_out</span>
      <span class="entity">ud_in</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(*** Exceptions ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_extra_type_variables</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aT</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Sup_class_c</span> <span class="main">=</span> <span class="inner_quoted">"Complete_Lattices.Sup_class"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">:</span> <span class="entity">unoverload_definition_in_type</span> <span class="main">=</span>
      <span class="main">(</span>
        <span class="main">(</span>Binding.empty<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> 
        <span class="main">(</span><span class="entity">Sup_class_c</span><span class="main">,</span> Term.itselfT <span class="entity">aT</span> --&gt; <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‹prop›</span></span><span class="main">)</span><span class="main">,</span> 
        <span class="entity">thy</span>
      <span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_unoverload_definition_error</span> 
      <span class="inner_quoted">"specification depends on extra type variables"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"extra type variables"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_ud_ex</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aT</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> 
      <span class="main">(</span><span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span> --&gt; <span class="entity">HOLogic.boolT</span><span class="main">)</span> --&gt; 
      <span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span> --&gt; 
      <span class="entity">HOLogic.boolT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts_c</span> <span class="main">=</span> <span class="inner_quoted">"Topological_Spaces.topological_space.closed"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">:</span> <span class="entity">unoverload_definition_in_type</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">ts_c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_unoverload_definition_error</span> 
      <span class="inner_quoted">"unoverloaded constant already exists"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"constant already exists"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_no_cids</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">aT</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">sort</span><span class="hidden">&gt;</span></span><span class="quoted">‹type›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> 
      <span class="main">(</span><span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span> --&gt; <span class="entity">HOLogic.boolT</span><span class="main">)</span> --&gt; 
      <span class="entity">HOLogic.mk_setT</span> <span class="entity">aT</span> --&gt; 
      <span class="entity">HOLogic.boolT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">implies_c</span> <span class="main">=</span> <span class="inner_quoted">"HOL.implies"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">:</span> <span class="entity">unoverload_definition_in_type</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">implies_c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_unoverload_definition_error</span>
      <span class="inner_quoted">"no suitable constant-instance definitions"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"no suitable CIs"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Test suite ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unoverload_definition_string_of_input</span> 
  <span class="main">(</span><span class="entity">unoverload_definition_in</span> <span class="main">:</span> <span class="entity">unoverload_definition_in_type</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">unoverload_definition_in</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b_c</span> <span class="main">=</span> <span class="inner_quoted">"binding: "</span> ^ Binding.name_of <span class="entity">b</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_c</span> <span class="main">=</span> 
      <span class="inner_quoted">"constant: "</span> ^ 
      <span class="entity">c</span> ^ 
      <span class="inner_quoted">" :: "</span> ^ 
      Syntax.string_of_typ <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">T</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy_c</span> <span class="main">=</span> <span class="inner_quoted">"thy: unknown theory"</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out_c</span> <span class="main">=</span> <span class="main">[</span><span class="entity">b_c</span><span class="main">,</span> <span class="entity">const_c</span><span class="main">,</span> <span class="entity">thy_c</span><span class="main">]</span> |&gt; String.concatWith <span class="inner_quoted">"\n"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out_c</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unoverload_definition_string_of_output</span> <span class="main">(</span><span class="entity">ud_thm_out</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ud_thm_c</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">with_thm_c</span> <span class="main">=</span> <span class="inner_quoted">"with_thm: "</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">with_def_thm_c</span> <span class="main">=</span> <span class="inner_quoted">"with_def_thm: "</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ud_thm_out</span> <span class="keyword2"><span class="keyword">of</span></span> 
          <span class="entity">UD.trivial</span> <span class="entity">with_thm</span> <span class="main">=&gt;</span> 
            <span class="entity">with_thm_c</span> ^ Thm.string_of_thm <span class="entity">ctxt</span> <span class="entity">with_thm</span>
        <span class="main">|</span> <span class="entity">UD.nontrivial</span> <span class="main">(</span><span class="entity">with_def_thm</span><span class="main">,</span> <span class="entity">with_thm</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">with_def_thm_c</span> ^ 
            Thm.string_of_thm <span class="entity">ctxt</span> <span class="entity">with_def_thm</span> ^ 
            <span class="inner_quoted">"\n"</span> ^
            <span class="entity">with_thm_c</span> ^ 
            Thm.string_of_thm <span class="entity">ctxt</span> <span class="entity">with_thm</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy_c</span> <span class="main">=</span> <span class="inner_quoted">"thy: unknown theory"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out_c</span> <span class="main">=</span> <span class="main">[</span><span class="entity">ud_thm_c</span><span class="main">,</span> <span class="entity">thy_c</span><span class="main">]</span> |&gt; String.concatWith <span class="inner_quoted">"\n"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out_c</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unoverload_definition</span> 
  <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">:</span> <span class="entity">unoverload_definition_in_type</span><span class="main">)</span> <span class="main">=</span> 
  <span class="entity">UD.unoverload_definition</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">mixfix</span><span class="main">)</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">thy</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_test_suite_unoverload_definition</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_suite_unoverload_definition</span> <span class="main">=</span> <span class="entity">UT_Test_Suite.init</span>
      <span class="inner_quoted">"unoverload_definition"</span>
      <span class="entity">unoverload_definition</span>
      <span class="entity">unoverload_definition_string_of_input</span>
      <span class="entity">unoverload_definition_string_of_output</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">test_suite_unoverload_definition</span>
    |&gt; <span class="entity">test_eq_trivial</span> <span class="entity">thy</span>
    |&gt; <span class="entity">test_eq_nontrivial</span> <span class="entity">thy</span>
    |&gt; <span class="entity">test_exc_extra_type_variables</span> <span class="entity">thy</span>
    |&gt; <span class="entity">test_exc_ud_ex</span> <span class="entity">thy</span>
    |&gt; <span class="entity">test_exc_no_cids</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">execute_test_suite_unoverload_definition</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="entity">UT_Test_Suite.execute</span> <span class="main">(</span><span class="entity">mk_test_suite_unoverload_definition</span> <span class="entity">thy</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="CTR_Tests">
<div class="head">
<h1>Theory CTR_Tests</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/Tests/CTR_Tests.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

A test suite for the sub-framework CTR.
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹A test suite for CTR›</span></span>
<span class="keyword1"><span class="command">theory</span></span> CTR_Tests
  <span class="keyword2"><span class="keyword">imports</span></span>
    <span class="quoted">"<a href="#CTR">../CTR</a>"</span>
    <span class="quoted">"<a href="#IML_UT">../../IML_UT/IML_UT</a>"</span>
    <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Complex_Main.html">Complex_Main</a>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"ctr_test"</span> <span class="main">::</span> thy_defn
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Background›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctr_test_data</span> <span class="main">=</span>
  <span class="main">{</span>
    ctr_type <span class="main">:</span> string<span class="main">,</span>
    synthesis <span class="main">:</span> <span class="main">(</span>string * thm list option<span class="main">)</span> option<span class="main">,</span>
    elems<span class="main">:</span> <span class="main">(</span>string<span class="main">,</span> string<span class="main">,</span> Facts.ref<span class="main">)</span> <span class="entity">Element.ctxt</span> list<span class="main">,</span>
    type_specs <span class="main">:</span> <span class="main">(</span>string * string<span class="main">)</span> list<span class="main">,</span>
    thm_specs <span class="main">:</span> <span class="main">(</span><span class="main">(</span>binding option * thm<span class="main">)</span> * mixfix<span class="main">)</span> list
  <span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CTRTestData</span> <span class="main">=</span> Generic_Data
  <span class="main">(</span>
    <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">ctr_test_data</span> Symtab.table
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span>
  <span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_ctr_test_data_generic</span> <span class="main">=</span> CTRTestData.get<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_ctr_test_data_proof</span> <span class="main">=</span> Context.Proof #&gt; <span class="entity">get_ctr_test_data_generic</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_ctr_test_data_global</span> <span class="main">=</span> Context.Theory #&gt; <span class="entity">get_ctr_test_data_generic</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_data_of_generic</span> <span class="entity">context</span> <span class="main">=</span> <span class="entity">context</span>
  |&gt; <span class="entity">get_ctr_test_data_generic</span>
  |&gt; Symtab.lookup<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_test_data_of_proof</span> <span class="main">=</span> Context.Proof #&gt; <span class="entity">test_data_of_generic</span><span class="main">;</span>

<span class="comment1">(*oversimplified: to be used with care*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_ctr_test_data</span> <span class="entity">k</span> <span class="entity">ctr_test_data</span> <span class="main">=</span>
  Local_Theory.declaration
    <span class="main">{</span>pervasive<span class="main">=</span>true<span class="main">,</span> syntax<span class="main">=</span>false<span class="main">}</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="entity">ctr_test_data</span><span class="main">)</span> |&gt; Symtab.update |&gt; CTRTestData.map<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctr_test_data</span> <span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">(</span><span class="entity">lthy</span> <span class="main">:</span> local_theory<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">preprocess_thm_specs</span> <span class="entity">lthy</span> <span class="main">=</span>
      map <span class="main">(</span>apfst <span class="main">(</span>apsnd <span class="main">(</span>singleton <span class="main">(</span><span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctrs_impl</span> <span class="main">(</span><span class="entity">CTR.ALG_PP</span> <span class="main">_</span><span class="main">)</span> <span class="main">(</span><span class="entity">lthy</span> <span class="main">:</span> local_theory<span class="main">)</span> <span class="main">=</span> <span class="entity">lthy</span>
      <span class="main">|</span> <span class="entity">process_ctrs_impl</span>
          <span class="main">(</span><span class="entity">CTR.ALG_RP</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">)</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span><span class="entity">lthy</span> <span class="main">:</span> local_theory<span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_specs'</span> <span class="main">=</span> <span class="entity">preprocess_thm_specs</span> <span class="entity">lthy</span> <span class="entity">thm_specs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">synthesis'</span> <span class="main">=</span> Option.map
              <span class="main">(</span>apsnd <span class="main">(</span>Option.map <span class="main">(</span><span class="main">(</span>single #&gt; <span class="entity">Attrib.eval_thms</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="entity">synthesis</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">:</span> <span class="entity">ctr_test_data</span> <span class="main">=</span>
              <span class="main">{</span>
                ctr_type <span class="main">=</span> <span class="inner_quoted">"relativization"</span><span class="main">,</span>
                synthesis <span class="main">=</span> <span class="entity">synthesis'</span><span class="main">,</span>
                elems <span class="main">=</span> <span class="entity">elems</span><span class="main">,</span>
                type_specs <span class="main">=</span> <span class="entity">type_specs</span><span class="main">,</span>
                thm_specs <span class="main">=</span> <span class="entity">thm_specs'</span>
              <span class="main">}</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">update_ctr_test_data</span> <span class="entity">k</span> <span class="entity">data</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">process_ctrs_impl</span> <span class="entity">args</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_test_parser</span> <span class="main">=</span> Parse.string -- <span class="entity">CTR.ctr_parser</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span>
    <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">ctr_test</span>›</span></span>
    <span class="inner_quoted">"test setup for the command ctr"</span>
    <span class="main">(</span><span class="entity">ctr_test_parser</span> &gt;&gt; <span class="entity">process_ctr_test_data</span><span class="main">)</span><span class="main">;</span>

›</span>

<span class="keyword1"><span class="command">ud</span></span> <span class="quoted"><span class="quoted">‹order.mono›</span></span>
<span class="keyword1"><span class="command">ud</span></span> mono' <span class="quoted"><span class="quoted">‹mono›</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mono_ow</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mono_ow</span> <span class="free"><span class="bound"><span class="entity">UB</span></span></span> <span class="free"><span class="bound"><span class="entity">leb</span></span></span> <span class="free"><span class="bound"><span class="entity">lea</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">UB</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">UB</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">lea</span></span></span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">leb</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> K <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">{</span><span class="bound">xs</span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">.</span> length <span class="bound">xs</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">}</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ex_list_of_length<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">KK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> K <span class="main">⇒</span> <span class="tfree">'a</span> K <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">KK</span> <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span>"</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> L <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">{</span><span class="bound">xs</span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">.</span> length <span class="bound">xs</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">}</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ex_list_of_length<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">LL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> L <span class="main">⇒</span> <span class="tfree">'a</span> L <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">LL</span> <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">k1</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k2</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_L</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>group_add <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>group_add <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>group_add L <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>group_add L <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_L</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">ctr_relator</span></span> <span class="quoted">rel_L</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_binders_binrelT</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_binders_binrelT</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">no_dup_binrelT</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">no_dup_binrelT</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_binders_binrelT_ftv_stv</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_binders_binrelT_ftv_stv</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_type_constructor_lhs</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> K <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_type_constructor_lhs</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_type_constructor_rhs</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> K <span class="main">⇒</span> <span class="tfree">'e</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_type_constructor_rhs</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_identical_type_constructors</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> K <span class="main">⇒</span> <span class="tfree">'e</span> L <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_identical_type_constructors</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_identical_type_constructors_lhs</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> K <span class="main">⇒</span> <span class="tfree">'b</span> K <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_identical_type_constructors_lhs</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">R2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">not_identical_type_constructors_rhs</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> K <span class="main">⇒</span> <span class="tfree">'c</span> K <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_identical_type_constructors_rhs</span> <span class="free"><span class="bound"><span class="entity">R1</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> True"</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Test data›</span></span>

<span class="keyword1" id="CTR_Tests-mono_ow_transfer'"><span class="command">lemma</span></span> mono_ow_transfer'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_domain_rule</span><span class="main">,</span> <span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domainp <span class="free">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">UB</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"right_total <span class="free">B</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span>
      <span class="main">(</span>mono_ow <span class="free">UB</span><span class="main">)</span> mono.with"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_ow_def mono.with_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer_prover_start</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer_step</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"mono_with"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_domain_rule</span><span class="main">,</span> <span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"Domainp <span class="main">(</span><span class="free">B</span><span class="main">::</span><span class="tfree">'c</span><span class="main">⇒</span><span class="tfree">'d</span><span class="main">⇒</span>bool<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">UB</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"right_total <span class="free">B</span>"</span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="quoted">‹<span class="free">A</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⇒</span><span class="tfree">'b</span><span class="main">⇒</span>bool›</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'a</span> <span class="quoted"><span class="free">B</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow'<span class="main">:</span> mono.with_def 

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"exI"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow''<span class="main">:</span> exI

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"binrel"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_domain_rule</span></span><span class="main">,</span> <span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="quoted">"Domainp <span class="main"><span class="main">(</span></span><span class="free"><span class="free">B</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">UB</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span class="quoted">"right_total <span class="free"><span class="free">B</span></span>"</span></span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'a</span> B<span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow'<span class="main">:</span> mono.with_def 

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"binrel_ftv"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_domain_rule</span></span><span class="main">,</span> <span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="quoted">"Domainp <span class="main"><span class="main">(</span></span><span class="free"><span class="free">B</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">UB</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span class="quoted">"right_total <span class="free"><span class="free">B</span></span>"</span></span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">A</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">⇒</span></span>bool›</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'a</span> B<span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow'<span class="main">:</span> mono.with_def 

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"dup_stvs"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_domain_rule</span></span><span class="main">,</span> <span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="quoted">"Domainp <span class="main"><span class="main">(</span></span><span class="free"><span class="free">B</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">UB</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span class="quoted">"right_total <span class="free"><span class="free">B</span></span>"</span></span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">A</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">⇒</span></span>bool›</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">B</span></span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow'<span class="main">:</span> mono.with_def 

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"dup_binrel_ftvs"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_domain_rule</span></span><span class="main">,</span> <span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="quoted">"Domainp <span class="main"><span class="main">(</span></span><span class="free"><span class="free">B</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">UB</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span class="quoted">"right_total <span class="free"><span class="free">B</span></span>"</span></span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">A</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool›</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'a</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">B</span></span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow'<span class="main">:</span> mono.with_def 

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"no_relator"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_domain_rule</span></span><span class="main">,</span> <span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="quoted">"Domainp <span class="main"><span class="main">(</span></span><span class="free"><span class="free">B</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">UB</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span class="quoted">"right_total <span class="free"><span class="free">B</span></span>"</span></span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">A</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">⇒</span></span>bool›</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'a</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">B</span></span></span></span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">in</span></span> KK_def

<span class="keyword1"><span class="command">ctr_test</span></span> <span class="quoted">"invalid_relator"</span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> ctr_simps_Collect_mem_eq
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_domain_rule</span></span><span class="main">,</span> <span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="quoted">"Domainp <span class="main"><span class="main">(</span></span><span class="free"><span class="free">B</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'d</span></span><span class="main"><span class="main">⇒</span></span>bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">UB</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator"><span class="operator">transfer_rule</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span class="quoted">"right_total <span class="free"><span class="free">B</span></span>"</span></span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">A</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">⇒</span></span>bool›</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'a</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">B</span></span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> LL_def



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Tests›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>process_relativization›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span><span class="quoted">‹CTR_TEST_PROCESS_RELATIVIZATION.ML›</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_test_process_relativization_test_results</span> <span class="main">=</span>
  <span class="entity">ctr_test_process_relativization.execute_test_suite_process_relativization</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
›</span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">ctr_test_process_relativization_test_results</span>
  |&gt; <span class="entity">UT_Test_Suite.output_test_results</span> true
›</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>process_ctr_relator›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span><span class="quoted">‹CTR_TEST_PROCESS_CTR_RELATOR.ML›</span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_test_process_ctr_relator_test_results</span> <span class="main">=</span>
  <span class="entity">ctr_test_process_ctr_relator.execute_test_suite_process_ctr_relator</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
›</span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">ctr_test_process_ctr_relator_test_results</span>
  |&gt; <span class="entity">UT_Test_Suite.output_test_results</span> true
›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/CTR_TEST_PROCESS_RELATIVIZATION.ML">
<div class="head">
<h1>File ‹CTR_TEST_PROCESS_RELATIVIZATION.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/Tests/CTR_TEST_PROCESS_RELATIVIZATION.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_TEST_PROCESS_RELATIVIZATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">process_relativization_in_type</span>
<span class="keyword1"><span class="keyword">val</span></span> execute_test_suite_process_relativization <span class="main">:</span> 
  <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">process_relativization_in_type</span><span class="main">,</span> <span class="entity">ctr_pp_out</span><span class="main">)</span>
    <span class="entity">UT_Test_Suite.test_results_suite</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ctr_test_process_relativization</span> <span class="main">:</span> <span class="entity">CTR_TEST_PROCESS_RELATIVIZATION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>




<span class="comment1">(**** Auxiliary ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_ctr_error</span> <span class="entity">msg</span> <span class="main">=</span> <span class="inner_quoted">"ctr: "</span> ^ <span class="entity">msg</span>



<span class="comment1">(*** Data ***)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">process_relativization_in_type</span> <span class="main">=</span> 
  <span class="main">(</span>
    <span class="main">(</span>string * thm list option<span class="main">)</span> option *
    <span class="entity">Element.context</span> list *
    <span class="main">(</span>string * string<span class="main">)</span> list *
    <span class="main">(</span><span class="main">(</span>binding option * thm<span class="main">)</span> * mixfix<span class="main">)</span> 
  <span class="main">)</span> * <span class="entity">Proof.context</span><span class="main">;</span>



<span class="comment1">(*** Relation ***)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_const_name</span> <span class="main">(</span><span class="entity">oldc</span><span class="main">,</span> <span class="entity">newc</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">oldc</span> <span class="main">=</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">then</span></span> Const <span class="main">(</span><span class="entity">newc</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_const_name</span> <span class="entity">eqc</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">map_const_name</span> <span class="entity">eqc</span> <span class="entity">t</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">map_const_name</span> <span class="entity">eqc</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">map_const_name</span> <span class="entity">eqc</span> <span class="entity">t</span> $ <span class="entity">map_const_name</span> <span class="entity">eqc</span> <span class="entity">u</span>
  <span class="main">|</span> <span class="entity">map_const_name</span> <span class="main">_</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span>

<span class="keyword2"><span class="keyword">in</span></span> 
 
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_relativization_test_eq</span> 
    <span class="main">(</span><span class="entity">PPRelativization</span> <span class="entity">args1</span><span class="main">,</span> <span class="entity">PPRelativization</span> <span class="entity">args2</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_lthy</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">args1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exp_lthy</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">args2</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">act_ow_def_t</span><span class="main">,</span> <span class="entity">act_tr_t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">args1</span>
          |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
          |&gt;&gt; Local_Defs.meta_rewrite_rule <span class="entity">act_lthy</span> 
          |&gt; apply2 Thm.full_prop_of
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">exp_ow_def_t</span><span class="main">,</span> <span class="entity">exp_tr_t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">args2</span>
          |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
          |&gt;&gt; Local_Defs.meta_rewrite_rule <span class="entity">act_lthy</span> 
          |&gt; apply2 Thm.full_prop_of
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_ow_def_lhst</span> <span class="main">=</span> <span class="entity">act_ow_def_t</span> |&gt; Logic.dest_equals |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exp_ow_def_lhst</span> <span class="main">=</span> <span class="entity">exp_ow_def_t</span> |&gt; Logic.dest_equals |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">exp_lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mapc</span> <span class="main">=</span> 
          <span class="main">(</span>
            <span class="entity">act_ow_def_lhst</span> |&gt; head_of |&gt; dest_Const |&gt; <span class="main">#</span><span class="inner_numeral">1</span><span class="main">,</span> 
            <span class="entity">exp_ow_def_lhst</span> |&gt; head_of |&gt; dest_Const |&gt; <span class="main">#</span><span class="inner_numeral">1</span>
          <span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_ow_def_t'</span> <span class="main">=</span> <span class="entity">map_const_name</span> <span class="entity">mapc</span> <span class="entity">act_ow_def_t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_tr_t'</span> <span class="main">=</span> <span class="entity">map_const_name</span> <span class="entity">mapc</span> <span class="entity">act_tr_t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">act_ow_def_eq</span> <span class="main">=</span> Pattern.equiv <span class="entity">thy</span> <span class="main">(</span><span class="entity">act_ow_def_t'</span><span class="main">,</span> <span class="entity">exp_ow_def_t</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tr_eq</span> <span class="main">=</span> Pattern.equiv <span class="entity">thy</span> <span class="main">(</span><span class="entity">act_tr_t'</span><span class="main">,</span> <span class="entity">exp_tr_t</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">act_ow_def_eq</span> |&gt; Bool.toString |&gt; writeln
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">act_ow_def_eq</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">tr_eq</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">process_relativization_test_eq</span> 
      <span class="main">(</span><span class="entity">PPParametricity</span> <span class="entity">args1</span><span class="main">,</span> <span class="entity">PPParametricity</span> <span class="entity">args2</span><span class="main">)</span> <span class="main">=</span> 
      <span class="comment1">(*careful: not needed; hence, a usable implementation is not provided*)</span>
      Thm.eq_thm <span class="main">(</span>fst <span class="entity">args1</span><span class="main">,</span> fst <span class="entity">args2</span><span class="main">)</span> 
  <span class="main">|</span> <span class="entity">process_relativization_test_eq</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> false<span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Tests ****)</span>



<span class="comment1">(*** Valid inputs ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_eq_trivial</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(*input*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"mono_with"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">process_relativization_in</span> <span class="main">=</span> 
      <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="comment1">(*output*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">process_relativization_out</span> <span class="main">=</span> 
      <span class="entity">PPRelativization</span> <span class="main">(</span><span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mono_ow_def<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mono_ow_transfer'<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">UT_Test_Suite.assert_brel</span> 
      <span class="inner_quoted">"output equivalence"</span>
      <span class="entity">process_relativization_test_eq</span> 
      <span class="entity">process_relativization_out</span>
      <span class="entity">process_relativization_in</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>



<span class="comment1">(*** Exceptions ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_def</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"exI"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> 
      <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span> 
      <span class="main">(</span>
        Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.full_prop_of <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> exI<span class="antiquote">}</span></span></span><span class="main">)</span> ^ 
        <span class="inner_quoted">" is not a definition"</span>
      <span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"not a definition"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_binrel</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"binrel"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span> 
      <span class="inner_quoted">"trp: trp must consist of (stv, binary relation) pairs"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"binary relation"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_binrel_ftv</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"binrel_ftv"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span> 
      <span class="inner_quoted">"trp: the user-specified binary relations must "</span> ^
      <span class="inner_quoted">"be defined over type variables"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"binary relation ftv"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_dup_stvs</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"dup_stvs"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span> <span class="inner_quoted">"trp: duplicate stvs"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"duplicate stv"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_dup_binrel_ftvs</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"dup_binrel_ftvs"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span>
      <span class="inner_quoted">"trp: duplicate ftvs in the specification of the binary relations"</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"duplicate binrel ftvs"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_no_relator</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"no_relator"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span>
      <span class="inner_quoted">"no relator found for the type constructor CTR_Tests.K"</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"no relator"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_invalid_relator</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_specs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> 
      <span class="entity">ctr_test_data_of_proof</span> <span class="entity">ctxt</span> <span class="inner_quoted">"invalid_relator"</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> the_single <span class="entity">thm_specs</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_error</span>
      <span class="main">(</span>
        <span class="inner_quoted">"the relator found for the type constructor CTR_Tests.L "</span> ^
        <span class="inner_quoted">"is not suitable (is there is a mismatch of type variables?)"</span> 
      <span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"no relator"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Test suite ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt_fixes</span> <span class="entity">args</span> <span class="main">=</span> <span class="inner_quoted">"fixes: "</span> ^
  <span class="main">(</span>
    <span class="entity">args</span>
    |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> 
    |&gt; ML_Syntax.print_list 
      <span class="main">(</span>ML_Syntax.print_pair Binding.print <span class="main">(</span>ML_Syntax.print_option I<span class="main">)</span><span class="main">)</span>
  <span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt_assumes</span> <span class="entity">ctxt</span> <span class="entity">args</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_fst</span> <span class="main">=</span> ML_Syntax.print_pair 
      Binding.print 
      <span class="main">(</span>ML_Syntax.print_list <span class="main">(</span>Token.pretty_src <span class="entity">ctxt</span> #&gt; Pretty.string_of<span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_snd</span> <span class="main">=</span> 
      ML_Syntax.print_list <span class="main">(</span>ML_Syntax.print_pair I <span class="main">(</span>ML_Syntax.print_list I<span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="inner_quoted">"assumes: "</span> ^ 
    ML_Syntax.print_list <span class="main">(</span>ML_Syntax.print_pair <span class="entity">string_of_fst</span> <span class="entity">string_of_snd</span><span class="main">)</span> <span class="entity">args</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt_constrains</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_quoted">"constrains: unknown constrains"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt_defines</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_quoted">"defines: unknown defines"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt_notes</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_quoted">"notes: unknown notes"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt_lazy_notes</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_quoted">"lazy notes: unknown lazy notes"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_elem_ctxt</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Fixes</span> <span class="entity">args</span> <span class="main">:</span> <span class="entity">Element.context</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">string_of_elem_ctxt_fixes</span> <span class="entity">args</span>
  <span class="main">|</span> <span class="entity">string_of_elem_ctxt</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Constrains</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">string_of_elem_ctxt_constrains</span> <span class="entity">args</span>
  <span class="main">|</span> <span class="entity">string_of_elem_ctxt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Element.Assumes</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">string_of_elem_ctxt_assumes</span> <span class="entity">ctxt</span> <span class="entity">args</span>
  <span class="main">|</span> <span class="entity">string_of_elem_ctxt</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Defines</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">string_of_elem_ctxt_defines</span> <span class="entity">args</span>
  <span class="main">|</span> <span class="entity">string_of_elem_ctxt</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Notes</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">string_of_elem_ctxt_notes</span> <span class="entity">args</span>
  <span class="main">|</span> <span class="entity">string_of_elem_ctxt</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Lazy_Notes</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> 
      <span class="entity">string_of_elem_ctxt_lazy_notes</span> <span class="entity">args</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_relativization_string_of_input</span> <span class="entity">ctxt</span> 
  <span class="main">(</span><span class="entity">process_relativization_in</span> <span class="main">:</span> <span class="entity">process_relativization_in_type</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">synthesis_opt</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_spec</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">process_relativization_in</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">synthesis_opt_c</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">synthesis_c</span> <span class="main">=</span> <span class="inner_quoted">"synthesis: "</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">synthesis_opt</span> <span class="keyword2"><span class="keyword">of</span></span> 
          SOME <span class="entity">synthesis</span> <span class="main">=&gt;</span> 
            <span class="main">(</span>
              <span class="keyword2"><span class="keyword">case</span></span> <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">synthesis</span> <span class="keyword2"><span class="keyword">of</span></span> 
                  SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">synthesis_c</span> ^ <span class="inner_quoted">"user-defined simpset"</span>
                <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">synthesis_c</span> ^ <span class="inner_quoted">"default simpset"</span>
            <span class="main">)</span>
        <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">synthesis_c</span> ^ <span class="inner_quoted">"none"</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elems_c</span> <span class="main">=</span> <span class="inner_quoted">"elements:"</span> ^ 
      <span class="main">(</span>
        <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">elems</span> 
        <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">" none"</span> 
        <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"\n"</span> ^
          <span class="main">(</span>
            <span class="entity">elems</span>
            |&gt; map <span class="main">(</span><span class="entity">string_of_elem_ctxt</span> <span class="entity">ctxt</span><span class="main">)</span>
            |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\t"</span> ^ <span class="entity">c</span><span class="main">)</span>
            |&gt; String.concatWith <span class="inner_quoted">"\n"</span>
          <span class="main">)</span>
      <span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_specs_c</span> <span class="main">=</span> <span class="inner_quoted">"type_specs: "</span> ^
      ML_Syntax.print_list <span class="main">(</span>ML_Syntax.print_pair I I<span class="main">)</span> <span class="entity">type_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_spec_c</span> <span class="main">=</span>
      <span class="inner_quoted">"definition: "</span> ^ <span class="main">(</span><span class="entity">thm_spec</span> |&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span> |&gt; Thm.string_of_thm <span class="entity">lthy</span><span class="main">)</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_c</span> <span class="main">=</span> <span class="inner_quoted">"lthy: unknown local theory"</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out_c</span> <span class="main">=</span> <span class="main">[</span><span class="entity">synthesis_opt_c</span><span class="main">,</span> <span class="entity">elems_c</span><span class="main">,</span> <span class="entity">type_specs_c</span><span class="main">,</span> <span class="entity">thm_spec_c</span><span class="main">,</span> <span class="entity">lthy_c</span><span class="main">]</span> 
      |&gt; String.concatWith <span class="inner_quoted">"\n"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out_c</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_relativization</span> 
  <span class="main">(</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">synthesis</span><span class="main">,</span> <span class="entity">assms</span><span class="main">,</span> <span class="entity">type_specs</span><span class="main">,</span> <span class="entity">thm_spec</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">:</span> 
      <span class="entity">process_relativization_in_type</span>
  <span class="main">)</span> <span class="main">=</span> <span class="entity">CTR.process_relativization</span> <span class="entity">synthesis</span> <span class="entity">assms</span> <span class="entity">type_specs</span> <span class="entity">thm_spec</span> <span class="entity">lthy</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_test_suite_process_relativization</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_suite_process_relativization</span> <span class="main">=</span> <span class="entity">UT_Test_Suite.init</span>
      <span class="inner_quoted">"process_relativization"</span>
      <span class="entity">process_relativization</span>
      <span class="main">(</span><span class="entity">process_relativization_string_of_input</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="entity">string_of_pp_out</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">test_suite_process_relativization</span>
    |&gt; <span class="entity">test_eq_trivial</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_def</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_binrel</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_binrel_ftv</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_dup_stvs</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_dup_binrel_ftvs</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_no_relator</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_invalid_relator</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">execute_test_suite_process_relativization</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="entity">UT_Test_Suite.execute</span> <span class="main">(</span><span class="entity">mk_test_suite_process_relativization</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="files/CTR_TEST_PROCESS_CTR_RELATOR.ML">
<div class="head">
<h1>File ‹CTR_TEST_PROCESS_CTR_RELATOR.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/Tests/CTR_TEST_PROCESS_CTR_RELATOR.ML
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CTR_TEST_PROCESS_CTR_RELATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">process_ctr_relator_in_type</span>
<span class="keyword1"><span class="keyword">val</span></span> execute_test_suite_process_ctr_relator <span class="main">:</span> 
  <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">process_ctr_relator_in_type</span><span class="main">,</span> local_theory<span class="main">)</span>
    <span class="entity">UT_Test_Suite.test_results_suite</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ctr_test_process_ctr_relator</span> <span class="main">:</span> <span class="entity">CTR_TEST_PROCESS_CTR_RELATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>



<span class="comment1">(**** Auxiliary ****)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_msg_ctr_relator</span> <span class="entity">msg</span> <span class="main">=</span> <span class="inner_quoted">"ctr_relator: "</span> ^ <span class="entity">msg</span><span class="main">;</span>



<span class="comment1">(*** Data ***)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">process_ctr_relator_in_type</span> <span class="main">=</span> string * <span class="entity">Proof.context</span><span class="main">;</span>




<span class="comment1">(**** Tests ****)</span>



<span class="comment1">(*** Exceptions ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_const</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"a + b"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span> <span class="inner_quoted">"the input must be a constant term"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"not a constant"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_body_bool</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"Cons"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span> 
      <span class="inner_quoted">"the body of the type of the input must be bool"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"not bool body"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_binders_2</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"Ex"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span> 
      <span class="inner_quoted">"the type of the input must have more than two binders"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">UT_Test_Suite.assert_exception</span> <span class="inner_quoted">"not two binders"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_binders_binrelT</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"not_binders_binrelT"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"all of the binders associated with the type of the input"</span> ^
      <span class="inner_quoted">"except the last two must be the binary relation types"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"not binary relation types"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_no_dup_binrelT</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"no_dup_binrelT"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"the types of the binders of the binary relations associated "</span> ^
      <span class="inner_quoted">"with the type of the input must have no duplicates"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"no duplicates in the binary relation types"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_binders_binrelT_ftv_stv</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"not_binders_binrelT_ftv_stv"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"the types of the binders of the binary relation types associated "</span> ^
      <span class="inner_quoted">"with the input type must be either free type variables or "</span> ^
      <span class="inner_quoted">"schematic type variables"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"not binrel type ftv or stv"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_type_constructor_lhs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"not_type_constructor_lhs"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"the last two binders of the input type must be "</span> ^
      <span class="inner_quoted">"the results of an application of a type constructor"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"not type constructor lhs"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_type_constructor_rhs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"not_type_constructor_rhs"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"the last two binders of the input type must be "</span> ^
      <span class="inner_quoted">"the results of an application of a type constructor"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"not type constructor rhs"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_identical_type_constructors_lhs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"not_identical_type_constructors_lhs"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"the sequences of the input types to the type constructors that are "</span> ^
      <span class="inner_quoted">"associated with the last two binders of the input type must be "</span> ^
      <span class="inner_quoted">"identical to the sequences of the types formed by concatenating the "</span> ^
      <span class="inner_quoted">"type variables associated with the left hand side and the right "</span> ^
      <span class="inner_quoted">"hand side of the binary relation types, respectively"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"not identical type constructors lhs"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_exc_not_identical_type_constructors_rhs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_quoted">"not_identical_type_constructors_rhs"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_msg</span> <span class="main">=</span> <span class="entity">mk_msg_ctr_relator</span>
      <span class="inner_quoted">"the sequences of the input types to the type constructors that are "</span> ^
      <span class="inner_quoted">"associated with the last two binders of the input type must be "</span> ^
      <span class="inner_quoted">"identical to the sequences of the types formed by concatenating the "</span> ^
      <span class="inner_quoted">"type variables associated with the left hand side and the right "</span> ^
      <span class="inner_quoted">"hand side of the binary relation types, respectively"</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">UT_Test_Suite.assert_exception</span> 
      <span class="inner_quoted">"not identical type constructors rhs"</span> <span class="entity">args</span> <span class="main">(</span>ERROR <span class="entity">err_msg</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>




<span class="comment1">(**** Test suite ****)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctr_relator_string_of_input</span> 
   <span class="main">(</span><span class="entity">process_ctr_relator_in</span> <span class="main">:</span> <span class="entity">process_ctr_relator_in_type</span><span class="main">)</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">process_ctr_relator_in</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name_c</span> <span class="main">=</span> <span class="inner_quoted">"constant name: "</span> ^ <span class="entity">c</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_c</span> <span class="main">=</span> <span class="inner_quoted">"lthy: unknown context"</span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">out_c</span> <span class="main">=</span> <span class="main">[</span><span class="entity">name_c</span><span class="main">,</span> <span class="entity">ctxt_c</span><span class="main">]</span> |&gt; String.concatWith <span class="inner_quoted">"\n"</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">out_c</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_ctr_relator</span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">:</span> <span class="entity">process_ctr_relator_in_type</span><span class="main">)</span> <span class="main">=</span> 
  <span class="entity">CTR_Relators.process_ctr_relator</span> <span class="entity">c</span> <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_test_suite_process_ctr_relator</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_suite_process_ctr_relator</span> <span class="main">=</span> <span class="entity">UT_Test_Suite.init</span>
      <span class="inner_quoted">"process_ctr_relator"</span>
      <span class="entity">process_ctr_relator</span>
      <span class="entity">process_ctr_relator_string_of_input</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_quoted">"lthy: unknown local theory"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">test_suite_process_ctr_relator</span>
    |&gt; <span class="entity">test_exc_not_const</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_body_bool</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_binders_2</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_binders_binrelT</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_no_dup_binrelT</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_binders_binrelT_ftv_stv</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_type_constructor_lhs</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_type_constructor_rhs</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_identical_type_constructors_lhs</span> <span class="entity">ctxt</span>
    |&gt; <span class="entity">test_exc_not_identical_type_constructors_rhs</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">execute_test_suite_process_ctr_relator</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="entity">UT_Test_Suite.execute</span> <span class="main">(</span><span class="entity">mk_test_suite_process_ctr_relator</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span></pre>
</div><div id="Reference_Prerequisites">
<div class="head">
<h1>Theory Reference_Prerequisites</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Reference_Prerequisites.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Reference prerequisites›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Reference_Prerequisites
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/LaTeXsugar.html">HOL-Library.LaTeXsugar</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹~~/src/Doc/antiquote_setup.ML›</span>


<span class="comment1">(* Copied from Transfer.thy in the main library. *)</span>
<span class="keyword1"><span class="command">notation</span></span> rel_fun <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">===&gt;</span>"</span> 55<span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> map_fun <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">---&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/ISABELLE_HOME/src/Doc/antiquote_setup.ML">
<div class="head">
<h1>File ‹~~/src/Doc/antiquote_setup.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Doc/antiquote_setup.ML
    Author:     Makarius

Auxiliary antiquotations for the Isabelle manuals.
*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Antiquote_Setup</span><span class="main">:</span> <span class="keyword2"><span class="keyword">sig</span></span> <span class="keyword2"><span class="keyword">end</span></span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* misc utils *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">translate</span> <span class="entity">f</span> <span class="main">=</span> Symbol.explode #&gt; map <span class="entity">f</span> #&gt; implode<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">clean_string</span> <span class="main">=</span> <span class="entity">translate</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="inner_quoted">"_"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\\_"</span>
    <span class="main">|</span> <span class="inner_quoted">"#"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\\#"</span>
    <span class="main">|</span> <span class="inner_quoted">"$"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\\$"</span>
    <span class="main">|</span> <span class="inner_quoted">"%"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\\%"</span>
    <span class="main">|</span> <span class="inner_quoted">"&lt;"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"$&lt;$"</span>
    <span class="main">|</span> <span class="inner_quoted">"&gt;"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"$&gt;$"</span>
    <span class="main">|</span> <span class="inner_quoted">"{"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\\{"</span>
    <span class="main">|</span> <span class="inner_quoted">"|"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"$\\mid$"</span>
    <span class="main">|</span> <span class="inner_quoted">"}"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"\\}"</span>
    <span class="main">|</span> <span class="inner_quoted">"‐"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"-"</span>
    <span class="main">|</span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">c</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_name</span> <span class="inner_quoted">"…"</span> <span class="main">=</span> <span class="inner_quoted">"dots"</span>
  <span class="main">|</span> <span class="entity">clean_name</span> <span class="inner_quoted">".."</span> <span class="main">=</span> <span class="inner_quoted">"ddot"</span>
  <span class="main">|</span> <span class="entity">clean_name</span> <span class="inner_quoted">"."</span> <span class="main">=</span> <span class="inner_quoted">"dot"</span>
  <span class="main">|</span> <span class="entity">clean_name</span> <span class="inner_quoted">"_"</span> <span class="main">=</span> <span class="inner_quoted">"underscore"</span>
  <span class="main">|</span> <span class="entity">clean_name</span> <span class="inner_quoted">"{"</span> <span class="main">=</span> <span class="inner_quoted">"braceleft"</span>
  <span class="main">|</span> <span class="entity">clean_name</span> <span class="inner_quoted">"}"</span> <span class="main">=</span> <span class="inner_quoted">"braceright"</span>
  <span class="main">|</span> <span class="entity">clean_name</span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">s</span> |&gt; <span class="entity">translate</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="inner_quoted">"_"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"-"</span> <span class="main">|</span> <span class="inner_quoted">"‐"</span> <span class="main">=&gt;</span> <span class="inner_quoted">"-"</span> <span class="main">|</span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">c</span><span class="main">)</span><span class="main">;</span>


<span class="comment1">(* ML text *)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_val</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> ML_Lex.read <span class="inner_quoted">"fn _ =&gt; ("</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">");"</span>
  <span class="main">|</span> <span class="entity">ml_val</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="entity">toks2</span><span class="main">)</span> <span class="main">=</span>
      ML_Lex.read <span class="inner_quoted">"fn _ =&gt; ("</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">" : "</span> @ <span class="entity">toks2</span> @ ML_Lex.read <span class="inner_quoted">");"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_op</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> ML_Lex.read <span class="inner_quoted">"fn _ =&gt; (op "</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">");"</span>
  <span class="main">|</span> <span class="entity">ml_op</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="entity">toks2</span><span class="main">)</span> <span class="main">=</span>
      ML_Lex.read <span class="inner_quoted">"fn _ =&gt; (op "</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">" : "</span> @ <span class="entity">toks2</span> @ ML_Lex.read <span class="inner_quoted">");"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_type</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> ML_Lex.read <span class="inner_quoted">"val _ = NONE : ("</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">") option;"</span>
  <span class="main">|</span> <span class="entity">ml_type</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="entity">toks2</span><span class="main">)</span> <span class="main">=</span>
      ML_Lex.read <span class="inner_quoted">"val _ = [NONE : ("</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">") option, NONE : ("</span> @
        <span class="entity">toks2</span> @ ML_Lex.read <span class="inner_quoted">") option];"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_exception</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> ML_Lex.read <span class="inner_quoted">"fn _ =&gt; ("</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">" : exn);"</span>
  <span class="main">|</span> <span class="entity">ml_exception</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="entity">toks2</span><span class="main">)</span> <span class="main">=</span>
      ML_Lex.read <span class="inner_quoted">"fn _ =&gt; ("</span> @ <span class="entity">toks1</span> @ ML_Lex.read <span class="inner_quoted">" : "</span> @ <span class="entity">toks2</span> @ ML_Lex.read <span class="inner_quoted">" -&gt; exn);"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_structure</span> <span class="main">(</span><span class="entity">toks</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
  ML_Lex.read <span class="inner_quoted">"functor XXX() = struct structure XX = "</span> @ <span class="entity">toks</span> @ ML_Lex.read <span class="inner_quoted">" end;"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_functor</span> <span class="main">(</span>Antiquote.Text <span class="entity">tok</span> :: <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      ML_Lex.read <span class="inner_quoted">"ML_Env.check_functor "</span> @
      ML_Lex.read <span class="main">(</span>ML_Syntax.print_string <span class="main">(</span>ML_Lex.content_of <span class="entity">tok</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">ml_functor</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Bad ML functor specification"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_name</span> <span class="main">=</span>
  ML_Lex.kind_of #&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">kind</span> <span class="main">=&gt;</span> <span class="entity">kind</span> <span class="main">=</span> ML_Lex.Ident <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">kind</span> <span class="main">=</span> ML_Lex.Long_Ident<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ml_name</span> <span class="entity">txt</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> filter <span class="entity">is_name</span> <span class="main">(</span>ML_Lex.tokenize <span class="entity">txt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">toks</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">[</span><span class="main">_</span><span class="main">]</span> <span class="main">=&gt;</span> ML_Lex.flatten <span class="entity">toks</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Single ML name expected in input: "</span> ^ quote <span class="entity">txt</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_ml</span> <span class="entity">source</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>Input.source_content <span class="entity">source</span><span class="main">)</span><span class="main">,</span> ML_Lex.read_source <span class="entity">source</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">index_ml</span> <span class="entity">name</span> <span class="entity">kind</span> <span class="entity">ml</span> <span class="main">=</span> <span class="entity">Thy_Output.antiquotation_raw</span> <span class="entity">name</span>
  <span class="main">(</span>Scan.lift <span class="main">(</span>Args.text_input -- Scan.option <span class="main">(</span>Args.colon |-- Args.text_input<span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">source1</span><span class="main">,</span> <span class="entity">opt_source2</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">txt1</span><span class="main">,</span> <span class="entity">toks1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep_ml</span> <span class="entity">source1</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">txt2</span><span class="main">,</span> <span class="entity">toks2</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt_source2</span> <span class="keyword2"><span class="keyword">of</span></span>
          SOME <span class="entity">source</span> <span class="main">=&gt;</span> <span class="entity">prep_ml</span> <span class="entity">source</span>
        <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">txt</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">txt2</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">txt1</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">kind</span> <span class="main">=</span> <span class="inner_quoted">"type"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">txt1</span> ^ <span class="inner_quoted">" = "</span> ^ <span class="entity">txt2</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">kind</span> <span class="main">=</span> <span class="inner_quoted">"exception"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">txt1</span> ^ <span class="inner_quoted">" of "</span> ^ <span class="entity">txt2</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> Symbol_Pos.is_identifier <span class="main">(</span>Long_Name.base_name <span class="main">(</span><span class="entity">ml_name</span> <span class="entity">txt1</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">txt1</span> ^ <span class="inner_quoted">": "</span> ^ <span class="entity">txt2</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">txt1</span> ^ <span class="inner_quoted">" : "</span> ^ <span class="entity">txt2</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">txt'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">kind</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">txt</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">kind</span> ^ <span class="inner_quoted">" "</span> ^ <span class="entity">txt</span><span class="main">;</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pos</span> <span class="main">=</span> Input.pos_of <span class="entity">source1</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
        ML_Context.eval_in <span class="main">(</span>SOME <span class="entity">ctxt</span><span class="main">)</span> ML_Compiler.flags <span class="entity">pos</span> <span class="main">(</span><span class="entity">ml</span> <span class="main">(</span><span class="entity">toks1</span><span class="main">,</span> <span class="entity">toks2</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="entity">msg</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="entity">msg</span> ^ Position.here <span class="entity">pos</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">kind'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">kind</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"ML"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"ML "</span> ^ <span class="entity">kind</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Latex.block
       <span class="main">[</span>Latex.string <span class="main">(</span><span class="inner_quoted">"\\indexdef{}{"</span> ^ <span class="entity">kind'</span> ^ <span class="inner_quoted">"}{"</span> ^ <span class="entity">clean_string</span> <span class="main">(</span><span class="entity">ml_name</span> <span class="entity">txt1</span><span class="main">)</span> ^ <span class="inner_quoted">"}"</span><span class="main">)</span><span class="main">,</span>
        <span class="entity">Thy_Output.verbatim</span> <span class="entity">ctxt</span> <span class="entity">txt'</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
   <span class="main">(</span><span class="entity">index_ml</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹index_ML›</span></span> <span class="inner_quoted">""</span> <span class="entity">ml_val</span> #&gt;
    <span class="entity">index_ml</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹index_ML_op›</span></span> <span class="inner_quoted">"infix"</span> <span class="entity">ml_op</span> #&gt;
    <span class="entity">index_ml</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹index_ML_type›</span></span> <span class="inner_quoted">"type"</span> <span class="entity">ml_type</span> #&gt;
    <span class="entity">index_ml</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹index_ML_exception›</span></span> <span class="inner_quoted">"exception"</span> <span class="entity">ml_exception</span> #&gt;
    <span class="entity">index_ml</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹index_ML_structure›</span></span> <span class="inner_quoted">"structure"</span> <span class="entity">ml_structure</span> #&gt;
    <span class="entity">index_ml</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹index_ML_functor›</span></span> <span class="inner_quoted">"functor"</span> <span class="entity">ml_functor</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* named theorems *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Thy_Output.antiquotation_raw</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹named_thms›</span></span>
    <span class="main">(</span>Scan.repeat <span class="main">(</span><span class="entity">Attrib.thm</span> -- Scan.lift <span class="main">(</span>Args.parens Args.name<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">name</span><span class="main">)</span> <span class="main">=&gt;</span>
        Output.output
          <span class="main">(</span><span class="entity">Document_Antiquotation.format</span> <span class="entity">ctxt</span>
            <span class="main">(</span><span class="entity">Document_Antiquotation.delimit</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Thy_Output.pretty_thm</span> <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> ^
        enclose <span class="inner_quoted">"\\rulename{"</span> <span class="inner_quoted">"}"</span> <span class="main">(</span>Output.output <span class="entity">name</span><span class="main">)</span><span class="main">)</span>
      #&gt; space_implode <span class="inner_quoted">"\\par\\smallskip%\n"</span>
      #&gt; Latex.string #&gt; single
      #&gt; <span class="entity">Thy_Output.isabelle</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>


<span class="comment1">(* Isabelle/Isar entities (with index) *)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">no_check</span> <span class="main">(</span><span class="main">_</span><span class="main">:</span> <span class="entity">Proof.context</span><span class="main">)</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">:</span> Position.T<span class="main">)</span> <span class="main">=</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_keyword</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">pos</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> Keyword.is_keyword <span class="main">(</span>Thy_Header.get_keywords' <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Bad outer syntax keyword "</span> ^ quote <span class="entity">name</span> ^ Position.here <span class="entity">pos</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_system_option</span> <span class="entity">ctxt</span> <span class="entity">arg</span> <span class="main">=</span>
  <span class="main">(</span>Completion.check_option <span class="main">(</span>Options.default <span class="main">(</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">arg</span><span class="main">;</span> true<span class="main">)</span>
    <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> enclose <span class="inner_quoted">"{"</span> <span class="inner_quoted">"}"</span> o <span class="entity">clean_string</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">entity</span> <span class="entity">check</span> <span class="entity">markup</span> <span class="entity">binding</span> <span class="entity">index</span> <span class="main">=</span>
  <span class="entity">Thy_Output.antiquotation_raw</span>
    <span class="main">(</span><span class="entity">binding</span> |&gt; Binding.map_name <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name</span> <span class="main">=&gt;</span> <span class="entity">name</span> ^
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">index</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="inner_quoted">""</span> <span class="main">|</span> SOME true <span class="main">=&gt;</span> <span class="inner_quoted">"_def"</span> <span class="main">|</span> SOME false <span class="main">=&gt;</span> <span class="inner_quoted">"_ref"</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>Scan.lift <span class="main">(</span>Scan.optional <span class="main">(</span>Args.parens Args.name<span class="main">)</span> <span class="inner_quoted">""</span> -- Args.name_position<span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">logic</span><span class="main">,</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">pos</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">kind</span> <span class="main">=</span> <span class="entity">translate</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="inner_quoted">"_"</span> <span class="main">=&gt;</span> <span class="inner_quoted">" "</span> <span class="main">|</span> <span class="entity">c</span> <span class="main">=&gt;</span> <span class="entity">c</span><span class="main">)</span> <span class="main">(</span>Binding.name_of <span class="entity">binding</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hyper_name</span> <span class="main">=</span>
          <span class="inner_quoted">"{"</span> ^ Long_Name.append <span class="entity">kind</span> <span class="main">(</span>Long_Name.append <span class="entity">logic</span> <span class="main">(</span><span class="entity">clean_name</span> <span class="entity">name</span><span class="main">)</span><span class="main">)</span> ^ <span class="inner_quoted">"}"</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hyper</span> <span class="main">=</span>
          enclose <span class="main">(</span><span class="inner_quoted">"\\hyperlink"</span> ^ <span class="entity">hyper_name</span> ^ <span class="inner_quoted">"{"</span><span class="main">)</span> <span class="inner_quoted">"}"</span> #&gt;
          <span class="entity">index</span> <span class="main">=</span> SOME true ? enclose <span class="main">(</span><span class="inner_quoted">"\\hypertarget"</span> ^ <span class="entity">hyper_name</span> ^ <span class="inner_quoted">"{"</span><span class="main">)</span> <span class="inner_quoted">"}"</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">idx</span> <span class="main">=</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">index</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> <span class="inner_quoted">""</span>
          <span class="main">|</span> SOME <span class="entity">is_def</span> <span class="main">=&gt;</span>
              <span class="inner_quoted">"\\index"</span> ^ <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_def</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"def"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"ref"</span><span class="main">)</span> ^ <span class="entity">arg</span> <span class="entity">logic</span> ^ <span class="entity">arg</span> <span class="entity">kind</span> ^ <span class="entity">arg</span> <span class="entity">name</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> Context_Position.is_reported <span class="entity">ctxt</span> <span class="entity">pos</span> <span class="keyword2"><span class="keyword">then</span></span> ignore <span class="main">(</span><span class="entity">check</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">pos</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">latex</span> <span class="main">=</span>
          <span class="entity">idx</span> ^
          <span class="main">(</span>Output.output <span class="entity">name</span>
            |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">markup</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> I <span class="keyword2"><span class="keyword">else</span></span> enclose <span class="main">(</span><span class="inner_quoted">"\\"</span> ^ <span class="entity">markup</span> ^ <span class="inner_quoted">"{"</span><span class="main">)</span> <span class="inner_quoted">"}"</span><span class="main">)</span>
            |&gt; <span class="entity">hyper</span> o enclose <span class="inner_quoted">"\\mbox{\\isa{"</span> <span class="inner_quoted">"}}"</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Latex.string <span class="entity">latex</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">entity_antiqs</span> <span class="entity">check</span> <span class="entity">markup</span> <span class="entity">kind</span> <span class="main">=</span>
  <span class="entity">entity</span> <span class="entity">check</span> <span class="entity">markup</span> <span class="entity">kind</span> NONE #&gt;
  <span class="entity">entity</span> <span class="entity">check</span> <span class="entity">markup</span> <span class="entity">kind</span> <span class="main">(</span>SOME true<span class="main">)</span> #&gt;
  <span class="entity">entity</span> <span class="entity">check</span> <span class="entity">markup</span> <span class="entity">kind</span> <span class="main">(</span>SOME false<span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup
   <span class="main">(</span><span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹syntax›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">Outer_Syntax.check_command</span> <span class="inner_quoted">"isacommand"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹command›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">check_keyword</span> <span class="inner_quoted">"isakeyword"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹keyword›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">check_keyword</span> <span class="inner_quoted">"isakeyword"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹element›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">Method.check_name</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹method›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">Attrib.check_name</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹attribute›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹fact›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹variable›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹case›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">Document_Antiquotation.check</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹antiquotation›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">Document_Antiquotation.check_option</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹antiquotation_option›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> Document_Marker.check <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹document_marker›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">"isasystem"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹setting›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">check_system_option</span> <span class="inner_quoted">"isasystem"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹system_option›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹inference›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">no_check</span> <span class="inner_quoted">"isasystem"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹executable›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="entity">Isabelle_Tool.check</span> <span class="inner_quoted">"isatool"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹tool›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> ML_Context.check_antiquotation <span class="inner_quoted">""</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹ML_antiquotation›</span></span> #&gt;
    <span class="entity">entity_antiqs</span> <span class="main">(</span>K <span class="entity">JEdit.check_action</span><span class="main">)</span> <span class="inner_quoted">"isasystem"</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹action›</span></span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="CTR_Introduction">
<div class="head">
<h1>Theory CTR_Introduction</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR_Introduction.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Introduction›</span></span>
<span class="keyword1"><span class="command">theory</span></span> CTR_Introduction
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Background›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The framework <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Conditional Transfer Rule›</span></span></span></span> provides several experimental
Isabelle/Isar commands that are aimed at the automation of unoverloading
of definitions and synthesis of conditional transfer rules in Isabelle/HOL.
›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Structure and organization›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The remainder of the reference manual is organized into two explicit sections,
one for each sub-framework of the CTR:
\begin{itemize}
\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Unoverload Definition›</span></span></span></span> (UD): automated elimination of sort
constraints and unoverloading of definitions
\item <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Conditional Transfer Rule›</span></span></span></span> (CTR): automated synthesis of 
relativized definitions and transfer rules
\end{itemize}
It should be noted that the abbreviation CTR will be used to 
refer both to the general framework and the sub-framework.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\newpage›</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="UD_Reference">
<div class="head">
<h1>Theory UD_Reference</h1>
</div>
<pre class="source"><span class="comment1">(* Title: UD/UD_Reference.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Reference manual for the UD.
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹UD›</span></span>
<span class="keyword1"><span class="command">theory</span></span> UD_Reference
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="#UD">UD</a>
    <span class="quoted">"<a href="#Reference_Prerequisites">../Reference_Prerequisites</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Introduction›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Background›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This section presents a reference manual for the (sub-)framework UD. 
The framework UD can be used for the elimination of sort constraints and
unoverloading of definitions in the object logic Isabelle/HOL of the 
formal proof assistant Isabelle \cite{paulson_natural_1986}. 
The framework UD evolved from the author's work on the extension of the 
framework Types-To-Sets (see \cite{blanchette_types_2016,kuncar_types_2019}, 
\cite{immler_smooth_2019} and \cite{immler_automation_2019} for a 
description of the framework Types-To-Sets, but not the author's extension) 
and builds upon certain ideas expressed in \cite{kaufmann_mechanized_2010}.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Purpose and scope›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The primary functionality of the framework is available via the Isabelle/Isar 
command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span>. This command automates the processes of the 
elimination of sort constrains and unoverloading of definitions.
Thus, the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> allows for the synthesis
of the convenience constants and theorems that are usually needed for the 
application of the derivation step 2 of the original relativization algorithm
of Types-To-Sets (see \cite{blanchette_types_2016}). However, 
it is expected that the command can be useful for other purposes.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Related and previous work›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The functionality provided by the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> shares similarities
with the functionality provided by the algorithms for the elimination of
sort constraints and elimination of overloading that were 
presented in \cite{kaufmann_mechanized_2010}
and with the algorithms associated with the command 
\mbox{\textbf{unoverload\_definition}} that was proposed
in \cite{immler_automation_2019}. 
Nonetheless, technically, unlike \mbox{\textbf{unoverload\_definition}}, 
the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> does
not require the additional axiom UO associated with Types-To-Sets for 
its operation (see \cite{blanchette_types_2016}, 
\cite{immler_automation_2019}), it uses the definitional axioms
instead of arbitrary theorems supplied by the user
and can be used for unoverloading almost any overloaded constants, 
not merely the constants overloaded using the Isabelle's type-class 
infrastructure 
\cite{nipkow_type_1991,wenzel_type_1997,altenkirch_constructive_2007}.

It should also be mentioned that the Isabelle/ML code from the main 
distribution of Isabelle was frequently reused during the 
development of the UD.
›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Theory\label{sec:ud_theory}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
It is assumed that there exists a variable $ud_{\mathsf{with}}$ that stores theorems 
of the form $c_{\tau} = c_{\mathsf{with}}\ \bar{*}$, where $c_{\tau}$ and $c_{\mathsf{with}}$ are 
distinct constant-instances and $\bar{*}$ is a finite sequence of unresolvable 
constant-instances, such that, if $c_{\tau}$ depends on a type 
variable $\alpha_{\Upsilon}$, with $\Upsilon$ being a type class that depends 
on the overloaded constants $\bar{*'}$, then $\bar{*}$ contains $\bar{*'}$
as a subsequence. The binary operation $\cup$ is defined 
in a manner such that for any sequences $\bar{*}$ and $\bar{*'}$, 
$\bar{*} \cup \bar{*'}$ is a sequence that consists of all elements of the 
union of the elements of $\bar{*}$ and $\bar{*'}$ without duplication. 
The inputs to the algorithm associated with the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span>
are assumed to be a constant-instance $c_{\sigma}$ and a well-formed 
definitional theory $D$.
Given the constant-instance $c_{\sigma}$, there exists at most
one definitional axiom $c_{\tau} = \phi_{\tau}\left[\bar{*}\right]$ 
in $D$ such that $c_{\sigma} \leq c_{\tau}$: otherwise the orthogonality 
of $D$ and, therefore, the well-formedness of $D$ are violated 
($\phi$ is assumed to be parameterized by the types that it can have with 
respect to the type substitution operation, and $\bar{*}$ in
$c_{\tau} = \phi_{\tau}\left[\bar{*}\right]$ is a list of all uninterpreted
constant-instances that occur in $\phi_{\tau}\left[\bar{*}\right]$).

If a definitional axiom $c_{\tau}=\phi_{\tau}\left[\bar{*}\right]$ 
such that $c_{\sigma} \leq c_{\tau}$ exists for the constant-instance 
$c_{\sigma}$, then the following derivation is applied to it by the algorithm
\[
\infer[(6)]
{\vdash c_{\sigma} = c_{\mathsf{with}}\ \left(\bar{*} \cup \bar{*'}\right)}
{
\infer[(5)]
{
\vdash c_{\mathsf{with}}\ \left(\bar{*} \cup \bar{*'}\right) = 
\phi_{\mathsf{with}}\left[\bar{*} \cup \bar{*'}\right]
}
{
\infer[(4)]
{\vdash c_{\mathsf{with}}\ ?\bar{f} = \phi_{\mathsf{with}}\left[?\bar{f}\right]}
{
\infer[(3)]
{\vdash c_{\mathsf{with}} = (\lambda \bar{f}.\ \phi_{\mathsf{with}}\left[\bar{f}\right])}
{
\infer[(2)]
{\vdash c_{\sigma}=\phi_{\mathsf{with}}\left[\bar{*} \cup \bar{*'}\right]}
{
\infer[(1)]
{\vdash c_{\sigma}=\phi_{\sigma}\left[\bar{*}\right]}
{\vdash c_{\tau}=\phi_{\tau}\left[\bar{*}\right]}
}
}
}
}
}
\]
In step 1, the previously established property $c_{\sigma} \leq c_{\tau}$ is
used to create the (extended variant of the) type substitution map $\rho$
such that $\sigma = \rho \left( \tau \right)$ (see \cite{kuncar_types_2015}) 
and perform the type substitution in 
$c_{\tau}=\phi_{\tau}\left[\bar{*}\right]$ to obtain
$c_{\sigma}=\phi_{\sigma}\left[\bar{*}\right]$; in step 2, the
collection of theorems $ud_{\mathsf{with}}$ is unfolded, using it as 
a term rewriting system, possibly introducing further uninterpreted constants
$\bar{*'}$; in step 3, the term on the right hand side of the 
theorem is processed by removing the sort constraints from all type variables 
that occur in it, replacing every uninterpreted constant-instance (this 
excludes all built-in constants of Isabelle/HOL) that occurs in 
it by a fresh term variable, 
and applying the abstraction until the resulting term is closed:
this term forms the right hand side of a new definitional axiom 
of a fresh constant $c_{\mathsf{with}}$ (if the conditions associated with the 
definitional principles of Isabelle/HOL \cite{yang_comprehending_2017} are 
satisfied); step 4 is justified by the beta-contraction; step 5 is a 
substitution of the uninterpreted constants $\bar{*} \cup \bar{*'}$; 
step 6 follows trivially from the results of the application of steps 2 and 5. 

Assuming that the definitional axiom for the input to the
algorithm $c_{\sigma}$ does not have any occurrences of uninterpreted 
constants and there is exactly one type-variable $\alpha_{\Upsilon}$ that occurs
in $c_{\sigma}$, with $\Upsilon$ being a type class that depends on the 
overloaded constants $\bar{*}$, the algorithm can be restated as follows:
\[
\infer[(6)]
{\vdash c_{\sigma}\left[?\alpha_{\Upsilon}\right] = c_{\mathsf{with}}\left[?\alpha_{\Upsilon}\right]\ \bar{*}}
{
\infer[(5)]
{
\vdash c_{\mathsf{with}}\left[?\alpha_{\Upsilon}\right]\ \bar{*} = \phi_{\mathsf{with}}\left[?\alpha_{\Upsilon}, \bar{*}\right]
}
{
\infer[(4)]
{\vdash c_{\mathsf{with}}\left[?\alpha\right]\ ?\bar{f}\left[?\alpha\right] = \phi_{\mathsf{with}}\left[?\alpha, ?\bar{f}\right]}
{
\infer[(3)]
{\vdash c_{\mathsf{with}}\left[?\alpha\right] = (\lambda \bar{f}\left[?\alpha\right].\ \phi_{\mathsf{with}}\left[?\alpha, \bar{f}\right])}
{
\infer[(2)]
{\vdash c_{\sigma}\left[?\alpha_{\Upsilon}\right] = \phi_{\mathsf{with}}\left[?\alpha_{\Upsilon}, \bar{*}\right]}
{
\infer[(1)]
{\vdash c_{\sigma}\left[?\alpha_{\Upsilon}\right] = \phi_{\sigma}\left[?\alpha_{\Upsilon}\right]}
{\vdash c_{\tau}\left[?\alpha\right]=\phi_{\tau}\left[?\alpha\right]}
}
}
}
}
}
\]

The implementation of the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> closely follows the steps of 
the algorithm outlined above. Thus, at the end of the successful
execution, the command declares the constant $c_{\mathsf{with}}$ and stores the 
constant-instance definition that is obtained at the end of step 3 of
the algorithm UD; furthermore, the command stores the theorem that is 
obtained after the execution of step 6 of the algorithm.

Unlike the classical overloading elimination algorithm, 
the algorithm employed in the implementation
of the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not recursive. Thus, the users are responsible 
for maintaining an adequate collection of theorems $ud_{\mathsf{with}}$. 
Nonetheless, in this case, the users can provide their own 
unoverloaded constants $c_{\mathsf{with}}$ and the associated theorems 
$c_{\sigma} = c_{\mathsf{with}}\ \bar{*}$ for any constant-instance $c_{\sigma}$. 
From the perspective of the relativization algorithm associated with
Types-To-Sets this can be useful because there is no 
guarantee that the automatically synthesized constants $c_{\mathsf{with}}$ 
will possess desirable parametricity characteristics
(e.g., see \cite{kuncar_types_2015} and \cite{immler_smooth_2019}).
Unfortunately, the implemented algorithm still suffers from the fundamental 
limitation that was already outlined in \cite{kaufmann_mechanized_2010}, 
\cite{blanchette_types_2016} and \cite{kuncar_types_2019}: 
it does not offer a solution for handling the 
constants whose types contain occurrences of the type constructors whose 
type definitions contain occurrences of unresolvable overloading.

›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Syntax›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This subsection presents the syntactic categories that are associated with the 
command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span>. It is important to note that the presentation is 
only approximate.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\begin{matharray}{rcl}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command_def</span></span> "ud"<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; : &amp; <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>theory → theory›</span></span></span></span>\\
\end{matharray}

  <span class="antiquoted"><span class="operator"><span class="antiquoted"><span class="operator">┉</span></span></span></span>

  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">rail</span><span class="hidden">&gt;</span></span></span>‹<span class="keyword1"><span class="keyword1">@</span></span><span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> binding<span class="keyword3"><span class="keyword3">?</span></span> const mixfix<span class="keyword3"><span class="keyword3">?</span></span>›</span></span>

  <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">ud</span></span></span></span>›</span></span></span></span> (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span>) <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>const›</span></span></span></span> (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mixfix›</span></span></span></span>) provides access to the algorithm for
the elimination of sort constraints and unoverloading of definitions
that was described in subsection \ref{sec:ud_theory}.
The optional binding <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span> is used for the specification
of the names of the entities added by the command to the theory and the 
optional argument <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mixfix›</span></span></span></span> is used for the specification 
of the concrete inner syntax for the constant in the usual manner
(e.g., see \cite{wenzel_isabelle/isar_2019-1}). 
If either <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mixfix›</span></span></span></span> are not specified by the user, then the command
introduces sensible defaults. Following the specification of the 
definition of the constant, an additional theorem that establishes
the relationship between the newly introduced constant and the 
constant provided by the user as an input is established and added 
to the dynamic fact <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">ud_with</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Examples\label{sec:ud_ex}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
In this subsection, some of the capabilities of the framework UD are 
demonstrated by example. The examples that are presented in this subsection are 
expected to be sufficient for beginning an independent exploration of the 
framework, but do not cover the entire spectrum of the functionality 
and the problems that one may encounter while using it.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Type classes›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
We begin the exploration of the capabilities of the framework by considering
the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
The constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono<span class="antiquote"><span class="antiquote">}</span></span></span></span> is an overloaded constant that is defined 
in the standard library of Isabelle/HOL \cite{noauthor_isabellehol_2020} as  
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [names_short = true] mono_def<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
\end{center}
for any <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [show_sorts] <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">::</span></span>order<span class="main"><span class="main">⇒</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">::</span></span>order"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Technically, there exist two distinct constants that are associated with
the definition of the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
(see, e.g., \cite{berardi_local_2009} 
for further details): <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> order.mono<span class="antiquote"><span class="antiquote">}</span></span></span></span> that is provided by the 
Isabelle system automatically and the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono<span class="antiquote"><span class="antiquote">}</span></span></span></span> itself.
The constants are unoverloaded successively using the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
›</span></span>
<span class="keyword1"><span class="command">ud</span></span> <span class="quoted"><span class="quoted">‹order.mono›</span></span>
<span class="keyword1"><span class="command">ud</span></span> mono' <span class="quoted"><span class="quoted">‹mono›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The invocation of the commands above declares the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
that is defined as
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> mono.with_def<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}
and provides the theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> given by
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> mono.with<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}
and the theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono'.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> given by
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> mono'.with<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\end{center}
The theorems establish the relationship between the unoverloaded constant
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> and the overloaded constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
both theorems are automatically added to the dynamic fact 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">ud_with</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Low-level overloading›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The following example closely follows Example 5 in section 5.2. in 
\cite{kaufmann_mechanized_2010}. 
›</span></span>

<span class="keyword1"><span class="command">consts</span></span> pls <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
pls_nat <span class="main">≡</span> <span class="quoted"><span class="quoted">"pls<span class="main">::</span>nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
pls_times <span class="main">≡</span> <span class="quoted"><span class="quoted">"pls<span class="main">::</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pls_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pls_nat</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pls_times</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pls_times</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span>pls <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">y</span><span class="main">)</span><span class="main">,</span> pls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">ud</span></span> pls_nat <span class="quoted"><span class="quoted">‹pls<span class="main">::</span>nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat›</span></span>
<span class="keyword1"><span class="command">ud</span></span> pls_times <span class="quoted"><span class="quoted">‹pls<span class="main">::</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span>›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
As expected, two new unoverloaded constants are produced via
the invocations of the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span> above. The first constant,
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹pls_nat.with›</span></span>, corresponds to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pls::nat ⇒ nat ⇒ nat›</span></span></span></span> and is given by
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> pls_nat.with_def<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
\end{center}
the second constant, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹pls_times.with›</span></span>, corresponds to
\begin{center}
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pls::'a × 'b ⇒ 'a × 'b ⇒ 'a × 'b›</span></span></span></span> 
\end{center}
and is given by 
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> pls_times.with_def<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\end{center}
The theorems that establish the relationship between the overloaded and
the unoverloaded constants are given by 
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> pls_nat.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
\end{center}
and 
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> pls_times.with<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\end{center}
The definitions of the constants <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹pls_nat.with›</span></span> and 
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹pls_times.with›</span></span> are consistent with the ones suggested in
\cite{kaufmann_mechanized_2010}. Nonetheless, of course, it is
important to keep in mind that the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span>
has a more restricted scope of applicability than the
algorithm suggested in \cite{kaufmann_mechanized_2010}.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\newpage›</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="CTR_Reference">
<div class="head">
<h1>Theory CTR_Reference</h1>
</div>
<pre class="source"><span class="comment1">(* Title: CTR/CTR_Reference.thy
   Author: Mihails Milehins
   Copyright 2021 (C) Mihails Milehins

Reference manual for the CTR.
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹CTR›</span></span>
<span class="keyword1"><span class="command">theory</span></span> CTR_Reference
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="#CTR">CTR</a>
    <span class="quoted">"<a href="#UD_Reference">../UD/UD_Reference</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Introduction›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Background›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This section presents a reference manual for the (sub-)framework CTR. 
The framework CTR can be used for the automated synthesis of transfer rules and
relativization of definitions.
CTR evolved from the frameworks Conditional Parametricity (CP) 
\cite{gilcher_conditional_2017} and Types-To-Sets 
(see \cite{blanchette_types_2016} and \cite{immler_smooth_2019})
that are available as part of the main distribution of Isabelle.
However, it does not require either the axiom LT or the axiom UO
associated with the Types-To-Sets for its operation.
The framework CTR introduces the following Isabelle/Isar commands:
\[
\begin{array}{rcl}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; : &amp;  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>local_theory → local_theory›</span></span></span></span>\\
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr_relator<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; : &amp;  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>local_theory → local_theory›</span></span></span></span>\\
\end{array}
\]
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Purpose and scope›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The primary functionality of the CTR is available via the
command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span>, given a definition 
of a constant, attempts to provide a conditional transfer rule for this 
constant, possibly under arbitrary user-defined side conditions.
The process of the synthesis of a transfer rule for 
a constant may or may not involve declaration and synthesis of a 
definition of a new (relativized) constant.
The command provides an interface for the application of two 
plausible algorithms for the synthesis of the transfer rules
that have a restricted and overlapping scope of applicability. 
The first algorithm (\textit{CTR I}) was developed and implemented in 
\cite{gilcher_conditional_2017}. 
An outline of the second algorithm (\textit{CTR II}) 
was proposed in \cite{lammich_automatic_2013} and \cite{immler_smooth_2019}:
CTR II relies on the functionality of the 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer_prover<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
(see subsection 4.6 in \cite{kuncar_types_2015}). 
More details about CTR II are given in the next subsection.

The command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr_relator<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be used for the 
registration of the so-called \textit{ctr-relators} that need to be provided 
for every non-nullary type constructor that occurs in the type of the 
constant-instance whose definition is passed as an argument to CTR II. 
However, as a fallback solution, the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> may 
use the relators that are associated with the standard BNF infrastructure
of Isabelle/HOL (e.g., see \cite{traytel_foundational_2012}).
The only necessary condition for the registration of the ctr-relators 
is that they must satisfy the type-constraint 
associated with the action of a BNF on relations (e.g., see 
\cite{traytel_foundational_2012} or \cite{blanchette_bindings_2019}).
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Related and previous work›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
As already mentioned, the framework CTR evolved from the framework 
CP that is available as part of the main 
distribution of Isabelle. Furthermore, CTR provides an interface to the main 
functionality associated with the framework CP 
and builds upon many ideas that could be associated with it. 

The primary reason for the development of the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> instead 
of extending the implementation of the existing command
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> parametric_constant<span class="antiquote"><span class="antiquote">}</span></span></span></span> was the philosophy of non-intervention with the
development version of Isabelle that was adopted at the onset of the design of 
the CTR. Perhaps, in the future, the functionality of the aforementioned 
commands can be integrated.

It should also be mentioned that the Isabelle/ML code from the main 
distribution of Isabelle was frequently reused during the 
development of CTR.
›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Theory›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
Assume the existence of an underlying well-formed 
definitional theory $D$ and an associated HOL signature $\Sigma$.
Furthermore, assume the existence of a map $\mathsf{ctr}_{\mathsf{Rel}}$ from a
finite set of non-nullary type constructors to ctr-relators, mapping each 
non-nullary type constructor in its domain to a valid ctr-relator for this 
type constructor. 

The inputs to CTR II are a context $\Gamma$,
a constant-instance definition 
\mbox{$\vdash c_{?\bar{\gamma}\ K} = \phi\left[?\bar{\gamma}\right]$} 
of the constant-instance $c_{?\bar{\gamma}\ K}$ 
and the map $\mathsf{trp}$ from the set of all schematic type variables
in ?$\bar{\gamma}$ to the set of (fixed) binary relations 
$x_{\alpha\rightarrow\beta\rightarrow\mathbb{B}}$ in $\Gamma$
($?\bar{\gamma}$ corresponds to a sequence of all 
distinct type variables that occur in the type $?\bar{\gamma}\ K$, 
while $K$, applied using a postfix notation, contains all information about 
the type constructors of the type $?\bar{\gamma}\ K$,
such that the non-nullary type constructors associated with $K$  
form a subset of the domain of $\mathsf{ctr}_{\mathsf{Rel}}$).
CTR II consists of three parts: 
\textit{synthesis of a parametricity relation},
\textit{synthesis of a transfer rule} and \textit{post-processing}.

\textbf{Synthesis of a parametricity relation}. 
An outline of an algorithm for the conversion of a type to a
parametricity relation is given in subsection 4.1.1 in \cite{kuncar_types_2015}.
Thus, every nullary type constructor in $?\bar{\gamma}\ K$ is replaced 
by the identity relation $=$, every non-nullary type constructor $\kappa$ 
in $?\bar{\gamma}\ K$ is replaced by its corresponding ctr-relator 
$\mathsf{ctr}_{\mathsf{Rel}}\left(\kappa\right)$ and every type variable 
$?\gamma$ in $?\bar{\gamma}\ K$ is replaced by $\mathsf{trp}\left(?\gamma\right)$, 
obtaining the parametricity relation 
$R_{\bar{\alpha}\ K \rightarrow \bar{\beta}\ K \rightarrow\mathbb{B}}$.

\textbf{Synthesis of a transfer rule}. 
First, the goal
$R\ \left(\phi\left[\bar{\alpha}\right]\right)\ \left(\phi\left[\bar{\beta}\right]\right)$
is created in $\Gamma$ and an attempt to prove it is made 
using the algorithm associated with 
the method <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer_prover<span class="antiquote"><span class="antiquote">}</span></span></span></span> (see subsection 4.6 in 
\cite{kuncar_types_2015}).
If the proof is successful, nothing else needs to be done in this part.
Otherwise, an attempt to find a solution for $?a$ in 
$R\ \left(?a_{\bar{\alpha}\ K}\right)\ \left(\phi\left[\bar{\beta}\right]\right)$ 
is made, once again, using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer_prover<span class="antiquote"><span class="antiquote">}</span></span></span></span>
(see subsection 4.6 in \cite{kuncar_types_2015}). 
Of course, the success of this part is not guaranteed 
(see \cite{kuncar_types_2015} for more information).
In summary, the result of the successful completion of the synthesis 
is a transfer rule 
$\Gamma \vdash R\ \left(\psi\left[\bar{\alpha},\bar{x}\right]\right)\ \left(\phi\left[\bar{\beta}\right]\right)$,
where $\bar{x}$ is used to denote a sequence of typed variables,
each of which occurs free in the context $\Gamma$. 

\textbf{Post-processing}. If 
$\psi\left[\bar{\alpha},\bar{x}\right] = \phi\left[\bar{\alpha}\right]$
after the successful completion of part 2 of the algorithm, then 
the definitions of the constant-instances $c_{\bar{\alpha}\ K}$
and $c_{\bar{\beta}\ K}$ are folded, resulting in the deduction
\mbox{$\Gamma \vdash R\ \left( c_{\bar{\alpha}\ K}\right)\ \left(c_{\bar{\beta}\ K}\right)$}. Otherwise, if 
\mbox{$\psi\left[\bar{\alpha},\bar{x}\right]\ \neq \phi\left[\bar{\alpha}\right]$},
then a new constant $d$ is declared such that 
\mbox{$\vdash d_{\sigma\left[?\bar{\alpha}\right]} = \left(\lambda \bar{x}.\ \psi\left[?\bar{\alpha},\bar{x}\right]\right)$},
where $\sigma$ is determined uniquely by $\bar{x}$ and $?\bar{\alpha}\ K$. 
In this case, 
\mbox{$\Gamma \vdash R\ \left(\psi\left[\bar{\alpha},\bar{x}\right]\right)\ \left(\phi\left[\bar{\beta}\right]\right)$}
can be restated as 
\mbox{$\Gamma \vdash R\ (d_{\sigma\left[\bar{\alpha}\right]}\ \bar{x})\ \left(c_{\bar{\beta}\ K}\right)$}.
This result can be exported to the global theory context and forms a 
conditional transfer rule for $c_{?\bar{\gamma}\ K}$.
›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Syntax›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Background›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This subsection presents the syntactic categories that are associated with the 
command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> and closely related auxiliary commands and attributes. 
It is important to note that the presentation is only approximate.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ctr_relator›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
\begin{matharray}{rcl}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command_def</span></span> ctr_relator<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; : &amp;  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>local_theory → local_theory›</span></span></span></span>
\end{matharray}

  <span class="antiquoted"><span class="operator"><span class="antiquoted"><span class="operator">┉</span></span></span></span>

  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">rail</span><span class="hidden">&gt;</span></span></span>‹<span class="keyword1"><span class="keyword1">@</span></span><span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr_relator<span class="antiquote"><span class="antiquote">}</span></span></span></span> term›</span></span>

  <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">ctr_relator</span></span></span></span>›</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>c›</span></span></span></span> saves the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ctr relator›</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>c›</span></span></span></span> to a database of 
ctr relators for future reference. A ctr relator is defined as any constant 
that has the type of the form
\begin{center} 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(α<span class="hidden">⇩</span><sub>1</sub>⇒β<span class="hidden">⇩</span><sub>1</sub>⇒𝔹)⇒…⇒(α<span class="hidden">⇩</span><sub>n</sub>⇒β<span class="hidden">⇩</span><sub>n</sub>⇒𝔹)⇒(α<span class="hidden">⇩</span><sub>1</sub>…α<span class="hidden">⇩</span><sub>n</sub>)κ⇒(β<span class="hidden">⇩</span><sub>1</sub>…β<span class="hidden">⇩</span><sub>n</sub>)κ⇒𝔹›</span></span></span></span>,
\end{center}
where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α<span class="hidden">⇩</span><sub>1</sub>…α<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>β<span class="hidden">⇩</span><sub>1</sub>…β<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span> are distinct type variables,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span> is a positive integer and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>κ›</span></span></span></span> is a type constructor.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ctr›</span></span></span></span>›</span></span>

<span class="comment1">(*
Certain elements of the content presented below were copied from the theory 
Doc/Isar_Rel/Spec.thy in the main library of Isabelle. 
*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
\begin{matharray}{rcl}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command_def</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; : &amp;  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>local_theory → local_theory›</span></span></span></span> \\
\end{matharray}

  <span class="antiquoted"><span class="operator"><span class="antiquoted"><span class="operator">┉</span></span></span></span>

  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">rail</span><span class="hidden">&gt;</span></span></span>‹
    <span class="keyword1"><span class="keyword1">@</span></span><span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'parametricity'</span></span> <span class="keyword3"><span class="keyword3">|</span></span> <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'relativization'</span></span> rlt) in_def
    <span class="keyword2"><span class="keyword2">;</span></span>
    rlt<span class="keyword2"><span class="keyword2">:</span></span> 
      (synthesis<span class="keyword3"><span class="keyword3">*</span></span>) 
      (cce<span class="keyword3"><span class="keyword3">*</span></span>)
      trp
    <span class="keyword2"><span class="keyword2">;</span></span>
    synthesis<span class="keyword2"><span class="keyword2">:</span></span> <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'synthesis'</span></span> (thm<span class="keyword3"><span class="keyword3">*</span></span>)
    <span class="keyword2"><span class="keyword2">;</span></span>
    cce<span class="keyword2"><span class="keyword2">:</span></span>
      <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'fixes'</span></span> vars <span class="keyword3"><span class="keyword3">|</span></span>
      <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'assumes'</span></span> (props <span class="keyword3"><span class="keyword3">+</span></span> <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'and'</span></span>)
    <span class="keyword2"><span class="keyword2">;</span></span>
    trp<span class="keyword2"><span class="keyword2">:</span></span> (<span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'trp'</span></span> (<span class="inner_quoted"><span class="inner_quoted">'('</span></span> type_var term <span class="inner_quoted"><span class="inner_quoted">')'</span></span> <span class="keyword3"><span class="keyword3">+</span></span> <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">'and'</span></span>))<span class="keyword3"><span class="keyword3">?</span></span>
    <span class="keyword2"><span class="keyword2">;</span></span>
    in_def<span class="keyword2"><span class="keyword2">:</span></span> ((binding <span class="keyword1"><span class="keyword1">@</span></span><span class="inner_quoted"><span class="inner_quoted">':'</span></span>)<span class="keyword3"><span class="keyword3">?</span></span> thm mixfix<span class="keyword3"><span class="keyword3">?</span></span>) <span class="keyword3"><span class="keyword3">+</span></span> and
  ›</span></span>

  <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">ctr</span></span></span></span>›</span></span></span></span> provides access to two algorithms for the automated synthesis of 
the transfer rules and the relativization of constants based on their 
definitions. 

    <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "parametricity"<span class="antiquote"><span class="antiquote">}</span></span></span></span> indicates that CTR I needs
to be invoked by the command.

    <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "relativization"<span class="antiquote"><span class="antiquote">}</span></span></span></span> indicates that CTR II needs to be 
invoked by the command. 

    <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "synthesis"<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>thm›</span></span></span></span> indicates that the relativization of the 
inputs needs to be performed and post-processed using the simplifier with 
the collection of rewrite rules stated as the fact <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>thm›</span></span></span></span>. If the optional 
argument <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>thm›</span></span></span></span> is not provided, then the default <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>simpset›</span></span></span></span> is used for 
post-processing. If the keyword <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "synthesis"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is omitted, 
then no attempt to perform the relativization is made. 
The keyword <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">keyword</span></span> "synthesis"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is relevant only for CTR II.

    <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "trp"<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(?a<span class="hidden">⇩</span><sub>1</sub> A<span class="hidden">⇩</span><sub>1</sub>)›</span></span></span></span> <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">and</span></span></span></span>›</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>…›</span></span></span></span> <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">and</span></span></span></span>›</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(?a<span class="hidden">⇩</span><sub>n</sub> A<span class="hidden">⇩</span><sub>n</sub>)›</span></span></span></span> indicates 
that the type variable that has the indexname <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>?a<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>1≤i≤n›</span></span></span></span>, 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span> is a non-negative integer) is meant to 
correspond to the binary relation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> in the transfer relation constructed by 
the command prior to the statement of the transfer rule (for further 
information see subsection 4.1 in \cite{kuncar_types_2015}). This is relevant only
for CTR II.

    <span class="antiquoted"><span class="antiquoted">➧</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "in"<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(b:) def_thm (mixfix)›</span></span></span></span> is used for
the specification of the input to the algorithms that are associated with 
the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span>. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>def_thm›</span></span></span></span> is meant to be a fact that 
consists of exactly one theorem of the form
\begin{center}
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A a<span class="hidden">⇩</span><sub>1</sub>…a<span class="hidden">⇩</span><sub>n</sub> ≃ f a<span class="hidden">⇩</span><sub>1</sub>…a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span>,
\end{center}
where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> is a constant, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>≃›</span></span></span></span> is either meta- or object-equality, 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span> is a non-negative integer,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>a<span class="hidden">⇩</span><sub>1</sub>…a<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span> are schematic variables and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> is a suitable formula in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span> 
arguments (however, there are further implicit restrictions). 
If a new constant is introduced by the command, then the optional argument
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mixfix›</span></span></span></span> is used for the specification 
of the concrete inner syntax for the constant 
in the usual manner
(e.g. see \cite{wenzel_isabelle/isar_2019-1}). The optional binding <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span> is
used for the specification of the names of the entities that
are provided after the successful execution of the command. It is hoped
that the algorithm chosen for the specification of the names 
is sufficiently intuitive and does not require further explanation.
If either <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b›</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mixfix›</span></span></span></span> are not specified by the user, then the command
introduces sensible defaults.
Multiple theorems may be provided after the
keyword <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">element</span></span> "in"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, employing the keyword <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">⬚</span></span><span class="raw_text"><span class="raw_text">‹<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">and</span></span></span></span>›</span></span></span></span> as a separator.
In this case, the parameterized algorithm associated with the command is
applied repeatedly to each input theorem in the order of their specification
from left to right and the local context is augmented incrementally. 
›</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Examples\label{sec:ctr_ex}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
In this subsection, some of the capabilities of the framework CTR are 
demonstrated by example. The examples that are presented in this subsection are 
expected to be sufficient to begin an independent exploration of the framework, 
but do not cover the entire spectrum of the functionality and the problems that 
one may encounter while using it.

The examples that are presented in this subsection continue the example 
of the application of the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ud<span class="antiquote"><span class="antiquote">}</span></span></span></span>
to the definition of the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono<span class="antiquote"><span class="antiquote">}</span></span></span></span> that was presented in 
subsection \ref{sec:ud_ex}.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹CTR I›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
As already explained, the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> ctr<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be used to invoke
the algorithm associated with the command <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> parametric_constant<span class="antiquote"><span class="antiquote">}</span></span></span></span>
for the synthesis of the parametricity relation for a given constant. For
example, the invocation of
›</span></span> 
<span class="keyword1"><span class="command">ctr</span></span> <span class="keyword2"><span class="keyword">parametricity</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> mono<span class="main">:</span> mono.with_def
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
generates the transfer rule <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono_transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span>: 
\begin{center}
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [display, mode=IfThenNoBox] mono_transfer<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}
A detailed explanation of the underlying algorithm can be found in 
\cite{gilcher_conditional_2017}.
›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹CTR II›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The first example demonstrates how CTR II can be 
used to produce a conditional parametricity property, identical 
to the parametricity property produced by CTR I:
›</span></span>

<span class="keyword1"><span class="command">ctr</span></span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_total <span class="free">A1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'a</span> <span class="quoted"><span class="free">A1</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="free">A2</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono'<span class="main">:</span> mono.with_def

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This produces the theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono'.transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [display, mode=IfThenNoBox] mono'.transfer<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
which is identical to the theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono_transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span> generated
by CTR I in the previous subsection.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
Of course, there is very little value in trying to establish a parametricity
property using CTR II due to the availability of CTR I. However,
it is often the case that the constant is not parametric under a given
set of side conditions. Nonetheless, in this case, it is often possible to
define a new (relativized) constant that is related to the original 
constant under the transfer relation associated with the original constant. 
It is expected that the most common application of CTR II will be the
synthesis of the relativized constants.

For example, suppose one desires to find a conditional transfer rule for
the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> such that (using the conventions from the 
previous example) the relation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A1›</span></span></span></span> is right total, but not, necessarily, 
left total. While, under such restriction on the involved relations, the 
constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> mono.with<span class="antiquote"><span class="antiquote">}</span></span></span></span> is no longer conditionally parametric, its 
relativization exists and can be found using the transfer prover. To automate 
the relativization process, the user merely needs to add the keyword 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">keyword</span></span> "synthesis"<span class="antiquote"><span class="antiquote">}</span></span></span></span> immediately after the keyword 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">keyword</span></span> "relativization"<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
›</span></span>

<span class="keyword1"><span class="command">ctr</span></span> <span class="keyword2"><span class="keyword">relativization</span></span>
  <span class="keyword2"><span class="keyword">synthesis</span></span> <span class="dynamic"><span class="dynamic">ctr_simps</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_domain_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domainp <span class="free">A1</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">U1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"right_total <span class="free">A1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">trp</span></span> <span class="main">(</span><span class="tvar">?'a</span> <span class="quoted"><span class="free">A1</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span><span class="tvar">?'b</span> <span class="quoted"><span class="free">A2</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> mono_ow<span class="main">:</span> mono.with_def

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This produces the definition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono_ow_def<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [display, mode=IfThenNoBox] mono_ow_def<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and the theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] mono_ow.transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [display, mode=IfThenNoBox] mono_ow.transfer<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

It should be noted that, given that the keyword <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">keyword</span></span> "synthesis"<span class="antiquote"><span class="antiquote">}</span></span></span></span> was
followed by the name of the named collection of theorems 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">ctr_simps</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, this collection was used in post-processing of
the result of the relativization. The users can omit simplification
entirely by specifying the collection <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">ctr_blank</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead
of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">ctr_simps</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\newpage›</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>