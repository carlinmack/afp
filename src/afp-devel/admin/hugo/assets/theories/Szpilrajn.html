<div id="Szpilrajn">
<div class="head">
<h1>Theory Szpilrajn</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Szpilrajn
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(*&gt;*)</span>



<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Introduction"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We formalize the Szpilrajn extension theorem~\cite{Szpilrajn:1930}, also known
as order-extension principal:
  Every strict partial order can be extended to strict linear order. 
This is a formalization of the proof presented in the Wikipedia article~\cite{wiki}.


A strict partial order is a transitive and irreflexive relation:›</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">strict_partial_order</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> trans <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∧</span> irrefl <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1" id="Szpilrajn-show_strict_partial_order"><span class="command">lemma</span></span> show_strict_partial_order<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="free">r</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strict_partial_order <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms strict_partial_order_def<span class="main">)</span>

<span class="keyword1" id="Szpilrajn-strict_partial_order_acyclic"><span class="command">lemma</span></span> strict_partial_order_acyclic<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"strict_partial_order <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> acyclic_irrefl assms strict_partial_order_def trancl_id<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A typical example is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(⊂)</span></span>›</span></span></span></span> on sets:›</span></span>

<span class="keyword1" id="Szpilrajn-strict_partial_order_subset"><span class="command">lemma</span></span> strict_partial_order_subset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"strict_partial_order <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊂</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊂</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trans_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊂</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> irrefl_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A strict linear order has all the properties of a strict partial order, but is also total: ›</span></span>

<span class="keyword1" id="Szpilrajn-strict_linear_order_def"><span class="command">lemma</span></span> strict_linear_order_def<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"strict_linear_order <span class="free">r</span> <span class="main">⟷</span> strict_partial_order <span class="free">r</span> <span class="main">∧</span> total <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> strict_linear_order_on_def strict_partial_order_def<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"The Proof"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A relation <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">r</span></span>›</span></span></span></span> is a strict extension of a base relation <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">base_r</span></span>›</span></span></span></span>
if <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">r</span></span>›</span></span></span></span> is a strict partial order and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">r</span></span>›</span></span></span></span> includes <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">base_r</span></span>›</span></span></span></span>:›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">strict_ext</span> <span class="free"><span class="bound"><span class="entity">base_r</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> strict_partial_order <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∧</span>  <span class="free"><span class="bound"><span class="entity">base_r</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We start by proving that a strict partial order with two incomparable elements
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">x</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">y</span></span>›</span></span></span></span> can be extended to a strict partial order where <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">&lt;</span></span> <span class="free"><span class="free">y</span></span>›</span></span></span></span>. ›</span></span>

<span class="keyword1" id="Szpilrajn-can_extend_partial_order"><span class="command">lemma</span></span> can_extend_partial_order<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> spo<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_partial_order <span class="free">r</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> no1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> no2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">≠</span><span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strict_ext <span class="free">r</span> <span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> strict_ext_def <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI show_strict_partial_order<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> spo <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="free">r</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> strict_partial_order_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_irrefl<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="free">r</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spo strict_partial_order_acyclic<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span> neq no2 rtranclD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>  
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹With this, we can start the proof of the Szpilrajn extension theorem.
For this we will use a variant of Zorns Lemma, which only considers nonempty chains:›</span></span>

<span class="keyword1" id="Szpilrajn-Zorns_po_lemma_nonempty"><span class="command">lemma</span></span> Zorns_po_lemma_nonempty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> po<span class="main">:</span> <span class="quoted"><span class="quoted">"Partial_order <span class="free">r</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> u<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">C</span> <span class="main">∈</span> Chains <span class="free">r</span><span class="main">;</span> <span class="bound">C</span><span class="main">≠</span><span class="main">{}</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">u</span><span class="main">∈</span>Field <span class="free">r</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="bound">C</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">m</span><span class="main">∈</span>Field <span class="free">r</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>Field <span class="free">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">m</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">r</span><span class="main">≠</span><span class="main">{}</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span>Field <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> FieldI2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Zorns_po_lemma <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> empty_iff<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">theorem</span></span> Szpilrajn<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"strict_partial_order <span class="free">base_r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> strict_linear_order <span class="bound">r</span> <span class="main">∧</span> <span class="free">base_r</span> <span class="main">⊆</span> <span class="bound">r</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define an order on the set of strict extensions of the base relation <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">base_r</span></span>›</span></span></span></span>, 
    where <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">r</span></span> <span class="main"><span class="main">≤</span></span> <span class="free"><span class="free">s</span></span>›</span></span></span></span> iff <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">r</span></span> <span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">s</span></span>›</span></span></span></span>:›</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">order_of_orders</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> rel<span class="main">)</span> rel"</span></span> <span class="keyword2"><span class="keyword">where</span></span> order_of_orders_def<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="skolem">order_of_orders</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="bound">r</span><span class="main">⊆</span><span class="bound">s</span> <span class="main">∧</span> strict_ext <span class="free">base_r</span> <span class="bound">r</span> <span class="main">∧</span> strict_ext <span class="free">base_r</span> <span class="bound">s</span> <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> ord_Field<span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="skolem">order_of_orders</span> <span class="main">=</span> <span class="main">{</span><span class="bound">r</span><span class="main">.</span> strict_ext <span class="free">base_r</span> <span class="bound">r</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def order_of_orders_def<span class="main">)</span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now show that this set has a maximum and that any maximum of this set is 
    a strict linear order and as thus is one of the extensions we are looking for.›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We begin by showing the existence of a maximal element <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">m</span></span>›</span></span></span></span> using Zorns Lemma:›</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">m</span><span class="main">∈</span>Field <span class="skolem">order_of_orders</span><span class="main">.</span> 
      <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>Field <span class="skolem">order_of_orders</span><span class="main">.</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">order_of_orders</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">m</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Zorns_po_lemma_nonempty<span class="main">)</span>




    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Zorns Lemma requires us to prove that our <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">order_of_orders</span></span>›</span></span></span></span> is a nonempty  partial order
   and that every nonempty chain has an upper bound. 
   The partial order property is trivial, since we used <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(⊆)</span></span>›</span></span></span></span> for the relation:›</span></span>



    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Partial_order <span class="skolem">order_of_orders</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_of_orders_def order_on_defs refl_on_def Field_def trans_def antisym_def<span class="main">)</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Also, our order is obviously not empty since it contains <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(</span></span><span class="free"><span class="free">base_r</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">base_r</span></span><span class="main"><span class="main">)</span></span>›</span></span></span></span>:›</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">base_r</span><span class="main">,</span> <span class="free">base_r</span><span class="main">)</span><span class="main">∈</span><span class="skolem">order_of_orders</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms strict_ext_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_of_orders_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">order_of_orders</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>


    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next we show that each chain has an upper bound.
    For the upper bound we take the union of all relations in the chain. ›</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">u</span><span class="main">∈</span>Field <span class="skolem">order_of_orders</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="skolem">C</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">order_of_orders</span>"</span></span> 
      <span class="keyword2"><span class="keyword">if</span></span> C_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∈</span> Chains <span class="skolem">order_of_orders</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> C_nonemtpy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">⋃</span></span><span class="skolem"><span class="skolem">C</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obviously each element in the chain is a strict extension of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">base_r</span></span>›</span></span></span></span> by definition
      and as such it is transitive, irreflexive and extends the base relation.›</span></span>

      <span class="keyword1"><span class="command">have</span></span> r_se<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_ext <span class="free">base_r</span> <span class="skolem">r</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">r</span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">C</span>›</span></span> C_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Chains_def order_of_orders_def<span class="main">)</span>

      <span class="keyword1"><span class="command">hence</span></span> r_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"trans <span class="skolem">r</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> r_irrefl<span class="main">:</span> <span class="quoted"><span class="quoted">"irrefl <span class="skolem">r</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> r_extends_base<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">base_r</span> <span class="main">⊆</span> <span class="skolem">r</span>"</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">r</span>
        <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> strict_ext_def strict_partial_order_def<span class="main">)</span>

      <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Because a chain is ordered, the union of the chain is also transitive:›</span></span>

      <span class="keyword1"><span class="command">have</span></span> C_ordered<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">⊆</span><span class="skolem">s</span> <span class="main">∨</span> <span class="skolem">s</span><span class="main">⊆</span><span class="skolem">r</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">C</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">r</span> <span class="skolem">s</span>
        <span class="keyword1"><span class="command">using</span></span> C_def that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Chains_def order_of_orders_def<span class="main">)</span>

      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span><span class="main">⋃</span><span class="skolem">C</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chain_subset_def chain_subset_trans_Union r_trans<span class="main">)</span>

      <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The other properties also can be transferred from the single relations 
       to the union of the chain.
       Therefore the union is also a strict extension of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">base_r</span></span>›</span></span></span></span>: ›</span></span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="main">(</span><span class="main">⋃</span><span class="skolem">C</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> irrefl_def r_irrefl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">base_r</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="skolem">C</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_Sup r_extends_base that<span class="main">)</span>

      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strict_ext <span class="free">base_r</span> <span class="main">(</span><span class="main">⋃</span><span class="skolem">C</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> show_strict_partial_order strict_ext_def that<span class="main">)</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="skolem">C</span><span class="main">)</span> <span class="main">∈</span> Field <span class="skolem">order_of_orders</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹strict_ext <span class="free">base_r</span> <span class="main">(</span><span class="main">⋃</span> <span class="skolem">C</span><span class="main">)</span>›</span></span> ord_Field<span class="main">)</span>

      <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The union is obviously an upper bound for the chain: ›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="skolem">C</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="main">⋃</span> <span class="skolem">C</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">order_of_orders</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper <span class="quoted"><span class="quoted">‹strict_ext <span class="free">base_r</span> <span class="main">(</span><span class="main">⋃</span> <span class="skolem">C</span><span class="main">)</span>›</span></span> order_of_orders_def r_se<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let our maximal element be named <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹max›</span></span></span></span>:›</span></span>

  <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">max</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> max_field<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">max</span><span class="main">∈</span>Field <span class="skolem">order_of_orders</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> is_max<span class="main">:</span> 
        <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>Field <span class="skolem">order_of_orders</span><span class="main">.</span> <span class="main">(</span><span class="skolem">max</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">order_of_orders</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="skolem">max</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> max_field <span class="keyword1"><span class="command">have</span></span> max_se<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_ext <span class="free">base_r</span> <span class="skolem">max</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ord_Field <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> max_spo<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_partial_order <span class="skolem">max</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">base_r</span> <span class="main">⊆</span> <span class="skolem">max</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> strict_ext_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We still have to show, that <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">max</span></span>›</span></span></span></span> is a strict linear order, 
  meaning that it is also a total order: ›</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"total <span class="skolem">max</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span>"</span></span>


    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">max</span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">max</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

      <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Assume that <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">max</span></span>›</span></span></span></span> is not total, and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">x</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">y</span></span>›</span></span></span></span> are incomparable.
      Then we can extend <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">max</span></span>›</span></span></span></span> by setting $x &lt; y$:›</span></span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">max</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">max</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?max'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">max</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> max_spo <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">max</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">max</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span>›</span></span> 
      <span class="keyword1"><span class="command">have</span></span> max'_se_max<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_ext <span class="skolem">max</span> <span class="var">?max'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> can_extend_partial_order<span class="main">)</span>

      <span class="keyword1"><span class="command">hence</span></span> max'_se<span class="main">:</span> <span class="quoted"><span class="quoted">"strict_ext <span class="free">base_r</span> <span class="var">?max'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> <span class="quoted"><span class="quoted">‹<span class="free">base_r</span> <span class="main">⊆</span> <span class="skolem">max</span>›</span></span> strict_ext_def subset_trans<span class="main">)</span>

      <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The extended relation is greater than <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">max</span></span>›</span></span></span></span>, which is a contradiction.›</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">max</span><span class="main">,</span> <span class="var">?max'</span><span class="main">)</span><span class="main">∈</span><span class="skolem">order_of_orders</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> max'_se <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_of_orders_def max_se<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">using</span></span> FieldI2 <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">max</span>›</span></span> is_max <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">with</span></span> max_spo <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strict_linear_order <span class="skolem">max</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> strict_linear_order_def<span class="main">)</span>

  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">base_r</span> <span class="main">⊆</span> <span class="skolem">max</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> strict_linear_order <span class="bound">r</span> <span class="main">∧</span> <span class="free">base_r</span> <span class="main">⊆</span> <span class="bound">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a corollary, we can also show that we can extend any <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹acyclic›</span></span></span></span> relation
to a strict linear order: ›</span></span>

<span class="keyword1"><span class="command">corollary</span></span> can_extend_acyclic_order_to_strict_linear<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"acyclic <span class="free">base_r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> strict_linear_order <span class="bound">r</span> <span class="main">∧</span> <span class="free">base_r</span> <span class="main">⊆</span> <span class="bound">r</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strict_partial_order <span class="main">(</span><span class="free">base_r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> acyclic_irrefl assms trans_trancl <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Szpilrajn r_into_trancl' subset_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let us conclude with an example, showing that there exists a strict linear 
order on sets, which includes the subset relation:›</span></span>

<span class="keyword1" id="Szpilrajn-exists_strict_partial_order_on_sets"><span class="command">lemma</span></span> exists_strict_partial_order_on_sets<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> strict_linear_order <span class="bound">r</span> <span class="main">∧</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊂</span> <span class="bound">y</span><span class="main">}</span> <span class="main">⊆</span> <span class="bound">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> strict_partial_order_subset <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Szpilrajn<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>